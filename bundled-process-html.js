var ProcessHtml = (function () {
    'use strict';

    /** Types of elements found in htmlparser2's DOM */
    var ElementType;
    (function (ElementType) {
        /** Type for the root element of a document */
        ElementType["Root"] = "root";
        /** Type for Text */
        ElementType["Text"] = "text";
        /** Type for <? ... ?> */
        ElementType["Directive"] = "directive";
        /** Type for <!-- ... --> */
        ElementType["Comment"] = "comment";
        /** Type for <script> tags */
        ElementType["Script"] = "script";
        /** Type for <style> tags */
        ElementType["Style"] = "style";
        /** Type for Any tag */
        ElementType["Tag"] = "tag";
        /** Type for <![CDATA[ ... ]]> */
        ElementType["CDATA"] = "cdata";
        /** Type for <!doctype ...> */
        ElementType["Doctype"] = "doctype";
    })(ElementType || (ElementType = {}));
    /**
     * Tests whether an element is a tag or not.
     *
     * @param elem Element to test
     */
    function isTag$1(elem) {
        return (elem.type === ElementType.Tag ||
            elem.type === ElementType.Script ||
            elem.type === ElementType.Style);
    }
    // Exports for backwards compatibility
    /** Type for the root element of a document */
    const Root = ElementType.Root;
    /** Type for Text */
    const Text$1 = ElementType.Text;
    /** Type for <? ... ?> */
    const Directive = ElementType.Directive;
    /** Type for <!-- ... --> */
    const Comment$1 = ElementType.Comment;
    /** Type for <script> tags */
    const Script = ElementType.Script;
    /** Type for <style> tags */
    const Style = ElementType.Style;
    /** Type for Any tag */
    const Tag = ElementType.Tag;
    /** Type for <![CDATA[ ... ]]> */
    const CDATA$1 = ElementType.CDATA;
    /** Type for <!doctype ...> */
    const Doctype = ElementType.Doctype;

    /**
     * This object will be used as the prototype for Nodes when creating a
     * DOM-Level-1-compliant structure.
     */
    class Node {
        constructor() {
            /** Parent of the node */
            this.parent = null;
            /** Previous sibling */
            this.prev = null;
            /** Next sibling */
            this.next = null;
            /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */
            this.startIndex = null;
            /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */
            this.endIndex = null;
        }
        // Read-write aliases for properties
        /**
         * Same as {@link parent}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get parentNode() {
            return this.parent;
        }
        set parentNode(parent) {
            this.parent = parent;
        }
        /**
         * Same as {@link prev}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get previousSibling() {
            return this.prev;
        }
        set previousSibling(prev) {
            this.prev = prev;
        }
        /**
         * Same as {@link next}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get nextSibling() {
            return this.next;
        }
        set nextSibling(next) {
            this.next = next;
        }
        /**
         * Clone this node, and optionally its children.
         *
         * @param recursive Clone child nodes as well.
         * @returns A clone of the node.
         */
        cloneNode(recursive = false) {
            return cloneNode(this, recursive);
        }
    }
    /**
     * A node that contains some data.
     */
    class DataNode extends Node {
        /**
         * @param data The content of the data node
         */
        constructor(data) {
            super();
            this.data = data;
        }
        /**
         * Same as {@link data}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get nodeValue() {
            return this.data;
        }
        set nodeValue(data) {
            this.data = data;
        }
    }
    /**
     * Text within the document.
     */
    class Text extends DataNode {
        constructor() {
            super(...arguments);
            this.type = ElementType.Text;
        }
        get nodeType() {
            return 3;
        }
    }
    /**
     * Comments within the document.
     */
    class Comment extends DataNode {
        constructor() {
            super(...arguments);
            this.type = ElementType.Comment;
        }
        get nodeType() {
            return 8;
        }
    }
    /**
     * Processing instructions, including doc types.
     */
    class ProcessingInstruction extends DataNode {
        constructor(name, data) {
            super(data);
            this.name = name;
            this.type = ElementType.Directive;
        }
        get nodeType() {
            return 1;
        }
    }
    /**
     * A `Node` that can have children.
     */
    class NodeWithChildren extends Node {
        /**
         * @param children Children of the node. Only certain node types can have children.
         */
        constructor(children) {
            super();
            this.children = children;
        }
        // Aliases
        /** First child of the node. */
        get firstChild() {
            var _a;
            return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
        }
        /** Last child of the node. */
        get lastChild() {
            return this.children.length > 0
                ? this.children[this.children.length - 1]
                : null;
        }
        /**
         * Same as {@link children}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get childNodes() {
            return this.children;
        }
        set childNodes(children) {
            this.children = children;
        }
    }
    class CDATA extends NodeWithChildren {
        constructor() {
            super(...arguments);
            this.type = ElementType.CDATA;
        }
        get nodeType() {
            return 4;
        }
    }
    /**
     * The root node of the document.
     */
    class Document extends NodeWithChildren {
        constructor() {
            super(...arguments);
            this.type = ElementType.Root;
        }
        get nodeType() {
            return 9;
        }
    }
    /**
     * An element within the DOM.
     */
    class Element extends NodeWithChildren {
        /**
         * @param name Name of the tag, eg. `div`, `span`.
         * @param attribs Object mapping attribute names to attribute values.
         * @param children Children of the node.
         */
        constructor(name, attribs, children = [], type = name === "script"
            ? ElementType.Script
            : name === "style"
                ? ElementType.Style
                : ElementType.Tag) {
            super(children);
            this.name = name;
            this.attribs = attribs;
            this.type = type;
        }
        get nodeType() {
            return 1;
        }
        // DOM Level 1 aliases
        /**
         * Same as {@link name}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get tagName() {
            return this.name;
        }
        set tagName(name) {
            this.name = name;
        }
        get attributes() {
            return Object.keys(this.attribs).map((name) => {
                var _a, _b;
                return ({
                    name,
                    value: this.attribs[name],
                    namespace: (_a = this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
                    prefix: (_b = this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name],
                });
            });
        }
    }
    /**
     * @param node Node to check.
     * @returns `true` if the node is a `Element`, `false` otherwise.
     */
    function isTag(node) {
        return isTag$1(node);
    }
    /**
     * @param node Node to check.
     * @returns `true` if the node has the type `CDATA`, `false` otherwise.
     */
    function isCDATA(node) {
        return node.type === ElementType.CDATA;
    }
    /**
     * @param node Node to check.
     * @returns `true` if the node has the type `Text`, `false` otherwise.
     */
    function isText(node) {
        return node.type === ElementType.Text;
    }
    /**
     * @param node Node to check.
     * @returns `true` if the node has the type `Comment`, `false` otherwise.
     */
    function isComment(node) {
        return node.type === ElementType.Comment;
    }
    /**
     * @param node Node to check.
     * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
     */
    function isDirective(node) {
        return node.type === ElementType.Directive;
    }
    /**
     * @param node Node to check.
     * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
     */
    function isDocument(node) {
        return node.type === ElementType.Root;
    }
    /**
     * Clone a node, and optionally its children.
     *
     * @param recursive Clone child nodes as well.
     * @returns A clone of the node.
     */
    function cloneNode(node, recursive = false) {
        let result;
        if (isText(node)) {
            result = new Text(node.data);
        }
        else if (isComment(node)) {
            result = new Comment(node.data);
        }
        else if (isTag(node)) {
            const children = recursive ? cloneChildren(node.children) : [];
            const clone = new Element(node.name, { ...node.attribs }, children);
            children.forEach((child) => (child.parent = clone));
            if (node.namespace != null) {
                clone.namespace = node.namespace;
            }
            if (node["x-attribsNamespace"]) {
                clone["x-attribsNamespace"] = { ...node["x-attribsNamespace"] };
            }
            if (node["x-attribsPrefix"]) {
                clone["x-attribsPrefix"] = { ...node["x-attribsPrefix"] };
            }
            result = clone;
        }
        else if (isCDATA(node)) {
            const children = recursive ? cloneChildren(node.children) : [];
            const clone = new CDATA(children);
            children.forEach((child) => (child.parent = clone));
            result = clone;
        }
        else if (isDocument(node)) {
            const children = recursive ? cloneChildren(node.children) : [];
            const clone = new Document(children);
            children.forEach((child) => (child.parent = clone));
            if (node["x-mode"]) {
                clone["x-mode"] = node["x-mode"];
            }
            result = clone;
        }
        else if (isDirective(node)) {
            const instruction = new ProcessingInstruction(node.name, node.data);
            if (node["x-name"] != null) {
                instruction["x-name"] = node["x-name"];
                instruction["x-publicId"] = node["x-publicId"];
                instruction["x-systemId"] = node["x-systemId"];
            }
            result = instruction;
        }
        else {
            throw new Error(`Not implemented yet: ${node.type}`);
        }
        result.startIndex = node.startIndex;
        result.endIndex = node.endIndex;
        if (node.sourceCodeLocation != null) {
            result.sourceCodeLocation = node.sourceCodeLocation;
        }
        return result;
    }
    function cloneChildren(childs) {
        const children = childs.map((child) => cloneNode(child, true));
        for (let i = 1; i < children.length; i++) {
            children[i].prev = children[i - 1];
            children[i - 1].next = children[i];
        }
        return children;
    }

    // Default options
    const defaultOpts = {
        withStartIndices: false,
        withEndIndices: false,
        xmlMode: false,
    };
    class DomHandler {
        /**
         * @param callback Called once parsing has completed.
         * @param options Settings for the handler.
         * @param elementCB Callback whenever a tag is closed.
         */
        constructor(callback, options, elementCB) {
            /** The elements of the DOM */
            this.dom = [];
            /** The root element for the DOM */
            this.root = new Document(this.dom);
            /** Indicated whether parsing has been completed. */
            this.done = false;
            /** Stack of open tags. */
            this.tagStack = [this.root];
            /** A data node that is still being written to. */
            this.lastNode = null;
            /** Reference to the parser instance. Used for location information. */
            this.parser = null;
            // Make it possible to skip arguments, for backwards-compatibility
            if (typeof options === "function") {
                elementCB = options;
                options = defaultOpts;
            }
            if (typeof callback === "object") {
                options = callback;
                callback = undefined;
            }
            this.callback = callback !== null && callback !== void 0 ? callback : null;
            this.options = options !== null && options !== void 0 ? options : defaultOpts;
            this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
        }
        onparserinit(parser) {
            this.parser = parser;
        }
        // Resets the handler back to starting state
        onreset() {
            this.dom = [];
            this.root = new Document(this.dom);
            this.done = false;
            this.tagStack = [this.root];
            this.lastNode = null;
            this.parser = null;
        }
        // Signals the handler that parsing is done
        onend() {
            if (this.done)
                return;
            this.done = true;
            this.parser = null;
            this.handleCallback(null);
        }
        onerror(error) {
            this.handleCallback(error);
        }
        onclosetag() {
            this.lastNode = null;
            const elem = this.tagStack.pop();
            if (this.options.withEndIndices) {
                elem.endIndex = this.parser.endIndex;
            }
            if (this.elementCB)
                this.elementCB(elem);
        }
        onopentag(name, attribs) {
            const type = this.options.xmlMode ? ElementType.Tag : undefined;
            const element = new Element(name, attribs, undefined, type);
            this.addNode(element);
            this.tagStack.push(element);
        }
        ontext(data) {
            const { lastNode } = this;
            if (lastNode && lastNode.type === ElementType.Text) {
                lastNode.data += data;
                if (this.options.withEndIndices) {
                    lastNode.endIndex = this.parser.endIndex;
                }
            }
            else {
                const node = new Text(data);
                this.addNode(node);
                this.lastNode = node;
            }
        }
        oncomment(data) {
            if (this.lastNode && this.lastNode.type === ElementType.Comment) {
                this.lastNode.data += data;
                return;
            }
            const node = new Comment(data);
            this.addNode(node);
            this.lastNode = node;
        }
        oncommentend() {
            this.lastNode = null;
        }
        oncdatastart() {
            const text = new Text("");
            const node = new CDATA([text]);
            this.addNode(node);
            text.parent = node;
            this.lastNode = text;
        }
        oncdataend() {
            this.lastNode = null;
        }
        onprocessinginstruction(name, data) {
            const node = new ProcessingInstruction(name, data);
            this.addNode(node);
        }
        handleCallback(error) {
            if (typeof this.callback === "function") {
                this.callback(error, this.dom);
            }
            else if (error) {
                throw error;
            }
        }
        addNode(node) {
            const parent = this.tagStack[this.tagStack.length - 1];
            const previousSibling = parent.children[parent.children.length - 1];
            if (this.options.withStartIndices) {
                node.startIndex = this.parser.startIndex;
            }
            if (this.options.withEndIndices) {
                node.endIndex = this.parser.endIndex;
            }
            parent.children.push(node);
            if (previousSibling) {
                node.prev = previousSibling;
                previousSibling.next = node;
            }
            node.parent = parent;
            this.lastNode = null;
        }
    }

    const e=/\n/g;function n(n){const o=[...n.matchAll(e)].map((e=>e.index||0));o.unshift(-1);const s=t(o,0,o.length);return e=>r(s,e)}function t(e,n,r){if(r-n==1)return {offset:e[n],index:n+1};const o=Math.ceil((n+r)/2),s=t(e,n,o),l=t(e,o,r);return {offset:s.offset,low:s,high:l}}function r(e,n){return function(e){return Object.prototype.hasOwnProperty.call(e,"index")}(e)?{line:e.index,column:n-e.offset}:r(e.high.offset<n?e.high:e.low,n)}function o(e,t="",r={}){const o="string"!=typeof t?t:r,l="string"==typeof t?t:"",c=e.map(s),f=!!o.lineNumbers;return function(e,t=0){const r=f?n(e):()=>({line:0,column:0});let o=t;const s=[];e:for(;o<e.length;){let n=!1;for(const t of c){t.regex.lastIndex=o;const c=t.regex.exec(e);if(c&&c[0].length>0){if(!t.discard){const e=r(o),n="string"==typeof t.replace?c[0].replace(new RegExp(t.regex.source,t.regex.flags),t.replace):c[0];s.push({state:l,name:t.name,text:n,offset:o,len:c[0].length,line:e.line,column:e.column});}if(o=t.regex.lastIndex,n=!0,t.push){const n=t.push(e,o);s.push(...n.tokens),o=n.offset;}if(t.pop)break e;break}}if(!n)break}return {tokens:s,offset:o,complete:e.length<=o}}}function s(e,n){return {...e,regex:l(e,n)}}function l(e,n){if(0===e.name.length)throw new Error(`Rule #${n} has empty name, which is not allowed.`);if(function(e){return Object.prototype.hasOwnProperty.call(e,"regex")}(e))return function(e){if(e.global)throw new Error(`Regular expression /${e.source}/${e.flags} contains the global flag, which is not allowed.`);return e.sticky?e:new RegExp(e.source,e.flags+"y")}(e.regex);if(function(e){return Object.prototype.hasOwnProperty.call(e,"str")}(e)){if(0===e.str.length)throw new Error(`Rule #${n} ("${e.name}") has empty "str" property, which is not allowed.`);return new RegExp(c(e.str),"y")}return new RegExp(c(e.name),"y")}function c(e){return e.replace(/[-[\]{}()*+!<=:?./\\^$|#\s,]/g,"\\$&")}

    function token(
    onToken,
    onEnd) {
        return (data, i) => {
            let position = i;
            let value = undefined;
            if (i < data.tokens.length) {
                value = onToken(data.tokens[i], data, i);
                if (value !== undefined) {
                    position++;
                }
            }
            return (value === undefined)
                ? { matched: false }
                : {
                    matched: true,
                    position: position,
                    value: value
                };
        };
    }
    function mapInner(r, f) {
        return (r.matched) ? ({
            matched: true,
            position: r.position,
            value: f(r.value, r.position)
        }) : r;
    }
    function mapOuter(r, f) {
        return (r.matched) ? f(r) : r;
    }
    function map(p, mapper) {
        return (data, i) => mapInner(p(data, i), (v, j) => mapper(v, data, i, j));
    }
    function option(p, def) {
        return (data, i) => {
            const r = p(data, i);
            return (r.matched)
                ? r
                : {
                    matched: true,
                    position: i,
                    value: def
                };
        };
    }
    function choice(...ps) {
        return (data, i) => {
            for (const p of ps) {
                const result = p(data, i);
                if (result.matched) {
                    return result;
                }
            }
            return { matched: false };
        };
    }
    function otherwise(pa, pb) {
        return (data, i) => {
            const r1 = pa(data, i);
            return (r1.matched)
                ? r1
                : pb(data, i);
        };
    }
    function takeWhile(p,
    test) {
        return (data, i) => {
            const values = [];
            let success = true;
            do {
                const r = p(data, i);
                if (r.matched && test(r.value, values.length + 1, data, i, r.position)) {
                    values.push(r.value);
                    i = r.position;
                }
                else {
                    success = false;
                }
            } while (success);
            return {
                matched: true,
                position: i,
                value: values
            };
        };
    }
    function many(p) {
        return takeWhile(p, () => true);
    }
    function many1(p) {
        return ab(p, many(p), (head, tail) => [head, ...tail]);
    }
    function ab(pa, pb, join) {
        return (data, i) => mapOuter(pa(data, i), (ma) => mapInner(pb(data, ma.position), (vb, j) => join(ma.value, vb, data, i, j)));
    }
    function left(pa, pb) {
        return ab(pa, pb, (va) => va);
    }
    function right(pa, pb) {
        return ab(pa, pb, (va, vb) => vb);
    }
    function abc(pa, pb, pc, join) {
        return (data, i) => mapOuter(pa(data, i), (ma) => mapOuter(pb(data, ma.position), (mb) => mapInner(pc(data, mb.position), (vc, j) => join(ma.value, mb.value, vc, data, i, j))));
    }
    function middle(pa, pb, pc) {
        return abc(pa, pb, pc, (ra, rb) => rb);
    }
    function all(...ps) {
        return (data, i) => {
            const result = [];
            let position = i;
            for (const p of ps) {
                const r1 = p(data, position);
                if (r1.matched) {
                    result.push(r1.value);
                    position = r1.position;
                }
                else {
                    return { matched: false };
                }
            }
            return {
                matched: true,
                position: position,
                value: result
            };
        };
    }
    function flatten(...ps) {
        return flatten1(all(...ps));
    }
    function flatten1(p) {
        return map(p, (vs) => vs.flatMap((v) => v));
    }
    function chainReduce(acc,
    f) {
        return (data, i) => {
            let loop = true;
            let acc1 = acc;
            let pos = i;
            do {
                const r = f(acc1, data, pos)(data, pos);
                if (r.matched) {
                    acc1 = r.value;
                    pos = r.position;
                }
                else {
                    loop = false;
                }
            } while (loop);
            return {
                matched: true,
                position: pos,
                value: acc1
            };
        };
    }
    function reduceLeft(acc, p,
    reducer) {
        return chainReduce(acc, (acc) => map(p, (v, data, i, j) => reducer(acc, v, data, i, j)));
    }
    function leftAssoc2(pLeft, pOper, pRight) {
        return chain(pLeft, (v0) => reduceLeft(v0, ab(pOper, pRight, (f, y) => [f, y]), (acc, [f, y]) => f(acc, y)));
    }
    function chain(p,
    f) {
        return (data, i) => mapOuter(p(data, i), (m1) => f(m1.value, data, i, m1.position)(data, m1.position));
    }

    const ws = `(?:[ \\t\\r\\n\\f]*)`;
    const nl = `(?:\\n|\\r\\n|\\r|\\f)`;
    const nonascii = `[^\\x00-\\x7F]`;
    const unicode = `(?:\\\\[0-9a-f]{1,6}(?:\\r\\n|[ \\n\\r\\t\\f])?)`;
    const escape = `(?:\\\\[^\\n\\r\\f0-9a-f])`;
    const nmstart = `(?:[_a-z]|${nonascii}|${unicode}|${escape})`;
    const nmchar = `(?:[_a-z0-9-]|${nonascii}|${unicode}|${escape})`;
    const name = `(?:${nmchar}+)`;
    const ident = `(?:[-]?${nmstart}${nmchar}*)`;
    const string1 = `'([^\\n\\r\\f\\\\']|\\\\${nl}|${nonascii}|${unicode}|${escape})*'`;
    const string2 = `"([^\\n\\r\\f\\\\"]|\\\\${nl}|${nonascii}|${unicode}|${escape})*"`;
    const lexSelector = o([
        { name: 'ws', regex: new RegExp(ws) },
        { name: 'hash', regex: new RegExp(`#${name}`, 'i') },
        { name: 'ident', regex: new RegExp(ident, 'i') },
        { name: 'str1', regex: new RegExp(string1, 'i') },
        { name: 'str2', regex: new RegExp(string2, 'i') },
        { name: '*' },
        { name: '.' },
        { name: ',' },
        { name: '[' },
        { name: ']' },
        { name: '=' },
        { name: '>' },
        { name: '|' },
        { name: '+' },
        { name: '~' },
        { name: '^' },
        { name: '$' },
    ]);
    const lexEscapedString = o([
        { name: 'unicode', regex: new RegExp(unicode, 'i') },
        { name: 'escape', regex: new RegExp(escape, 'i') },
        { name: 'any', regex: new RegExp('[\\s\\S]', 'i') }
    ]);
    function sumSpec([a0, a1, a2], [b0, b1, b2]) {
        return [a0 + b0, a1 + b1, a2 + b2];
    }
    function sumAllSpec(ss) {
        return ss.reduce(sumSpec, [0, 0, 0]);
    }
    const unicodeEscapedSequence_ = token((t) => t.name === 'unicode' ? String.fromCodePoint(parseInt(t.text.slice(1), 16)) : undefined);
    const escapedSequence_ = token((t) => t.name === 'escape' ? t.text.slice(1) : undefined);
    const anyChar_ = token((t) => t.name === 'any' ? t.text : undefined);
    const escapedString_ = map(many(choice(unicodeEscapedSequence_, escapedSequence_, anyChar_)), (cs) => cs.join(''));
    function unescape(escapedString) {
        const lexerResult = lexEscapedString(escapedString);
        const result = escapedString_({ tokens: lexerResult.tokens, options: undefined }, 0);
        return result.value;
    }
    function literal(name) {
        return token((t) => t.name === name ? true : undefined);
    }
    const whitespace_ = token((t) => t.name === 'ws' ? null : undefined);
    const optionalWhitespace_ = option(whitespace_, null);
    function optionallySpaced(parser) {
        return middle(optionalWhitespace_, parser, optionalWhitespace_);
    }
    const identifier_ = token((t) => t.name === 'ident' ? unescape(t.text) : undefined);
    const hashId_ = token((t) => t.name === 'hash' ? unescape(t.text.slice(1)) : undefined);
    const string_ = token((t) => t.name.startsWith('str') ? unescape(t.text.slice(1, -1)) : undefined);
    const namespace_ = left(option(identifier_, ''), literal('|'));
    const qualifiedName_ = otherwise(ab(namespace_, identifier_, (ns, name) => ({ name: name, namespace: ns })), map(identifier_, (name) => ({ name: name, namespace: null })));
    const uniSelector_ = otherwise(ab(namespace_, literal('*'), (ns) => ({ type: 'universal', namespace: ns, specificity: [0, 0, 0] })), map(literal('*'), () => ({ type: 'universal', namespace: null, specificity: [0, 0, 0] })));
    const tagSelector_ = map(qualifiedName_, ({ name, namespace }) => ({
        type: 'tag',
        name: name,
        namespace: namespace,
        specificity: [0, 0, 1]
    }));
    const classSelector_ = ab(literal('.'), identifier_, (fullstop, name) => ({
        type: 'class',
        name: name,
        specificity: [0, 1, 0]
    }));
    const idSelector_ = map(hashId_, (name) => ({
        type: 'id',
        name: name,
        specificity: [1, 0, 0]
    }));
    const attrModifier_ = token((t) => {
        if (t.name === 'ident') {
            if (t.text === 'i' || t.text === 'I') {
                return 'i';
            }
            if (t.text === 's' || t.text === 'S') {
                return 's';
            }
        }
        return undefined;
    });
    const attrValue_ = otherwise(ab(string_, option(right(optionalWhitespace_, attrModifier_), null), (v, mod) => ({ value: v, modifier: mod })), ab(identifier_, option(right(whitespace_, attrModifier_), null), (v, mod) => ({ value: v, modifier: mod })));
    const attrMatcher_ = choice(map(literal('='), () => '='), ab(literal('~'), literal('='), () => '~='), ab(literal('|'), literal('='), () => '|='), ab(literal('^'), literal('='), () => '^='), ab(literal('$'), literal('='), () => '$='), ab(literal('*'), literal('='), () => '*='));
    const attrPresenceSelector_ = abc(literal('['), optionallySpaced(qualifiedName_), literal(']'), (lbr, { name, namespace }) => ({
        type: 'attrPresence',
        name: name,
        namespace: namespace,
        specificity: [0, 1, 0]
    }));
    const attrValueSelector_ = middle(literal('['), abc(optionallySpaced(qualifiedName_), attrMatcher_, optionallySpaced(attrValue_), ({ name, namespace }, matcher, { value, modifier }) => ({
        type: 'attrValue',
        name: name,
        namespace: namespace,
        matcher: matcher,
        value: value,
        modifier: modifier,
        specificity: [0, 1, 0]
    })), literal(']'));
    const attrSelector_ = otherwise(attrPresenceSelector_, attrValueSelector_);
    const typeSelector_ = otherwise(uniSelector_, tagSelector_);
    const subclassSelector_ = choice(idSelector_, classSelector_, attrSelector_);
    const compoundSelector_ = map(otherwise(flatten(typeSelector_, many(subclassSelector_)), many1(subclassSelector_)), (ss) => {
        return {
            type: 'compound',
            list: ss,
            specificity: sumAllSpec(ss.map(s => s.specificity))
        };
    });
    const combinator_ = choice(map(literal('>'), () => '>'), map(literal('+'), () => '+'), map(literal('~'), () => '~'), ab(literal('|'), literal('|'), () => '||'));
    const combinatorSeparator_ = otherwise(optionallySpaced(combinator_), map(whitespace_, () => ' '));
    const complexSelector_ = leftAssoc2(compoundSelector_, map(combinatorSeparator_, (c) => (left, right) => ({
        type: 'compound',
        list: [...right.list, { type: 'combinator', combinator: c, left: left, specificity: left.specificity }],
        specificity: sumSpec(left.specificity, right.specificity)
    })), compoundSelector_);
    function parse_(parser, str) {
        if (!(typeof str === 'string' || str instanceof String)) {
            throw new Error('Expected a selector string. Actual input is not a string!');
        }
        const lexerResult = lexSelector(str);
        if (!lexerResult.complete) {
            throw new Error(`The input "${str}" was only partially tokenized, stopped at offset ${lexerResult.offset}!\n` +
                prettyPrintPosition(str, lexerResult.offset));
        }
        const result = optionallySpaced(parser)({ tokens: lexerResult.tokens, options: undefined }, 0);
        if (!result.matched) {
            throw new Error(`No match for "${str}" input!`);
        }
        if (result.position < lexerResult.tokens.length) {
            const token = lexerResult.tokens[result.position];
            throw new Error(`The input "${str}" was only partially parsed, stopped at offset ${token.offset}!\n` +
                prettyPrintPosition(str, token.offset, token.len));
        }
        return result.value;
    }
    function prettyPrintPosition(str, offset, len = 1) {
        return `${str.replace(/(\t)|(\r)|(\n)/g, (m, t, r) => t ? '\u2409' : r ? '\u240d' : '\u240a')}\n${''.padEnd(offset)}${'^'.repeat(len)}`;
    }
    function parse1(str) {
        return parse_(complexSelector_, str);
    }

    function serialize(selector) {
        if (!selector.type) {
            throw new Error('This is not an AST node.');
        }
        switch (selector.type) {
            case 'universal':
                return _serNs(selector.namespace) + '*';
            case 'tag':
                return _serNs(selector.namespace) + _serIdent(selector.name);
            case 'class':
                return '.' + _serIdent(selector.name);
            case 'id':
                return '#' + _serIdent(selector.name);
            case 'attrPresence':
                return `[${_serNs(selector.namespace)}${_serIdent(selector.name)}]`;
            case 'attrValue':
                return `[${_serNs(selector.namespace)}${_serIdent(selector.name)}${selector.matcher}"${_serStr(selector.value)}"${(selector.modifier ? selector.modifier : '')}]`;
            case 'combinator':
                return serialize(selector.left) + selector.combinator;
            case 'compound':
                return selector.list.reduce((acc, node) => {
                    if (node.type === 'combinator') {
                        return serialize(node) + acc;
                    }
                    else {
                        return acc + serialize(node);
                    }
                }, '');
            case 'list':
                return selector.list.map(serialize).join(',');
        }
    }
    function _serNs(ns) {
        return (ns || ns === '')
            ? _serIdent(ns) + '|'
            : '';
    }
    function _codePoint(char) {
        return `\\${char.codePointAt(0).toString(16)} `;
    }
    function _serIdent(str) {
        return str.replace(
        /(^[0-9])|(^-[0-9])|(^-$)|([-0-9a-zA-Z_]|[^\x00-\x7F])|(\x00)|([\x01-\x1f]|\x7f)|([\s\S])/g, (m, d1, d2, hy, safe, nl, ctrl, other) => d1 ? _codePoint(d1) :
            d2 ? '-' + _codePoint(d2.slice(1)) :
                hy ? '\\-' :
                    safe ? safe :
                        nl ? '\ufffd' :
                            ctrl ? _codePoint(ctrl) :
                                '\\' + other);
    }
    function _serStr(str) {
        return str.replace(
        /(")|(\\)|(\x00)|([\x01-\x1f]|\x7f)/g, (m, dq, bs, nl, ctrl) => dq ? '\\"' :
            bs ? '\\\\' :
                nl ? '\ufffd' :
                    _codePoint(ctrl));
    }
    function normalize(selector) {
        if (!selector.type) {
            throw new Error('This is not an AST node.');
        }
        switch (selector.type) {
            case 'compound': {
                selector.list.forEach(normalize);
                selector.list.sort((a, b) => _compareArrays(_getSelectorPriority(a), _getSelectorPriority(b)));
                break;
            }
            case 'combinator': {
                normalize(selector.left);
                break;
            }
            case 'list': {
                selector.list.forEach(normalize);
                selector.list.sort((a, b) => (serialize(a) < serialize(b)) ? -1 : 1);
                break;
            }
        }
        return selector;
    }
    function _getSelectorPriority(selector) {
        switch (selector.type) {
            case 'universal':
                return [1];
            case 'tag':
                return [1];
            case 'id':
                return [2];
            case 'class':
                return [3, selector.name];
            case 'attrPresence':
                return [4, serialize(selector)];
            case 'attrValue':
                return [5, serialize(selector)];
            case 'combinator':
                return [15, serialize(selector)];
        }
    }
    function compareSpecificity(a, b) {
        return _compareArrays(a, b);
    }
    function _compareArrays(a, b) {
        if (!Array.isArray(a) || !Array.isArray(b)) {
            throw new Error('Arguments must be arrays.');
        }
        const shorter = (a.length < b.length) ? a.length : b.length;
        for (let i = 0; i < shorter; i++) {
            if (a[i] === b[i]) {
                continue;
            }
            return (a[i] < b[i]) ? -1 : 1;
        }
        return a.length - b.length;
    }

    class DecisionTree {
        constructor(input) {
            this.branches = weave(toAstTerminalPairs(input));
        }
        build(builder) {
            return builder(this.branches);
        }
    }
    function toAstTerminalPairs(array) {
        const len = array.length;
        const results = new Array(len);
        for (let i = 0; i < len; i++) {
            const [selectorString, val] = array[i];
            const ast = preprocess(parse1(selectorString));
            results[i] = {
                ast: ast,
                terminal: {
                    type: 'terminal',
                    valueContainer: { index: i, value: val, specificity: ast.specificity }
                }
            };
        }
        return results;
    }
    function preprocess(ast) {
        reduceSelectorVariants(ast);
        normalize(ast);
        return ast;
    }
    function reduceSelectorVariants(ast) {
        const newList = [];
        ast.list.forEach(sel => {
            switch (sel.type) {
                case 'class':
                    newList.push({
                        matcher: '~=',
                        modifier: null,
                        name: 'class',
                        namespace: null,
                        specificity: sel.specificity,
                        type: 'attrValue',
                        value: sel.name,
                    });
                    break;
                case 'id':
                    newList.push({
                        matcher: '=',
                        modifier: null,
                        name: 'id',
                        namespace: null,
                        specificity: sel.specificity,
                        type: 'attrValue',
                        value: sel.name,
                    });
                    break;
                case 'combinator':
                    reduceSelectorVariants(sel.left);
                    newList.push(sel);
                    break;
                case 'universal':
                    break;
                default:
                    newList.push(sel);
                    break;
            }
        });
        ast.list = newList;
    }
    function weave(items) {
        const branches = [];
        while (items.length) {
            const topKind = findTopKey(items, (sel) => true, getSelectorKind);
            const { matches, nonmatches, empty } = breakByKind(items, topKind);
            items = nonmatches;
            if (matches.length) {
                branches.push(branchOfKind(topKind, matches));
            }
            if (empty.length) {
                branches.push(...terminate(empty));
            }
        }
        return branches;
    }
    function terminate(items) {
        const results = [];
        for (const item of items) {
            const terminal = item.terminal;
            if (terminal.type === 'terminal') {
                results.push(terminal);
            }
            else {
                const { matches, rest } = partition(terminal.cont, (node) => node.type === 'terminal');
                matches.forEach((node) => results.push(node));
                if (rest.length) {
                    terminal.cont = rest;
                    results.push(terminal);
                }
            }
        }
        return results;
    }
    function breakByKind(items, selectedKind) {
        const matches = [];
        const nonmatches = [];
        const empty = [];
        for (const item of items) {
            const simpsels = item.ast.list;
            if (simpsels.length) {
                const isMatch = simpsels.some(node => getSelectorKind(node) === selectedKind);
                (isMatch ? matches : nonmatches).push(item);
            }
            else {
                empty.push(item);
            }
        }
        return { matches, nonmatches, empty };
    }
    function getSelectorKind(sel) {
        switch (sel.type) {
            case 'attrPresence':
                return `attrPresence ${sel.name}`;
            case 'attrValue':
                return `attrValue ${sel.name}`;
            case 'combinator':
                return `combinator ${sel.combinator}`;
            default:
                return sel.type;
        }
    }
    function branchOfKind(kind, items) {
        if (kind === 'tag') {
            return tagNameBranch(items);
        }
        if (kind.startsWith('attrValue ')) {
            return attrValueBranch(kind.substring(10), items);
        }
        if (kind.startsWith('attrPresence ')) {
            return attrPresenceBranch(kind.substring(13), items);
        }
        if (kind === 'combinator >') {
            return combinatorBranch('>', items);
        }
        if (kind === 'combinator +') {
            return combinatorBranch('+', items);
        }
        throw new Error(`Unsupported selector kind: ${kind}`);
    }
    function tagNameBranch(items) {
        const groups = spliceAndGroup(items, (x) => x.type === 'tag', (x) => x.name);
        const variants = Object.entries(groups).map(([name, group]) => ({
            type: 'variant',
            value: name,
            cont: weave(group.items)
        }));
        return {
            type: 'tagName',
            variants: variants
        };
    }
    function attrPresenceBranch(name, items) {
        for (const item of items) {
            spliceSimpleSelector(item, (x) => (x.type === 'attrPresence') && (x.name === name));
        }
        return {
            type: 'attrPresence',
            name: name,
            cont: weave(items)
        };
    }
    function attrValueBranch(name, items) {
        const groups = spliceAndGroup(items, (x) => (x.type === 'attrValue') && (x.name === name), (x) => `${x.matcher} ${x.modifier || ''} ${x.value}`);
        const matchers = [];
        for (const group of Object.values(groups)) {
            const sel = group.oneSimpleSelector;
            const predicate = getAttrPredicate(sel);
            const continuation = weave(group.items);
            matchers.push({
                type: 'matcher',
                matcher: sel.matcher,
                modifier: sel.modifier,
                value: sel.value,
                predicate: predicate,
                cont: continuation
            });
        }
        return {
            type: 'attrValue',
            name: name,
            matchers: matchers
        };
    }
    function getAttrPredicate(sel) {
        if (sel.modifier === 'i') {
            const expected = sel.value.toLowerCase();
            switch (sel.matcher) {
                case '=':
                    return (actual) => expected === actual.toLowerCase();
                case '~=':
                    return (actual) => actual.toLowerCase().split(/[ \t]+/).includes(expected);
                case '^=':
                    return (actual) => actual.toLowerCase().startsWith(expected);
                case '$=':
                    return (actual) => actual.toLowerCase().endsWith(expected);
                case '*=':
                    return (actual) => actual.toLowerCase().includes(expected);
                case '|=':
                    return (actual) => {
                        const lower = actual.toLowerCase();
                        return (expected === lower) || (lower.startsWith(expected) && lower[expected.length] === '-');
                    };
            }
        }
        else {
            const expected = sel.value;
            switch (sel.matcher) {
                case '=':
                    return (actual) => expected === actual;
                case '~=':
                    return (actual) => actual.split(/[ \t]+/).includes(expected);
                case '^=':
                    return (actual) => actual.startsWith(expected);
                case '$=':
                    return (actual) => actual.endsWith(expected);
                case '*=':
                    return (actual) => actual.includes(expected);
                case '|=':
                    return (actual) => (expected === actual) || (actual.startsWith(expected) && actual[expected.length] === '-');
            }
        }
    }
    function combinatorBranch(combinator, items) {
        const groups = spliceAndGroup(items, (x) => (x.type === 'combinator') && (x.combinator === combinator), (x) => serialize(x.left));
        const leftItems = [];
        for (const group of Object.values(groups)) {
            const rightCont = weave(group.items);
            const leftAst = group.oneSimpleSelector.left;
            leftItems.push({
                ast: leftAst,
                terminal: { type: 'popElement', cont: rightCont }
            });
        }
        return {
            type: 'pushElement',
            combinator: combinator,
            cont: weave(leftItems)
        };
    }
    function spliceAndGroup(items, predicate, keyCallback) {
        const groups = {};
        while (items.length) {
            const bestKey = findTopKey(items, predicate, keyCallback);
            const bestKeyPredicate = (sel) => predicate(sel) && keyCallback(sel) === bestKey;
            const hasBestKeyPredicate = (item) => item.ast.list.some(bestKeyPredicate);
            const { matches, rest } = partition1(items, hasBestKeyPredicate);
            let oneSimpleSelector = null;
            for (const item of matches) {
                const splicedNode = spliceSimpleSelector(item, bestKeyPredicate);
                if (!oneSimpleSelector) {
                    oneSimpleSelector = splicedNode;
                }
            }
            if (oneSimpleSelector == null) {
                throw new Error('No simple selector is found.');
            }
            groups[bestKey] = { oneSimpleSelector: oneSimpleSelector, items: matches };
            items = rest;
        }
        return groups;
    }
    function spliceSimpleSelector(item, predicate) {
        const simpsels = item.ast.list;
        const matches = new Array(simpsels.length);
        let firstIndex = -1;
        for (let i = simpsels.length; i-- > 0;) {
            if (predicate(simpsels[i])) {
                matches[i] = true;
                firstIndex = i;
            }
        }
        if (firstIndex == -1) {
            throw new Error(`Couldn't find the required simple selector.`);
        }
        const result = simpsels[firstIndex];
        item.ast.list = simpsels.filter((sel, i) => !matches[i]);
        return result;
    }
    function findTopKey(items, predicate, keyCallback) {
        const candidates = {};
        for (const item of items) {
            const candidates1 = {};
            for (const node of item.ast.list.filter(predicate)) {
                candidates1[keyCallback(node)] = true;
            }
            for (const key of Object.keys(candidates1)) {
                if (candidates[key]) {
                    candidates[key]++;
                }
                else {
                    candidates[key] = 1;
                }
            }
        }
        let topKind = '';
        let topCounter = 0;
        for (const entry of Object.entries(candidates)) {
            if (entry[1] > topCounter) {
                topKind = entry[0];
                topCounter = entry[1];
            }
        }
        return topKind;
    }
    function partition(src, predicate) {
        const matches = [];
        const rest = [];
        for (const x of src) {
            if (predicate(x)) {
                matches.push(x);
            }
            else {
                rest.push(x);
            }
        }
        return { matches, rest };
    }
    function partition1(src, predicate) {
        const matches = [];
        const rest = [];
        for (const x of src) {
            if (predicate(x)) {
                matches.push(x);
            }
            else {
                rest.push(x);
            }
        }
        return { matches, rest };
    }

    class Picker {
        constructor(f) {
            this.f = f;
        }
        pickAll(el) {
            return this.f(el);
        }
        pick1(el, preferFirst = false) {
            const results = this.f(el);
            const len = results.length;
            if (len === 0) {
                return null;
            }
            if (len === 1) {
                return results[0].value;
            }
            const comparator = (preferFirst)
                ? comparatorPreferFirst
                : comparatorPreferLast;
            let result = results[0];
            for (let i = 1; i < len; i++) {
                const next = results[i];
                if (comparator(result, next)) {
                    result = next;
                }
            }
            return result.value;
        }
    }
    function comparatorPreferFirst(acc, next) {
        const diff = compareSpecificity(next.specificity, acc.specificity);
        return diff > 0 || (diff === 0 && next.index < acc.index);
    }
    function comparatorPreferLast(acc, next) {
        const diff = compareSpecificity(next.specificity, acc.specificity);
        return diff > 0 || (diff === 0 && next.index > acc.index);
    }

    function hp2Builder(nodes) {
        return new Picker(handleArray(nodes));
    }
    function handleArray(nodes) {
        const matchers = nodes.map(handleNode);
        return (el, ...tail) => matchers.flatMap(m => m(el, ...tail));
    }
    function handleNode(node) {
        switch (node.type) {
            case 'terminal': {
                const result = [node.valueContainer];
                return (el, ...tail) => result;
            }
            case 'tagName':
                return handleTagName(node);
            case 'attrValue':
                return handleAttrValueName(node);
            case 'attrPresence':
                return handleAttrPresenceName(node);
            case 'pushElement':
                return handlePushElementNode(node);
            case 'popElement':
                return handlePopElementNode(node);
        }
    }
    function handleTagName(node) {
        const variants = {};
        for (const variant of node.variants) {
            variants[variant.value] = handleArray(variant.cont);
        }
        return (el, ...tail) => {
            const continuation = variants[el.name];
            return (continuation) ? continuation(el, ...tail) : [];
        };
    }
    function handleAttrPresenceName(node) {
        const attrName = node.name;
        const continuation = handleArray(node.cont);
        return (el, ...tail) => (Object.prototype.hasOwnProperty.call(el.attribs, attrName))
            ? continuation(el, ...tail)
            : [];
    }
    function handleAttrValueName(node) {
        const callbacks = [];
        for (const matcher of node.matchers) {
            const predicate = matcher.predicate;
            const continuation = handleArray(matcher.cont);
            callbacks.push((attr, el, ...tail) => (predicate(attr) ? continuation(el, ...tail) : []));
        }
        const attrName = node.name;
        return (el, ...tail) => {
            const attr = el.attribs[attrName];
            return (attr || attr === '')
                ? callbacks.flatMap(cb => cb(attr, el, ...tail))
                : [];
        };
    }
    function handlePushElementNode(node) {
        const continuation = handleArray(node.cont);
        const leftElementGetter = (node.combinator === '+')
            ? getPrecedingElement
            : getParentElement;
        return (el, ...tail) => {
            const next = leftElementGetter(el);
            if (next === null) {
                return [];
            }
            return continuation(next, el, ...tail);
        };
    }
    const getPrecedingElement = (el) => {
        const prev = el.prev;
        if (prev === null) {
            return null;
        }
        return (isTag(prev)) ? prev : getPrecedingElement(prev);
    };
    const getParentElement = (el) => {
        const parent = el.parent;
        return (parent && isTag(parent)) ? parent : null;
    };
    function handlePopElementNode(node) {
        const continuation = handleArray(node.cont);
        return (el, next, ...tail) => continuation(next, ...tail);
    }

    // Generated using scripts/write-decode-map.ts
    var htmlDecodeTree = new Uint16Array(
    // prettier-ignore
    "\u1d41<\xd5\u0131\u028a\u049d\u057b\u05d0\u0675\u06de\u07a2\u07d6\u080f\u0a4a\u0a91\u0da1\u0e6d\u0f09\u0f26\u10ca\u1228\u12e1\u1415\u149d\u14c3\u14df\u1525\0\0\0\0\0\0\u156b\u16cd\u198d\u1c12\u1ddd\u1f7e\u2060\u21b0\u228d\u23c0\u23fb\u2442\u2824\u2912\u2d08\u2e48\u2fce\u3016\u32ba\u3639\u37ac\u38fe\u3a28\u3a71\u3ae0\u3b2e\u0800EMabcfglmnoprstu\\bfms\x7f\x84\x8b\x90\x95\x98\xa6\xb3\xb9\xc8\xcflig\u803b\xc6\u40c6P\u803b&\u4026cute\u803b\xc1\u40c1reve;\u4102\u0100iyx}rc\u803b\xc2\u40c2;\u4410r;\uc000\ud835\udd04rave\u803b\xc0\u40c0pha;\u4391acr;\u4100d;\u6a53\u0100gp\x9d\xa1on;\u4104f;\uc000\ud835\udd38plyFunction;\u6061ing\u803b\xc5\u40c5\u0100cs\xbe\xc3r;\uc000\ud835\udc9cign;\u6254ilde\u803b\xc3\u40c3ml\u803b\xc4\u40c4\u0400aceforsu\xe5\xfb\xfe\u0117\u011c\u0122\u0127\u012a\u0100cr\xea\xf2kslash;\u6216\u0176\xf6\xf8;\u6ae7ed;\u6306y;\u4411\u0180crt\u0105\u010b\u0114ause;\u6235noullis;\u612ca;\u4392r;\uc000\ud835\udd05pf;\uc000\ud835\udd39eve;\u42d8c\xf2\u0113mpeq;\u624e\u0700HOacdefhilorsu\u014d\u0151\u0156\u0180\u019e\u01a2\u01b5\u01b7\u01ba\u01dc\u0215\u0273\u0278\u027ecy;\u4427PY\u803b\xa9\u40a9\u0180cpy\u015d\u0162\u017aute;\u4106\u0100;i\u0167\u0168\u62d2talDifferentialD;\u6145leys;\u612d\u0200aeio\u0189\u018e\u0194\u0198ron;\u410cdil\u803b\xc7\u40c7rc;\u4108nint;\u6230ot;\u410a\u0100dn\u01a7\u01adilla;\u40b8terDot;\u40b7\xf2\u017fi;\u43a7rcle\u0200DMPT\u01c7\u01cb\u01d1\u01d6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01e2\u01f8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020foubleQuote;\u601duote;\u6019\u0200lnpu\u021e\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6a74\u0180git\u022f\u0236\u023aruent;\u6261nt;\u622fourIntegral;\u622e\u0100fr\u024c\u024e;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6a2fcr;\uc000\ud835\udc9ep\u0100;C\u0284\u0285\u62d3ap;\u624d\u0580DJSZacefios\u02a0\u02ac\u02b0\u02b4\u02b8\u02cb\u02d7\u02e1\u02e6\u0333\u048d\u0100;o\u0179\u02a5trahd;\u6911cy;\u4402cy;\u4405cy;\u440f\u0180grs\u02bf\u02c4\u02c7ger;\u6021r;\u61a1hv;\u6ae4\u0100ay\u02d0\u02d5ron;\u410e;\u4414l\u0100;t\u02dd\u02de\u6207a;\u4394r;\uc000\ud835\udd07\u0100af\u02eb\u0327\u0100cm\u02f0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031ccute;\u40b4o\u0174\u030b\u030d;\u42d9bleAcute;\u42ddrave;\u4060ilde;\u42dcond;\u62c4ferentialD;\u6146\u0470\u033d\0\0\0\u0342\u0354\0\u0405f;\uc000\ud835\udd3b\u0180;DE\u0348\u0349\u034d\u40a8ot;\u60dcqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03cf\u03e2\u03f8ontourIntegra\xec\u0239o\u0274\u0379\0\0\u037b\xbb\u0349nArrow;\u61d3\u0100eo\u0387\u03a4ft\u0180ART\u0390\u0396\u03a1rrow;\u61d0ightArrow;\u61d4e\xe5\u02cang\u0100LR\u03ab\u03c4eft\u0100AR\u03b3\u03b9rrow;\u67f8ightArrow;\u67faightArrow;\u67f9ight\u0100AT\u03d8\u03derrow;\u61d2ee;\u62a8p\u0241\u03e9\0\0\u03efrrow;\u61d1ownArrow;\u61d5erticalBar;\u6225n\u0300ABLRTa\u0412\u042a\u0430\u045e\u047f\u037crrow\u0180;BU\u041d\u041e\u0422\u6193ar;\u6913pArrow;\u61f5reve;\u4311eft\u02d2\u043a\0\u0446\0\u0450ightVector;\u6950eeVector;\u695eector\u0100;B\u0459\u045a\u61bdar;\u6956ight\u01d4\u0467\0\u0471eeVector;\u695fector\u0100;B\u047a\u047b\u61c1ar;\u6957ee\u0100;A\u0486\u0487\u62a4rrow;\u61a7\u0100ct\u0492\u0497r;\uc000\ud835\udc9frok;\u4110\u0800NTacdfglmopqstux\u04bd\u04c0\u04c4\u04cb\u04de\u04e2\u04e7\u04ee\u04f5\u0521\u052f\u0536\u0552\u055d\u0560\u0565G;\u414aH\u803b\xd0\u40d0cute\u803b\xc9\u40c9\u0180aiy\u04d2\u04d7\u04dcron;\u411arc\u803b\xca\u40ca;\u442dot;\u4116r;\uc000\ud835\udd08rave\u803b\xc8\u40c8ement;\u6208\u0100ap\u04fa\u04fecr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65fberySmallSquare;\u65ab\u0100gp\u0526\u052aon;\u4118f;\uc000\ud835\udd3csilon;\u4395u\u0100ai\u053c\u0549l\u0100;T\u0542\u0543\u6a75ilde;\u6242librium;\u61cc\u0100ci\u0557\u055ar;\u6130m;\u6a73a;\u4397ml\u803b\xcb\u40cb\u0100ip\u056a\u056fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058d\u05b2\u05ccy;\u4424r;\uc000\ud835\udd09lled\u0253\u0597\0\0\u05a3mallSquare;\u65fcerySmallSquare;\u65aa\u0370\u05ba\0\u05bf\0\0\u05c4f;\uc000\ud835\udd3dAll;\u6200riertrf;\u6131c\xf2\u05cb\u0600JTabcdfgorst\u05e8\u05ec\u05ef\u05fa\u0600\u0612\u0616\u061b\u061d\u0623\u066c\u0672cy;\u4403\u803b>\u403emma\u0100;d\u05f7\u05f8\u4393;\u43dcreve;\u411e\u0180eiy\u0607\u060c\u0610dil;\u4122rc;\u411c;\u4413ot;\u4120r;\uc000\ud835\udd0a;\u62d9pf;\uc000\ud835\udd3eeater\u0300EFGLST\u0635\u0644\u064e\u0656\u065b\u0666qual\u0100;L\u063e\u063f\u6265ess;\u62dbullEqual;\u6267reater;\u6aa2ess;\u6277lantEqual;\u6a7eilde;\u6273cr;\uc000\ud835\udca2;\u626b\u0400Aacfiosu\u0685\u068b\u0696\u069b\u069e\u06aa\u06be\u06caRDcy;\u442a\u0100ct\u0690\u0694ek;\u42c7;\u405eirc;\u4124r;\u610clbertSpace;\u610b\u01f0\u06af\0\u06b2f;\u610dizontalLine;\u6500\u0100ct\u06c3\u06c5\xf2\u06a9rok;\u4126mp\u0144\u06d0\u06d8ownHum\xf0\u012fqual;\u624f\u0700EJOacdfgmnostu\u06fa\u06fe\u0703\u0707\u070e\u071a\u071e\u0721\u0728\u0744\u0778\u078b\u078f\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803b\xcd\u40cd\u0100iy\u0713\u0718rc\u803b\xce\u40ce;\u4418ot;\u4130r;\u6111rave\u803b\xcc\u40cc\u0180;ap\u0720\u072f\u073f\u0100cg\u0734\u0737r;\u412ainaryI;\u6148lie\xf3\u03dd\u01f4\u0749\0\u0762\u0100;e\u074d\u074e\u622c\u0100gr\u0753\u0758ral;\u622bsection;\u62c2isible\u0100CT\u076c\u0772omma;\u6063imes;\u6062\u0180gpt\u077f\u0783\u0788on;\u412ef;\uc000\ud835\udd40a;\u4399cr;\u6110ilde;\u4128\u01eb\u079a\0\u079ecy;\u4406l\u803b\xcf\u40cf\u0280cfosu\u07ac\u07b7\u07bc\u07c2\u07d0\u0100iy\u07b1\u07b5rc;\u4134;\u4419r;\uc000\ud835\udd0dpf;\uc000\ud835\udd41\u01e3\u07c7\0\u07ccr;\uc000\ud835\udca5rcy;\u4408kcy;\u4404\u0380HJacfos\u07e4\u07e8\u07ec\u07f1\u07fd\u0802\u0808cy;\u4425cy;\u440cppa;\u439a\u0100ey\u07f6\u07fbdil;\u4136;\u441ar;\uc000\ud835\udd0epf;\uc000\ud835\udd42cr;\uc000\ud835\udca6\u0580JTaceflmost\u0825\u0829\u082c\u0850\u0863\u09b3\u09b8\u09c7\u09cd\u0a37\u0a47cy;\u4409\u803b<\u403c\u0280cmnpr\u0837\u083c\u0841\u0844\u084dute;\u4139bda;\u439bg;\u67ealacetrf;\u6112r;\u619e\u0180aey\u0857\u085c\u0861ron;\u413ddil;\u413b;\u441b\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087e\u08a9\u08b1\u08e0\u08e6\u08fc\u092f\u095b\u0390\u096a\u0100nr\u0883\u088fgleBracket;\u67e8row\u0180;BR\u0899\u089a\u089e\u6190ar;\u61e4ightArrow;\u61c6eiling;\u6308o\u01f5\u08b7\0\u08c3bleBracket;\u67e6n\u01d4\u08c8\0\u08d2eeVector;\u6961ector\u0100;B\u08db\u08dc\u61c3ar;\u6959loor;\u630aight\u0100AV\u08ef\u08f5rrow;\u6194ector;\u694e\u0100er\u0901\u0917e\u0180;AV\u0909\u090a\u0910\u62a3rrow;\u61a4ector;\u695aiangle\u0180;BE\u0924\u0925\u0929\u62b2ar;\u69cfqual;\u62b4p\u0180DTV\u0937\u0942\u094cownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61bfar;\u6958ector\u0100;B\u0965\u0966\u61bcar;\u6952ight\xe1\u039cs\u0300EFGLST\u097e\u098b\u0995\u099d\u09a2\u09adqualGreater;\u62daullEqual;\u6266reater;\u6276ess;\u6aa1lantEqual;\u6a7dilde;\u6272r;\uc000\ud835\udd0f\u0100;e\u09bd\u09be\u62d8ftarrow;\u61daidot;\u413f\u0180npw\u09d4\u0a16\u0a1bg\u0200LRlr\u09de\u09f7\u0a02\u0a10eft\u0100AR\u09e6\u09ecrrow;\u67f5ightArrow;\u67f7ightArrow;\u67f6eft\u0100ar\u03b3\u0a0aight\xe1\u03bfight\xe1\u03caf;\uc000\ud835\udd43er\u0100LR\u0a22\u0a2ceftArrow;\u6199ightArrow;\u6198\u0180cht\u0a3e\u0a40\u0a42\xf2\u084c;\u61b0rok;\u4141;\u626a\u0400acefiosu\u0a5a\u0a5d\u0a60\u0a77\u0a7c\u0a85\u0a8b\u0a8ep;\u6905y;\u441c\u0100dl\u0a65\u0a6fiumSpace;\u605flintrf;\u6133r;\uc000\ud835\udd10nusPlus;\u6213pf;\uc000\ud835\udd44c\xf2\u0a76;\u439c\u0480Jacefostu\u0aa3\u0aa7\u0aad\u0ac0\u0b14\u0b19\u0d91\u0d97\u0d9ecy;\u440acute;\u4143\u0180aey\u0ab4\u0ab9\u0aberon;\u4147dil;\u4145;\u441d\u0180gsw\u0ac7\u0af0\u0b0eative\u0180MTV\u0ad3\u0adf\u0ae8ediumSpace;\u600bhi\u0100cn\u0ae6\u0ad8\xeb\u0ad9eryThi\xee\u0ad9ted\u0100GL\u0af8\u0b06reaterGreate\xf2\u0673essLes\xf3\u0a48Line;\u400ar;\uc000\ud835\udd11\u0200Bnpt\u0b22\u0b28\u0b37\u0b3areak;\u6060BreakingSpace;\u40a0f;\u6115\u0680;CDEGHLNPRSTV\u0b55\u0b56\u0b6a\u0b7c\u0ba1\u0beb\u0c04\u0c5e\u0c84\u0ca6\u0cd8\u0d61\u0d85\u6aec\u0100ou\u0b5b\u0b64ngruent;\u6262pCap;\u626doubleVerticalBar;\u6226\u0180lqx\u0b83\u0b8a\u0b9bement;\u6209ual\u0100;T\u0b92\u0b93\u6260ilde;\uc000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0bb6\u0bb7\u0bbd\u0bc9\u0bd3\u0bd8\u0be5\u626fqual;\u6271ullEqual;\uc000\u2267\u0338reater;\uc000\u226b\u0338ess;\u6279lantEqual;\uc000\u2a7e\u0338ilde;\u6275ump\u0144\u0bf2\u0bfdownHump;\uc000\u224e\u0338qual;\uc000\u224f\u0338e\u0100fs\u0c0a\u0c27tTriangle\u0180;BE\u0c1a\u0c1b\u0c21\u62eaar;\uc000\u29cf\u0338qual;\u62ecs\u0300;EGLST\u0c35\u0c36\u0c3c\u0c44\u0c4b\u0c58\u626equal;\u6270reater;\u6278ess;\uc000\u226a\u0338lantEqual;\uc000\u2a7d\u0338ilde;\u6274ested\u0100GL\u0c68\u0c79reaterGreater;\uc000\u2aa2\u0338essLess;\uc000\u2aa1\u0338recedes\u0180;ES\u0c92\u0c93\u0c9b\u6280qual;\uc000\u2aaf\u0338lantEqual;\u62e0\u0100ei\u0cab\u0cb9verseElement;\u620cghtTriangle\u0180;BE\u0ccb\u0ccc\u0cd2\u62ebar;\uc000\u29d0\u0338qual;\u62ed\u0100qu\u0cdd\u0d0cuareSu\u0100bp\u0ce8\u0cf9set\u0100;E\u0cf0\u0cf3\uc000\u228f\u0338qual;\u62e2erset\u0100;E\u0d03\u0d06\uc000\u2290\u0338qual;\u62e3\u0180bcp\u0d13\u0d24\u0d4eset\u0100;E\u0d1b\u0d1e\uc000\u2282\u20d2qual;\u6288ceeds\u0200;EST\u0d32\u0d33\u0d3b\u0d46\u6281qual;\uc000\u2ab0\u0338lantEqual;\u62e1ilde;\uc000\u227f\u0338erset\u0100;E\u0d58\u0d5b\uc000\u2283\u20d2qual;\u6289ilde\u0200;EFT\u0d6e\u0d6f\u0d75\u0d7f\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uc000\ud835\udca9ilde\u803b\xd1\u40d1;\u439d\u0700Eacdfgmoprstuv\u0dbd\u0dc2\u0dc9\u0dd5\u0ddb\u0de0\u0de7\u0dfc\u0e02\u0e20\u0e22\u0e32\u0e3f\u0e44lig;\u4152cute\u803b\xd3\u40d3\u0100iy\u0dce\u0dd3rc\u803b\xd4\u40d4;\u441eblac;\u4150r;\uc000\ud835\udd12rave\u803b\xd2\u40d2\u0180aei\u0dee\u0df2\u0df6cr;\u414cga;\u43a9cron;\u439fpf;\uc000\ud835\udd46enCurly\u0100DQ\u0e0e\u0e1aoubleQuote;\u601cuote;\u6018;\u6a54\u0100cl\u0e27\u0e2cr;\uc000\ud835\udcaaash\u803b\xd8\u40d8i\u016c\u0e37\u0e3cde\u803b\xd5\u40d5es;\u6a37ml\u803b\xd6\u40d6er\u0100BP\u0e4b\u0e60\u0100ar\u0e50\u0e53r;\u603eac\u0100ek\u0e5a\u0e5c;\u63deet;\u63b4arenthesis;\u63dc\u0480acfhilors\u0e7f\u0e87\u0e8a\u0e8f\u0e92\u0e94\u0e9d\u0eb0\u0efcrtialD;\u6202y;\u441fr;\uc000\ud835\udd13i;\u43a6;\u43a0usMinus;\u40b1\u0100ip\u0ea2\u0eadncareplan\xe5\u069df;\u6119\u0200;eio\u0eb9\u0eba\u0ee0\u0ee4\u6abbcedes\u0200;EST\u0ec8\u0ec9\u0ecf\u0eda\u627aqual;\u6aaflantEqual;\u627cilde;\u627eme;\u6033\u0100dp\u0ee9\u0eeeuct;\u620fortion\u0100;a\u0225\u0ef9l;\u621d\u0100ci\u0f01\u0f06r;\uc000\ud835\udcab;\u43a8\u0200Ufos\u0f11\u0f16\u0f1b\u0f1fOT\u803b\"\u4022r;\uc000\ud835\udd14pf;\u611acr;\uc000\ud835\udcac\u0600BEacefhiorsu\u0f3e\u0f43\u0f47\u0f60\u0f73\u0fa7\u0faa\u0fad\u1096\u10a9\u10b4\u10bearr;\u6910G\u803b\xae\u40ae\u0180cnr\u0f4e\u0f53\u0f56ute;\u4154g;\u67ebr\u0100;t\u0f5c\u0f5d\u61a0l;\u6916\u0180aey\u0f67\u0f6c\u0f71ron;\u4158dil;\u4156;\u4420\u0100;v\u0f78\u0f79\u611cerse\u0100EU\u0f82\u0f99\u0100lq\u0f87\u0f8eement;\u620builibrium;\u61cbpEquilibrium;\u696fr\xbb\u0f79o;\u43a1ght\u0400ACDFTUVa\u0fc1\u0feb\u0ff3\u1022\u1028\u105b\u1087\u03d8\u0100nr\u0fc6\u0fd2gleBracket;\u67e9row\u0180;BL\u0fdc\u0fdd\u0fe1\u6192ar;\u61e5eftArrow;\u61c4eiling;\u6309o\u01f5\u0ff9\0\u1005bleBracket;\u67e7n\u01d4\u100a\0\u1014eeVector;\u695dector\u0100;B\u101d\u101e\u61c2ar;\u6955loor;\u630b\u0100er\u102d\u1043e\u0180;AV\u1035\u1036\u103c\u62a2rrow;\u61a6ector;\u695biangle\u0180;BE\u1050\u1051\u1055\u62b3ar;\u69d0qual;\u62b5p\u0180DTV\u1063\u106e\u1078ownVector;\u694feeVector;\u695cector\u0100;B\u1082\u1083\u61bear;\u6954ector\u0100;B\u1091\u1092\u61c0ar;\u6953\u0100pu\u109b\u109ef;\u611dndImplies;\u6970ightarrow;\u61db\u0100ch\u10b9\u10bcr;\u611b;\u61b1leDelayed;\u69f4\u0680HOacfhimoqstu\u10e4\u10f1\u10f7\u10fd\u1119\u111e\u1151\u1156\u1161\u1167\u11b5\u11bb\u11bf\u0100Cc\u10e9\u10eeHcy;\u4429y;\u4428FTcy;\u442ccute;\u415a\u0280;aeiy\u1108\u1109\u110e\u1113\u1117\u6abcron;\u4160dil;\u415erc;\u415c;\u4421r;\uc000\ud835\udd16ort\u0200DLRU\u112a\u1134\u113e\u1149ownArrow\xbb\u041eeftArrow\xbb\u089aightArrow\xbb\u0fddpArrow;\u6191gma;\u43a3allCircle;\u6218pf;\uc000\ud835\udd4a\u0272\u116d\0\0\u1170t;\u621aare\u0200;ISU\u117b\u117c\u1189\u11af\u65a1ntersection;\u6293u\u0100bp\u118f\u119eset\u0100;E\u1197\u1198\u628fqual;\u6291erset\u0100;E\u11a8\u11a9\u6290qual;\u6292nion;\u6294cr;\uc000\ud835\udcaear;\u62c6\u0200bcmp\u11c8\u11db\u1209\u120b\u0100;s\u11cd\u11ce\u62d0et\u0100;E\u11cd\u11d5qual;\u6286\u0100ch\u11e0\u1205eeds\u0200;EST\u11ed\u11ee\u11f4\u11ff\u627bqual;\u6ab0lantEqual;\u627dilde;\u627fTh\xe1\u0f8c;\u6211\u0180;es\u1212\u1213\u1223\u62d1rset\u0100;E\u121c\u121d\u6283qual;\u6287et\xbb\u1213\u0580HRSacfhiors\u123e\u1244\u1249\u1255\u125e\u1271\u1276\u129f\u12c2\u12c8\u12d1ORN\u803b\xde\u40deADE;\u6122\u0100Hc\u124e\u1252cy;\u440by;\u4426\u0100bu\u125a\u125c;\u4009;\u43a4\u0180aey\u1265\u126a\u126fron;\u4164dil;\u4162;\u4422r;\uc000\ud835\udd17\u0100ei\u127b\u1289\u01f2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128e\u1298kSpace;\uc000\u205f\u200aSpace;\u6009lde\u0200;EFT\u12ab\u12ac\u12b2\u12bc\u623cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uc000\ud835\udd4bipleDot;\u60db\u0100ct\u12d6\u12dbr;\uc000\ud835\udcafrok;\u4166\u0ae1\u12f7\u130e\u131a\u1326\0\u132c\u1331\0\0\0\0\0\u1338\u133d\u1377\u1385\0\u13ff\u1404\u140a\u1410\u0100cr\u12fb\u1301ute\u803b\xda\u40dar\u0100;o\u1307\u1308\u619fcir;\u6949r\u01e3\u1313\0\u1316y;\u440eve;\u416c\u0100iy\u131e\u1323rc\u803b\xdb\u40db;\u4423blac;\u4170r;\uc000\ud835\udd18rave\u803b\xd9\u40d9acr;\u416a\u0100di\u1341\u1369er\u0100BP\u1348\u135d\u0100ar\u134d\u1350r;\u405fac\u0100ek\u1357\u1359;\u63dfet;\u63b5arenthesis;\u63ddon\u0100;P\u1370\u1371\u62c3lus;\u628e\u0100gp\u137b\u137fon;\u4172f;\uc000\ud835\udd4c\u0400ADETadps\u1395\u13ae\u13b8\u13c4\u03e8\u13d2\u13d7\u13f3rrow\u0180;BD\u1150\u13a0\u13a4ar;\u6912ownArrow;\u61c5ownArrow;\u6195quilibrium;\u696eee\u0100;A\u13cb\u13cc\u62a5rrow;\u61a5own\xe1\u03f3er\u0100LR\u13de\u13e8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13f9\u13fa\u43d2on;\u43a5ing;\u416ecr;\uc000\ud835\udcb0ilde;\u4168ml\u803b\xdc\u40dc\u0480Dbcdefosv\u1427\u142c\u1430\u1433\u143e\u1485\u148a\u1490\u1496ash;\u62abar;\u6aeby;\u4412ash\u0100;l\u143b\u143c\u62a9;\u6ae6\u0100er\u1443\u1445;\u62c1\u0180bty\u144c\u1450\u147aar;\u6016\u0100;i\u144f\u1455cal\u0200BLST\u1461\u1465\u146a\u1474ar;\u6223ine;\u407ceparator;\u6758ilde;\u6240ThinSpace;\u600ar;\uc000\ud835\udd19pf;\uc000\ud835\udd4dcr;\uc000\ud835\udcb1dash;\u62aa\u0280cefos\u14a7\u14ac\u14b1\u14b6\u14bcirc;\u4174dge;\u62c0r;\uc000\ud835\udd1apf;\uc000\ud835\udd4ecr;\uc000\ud835\udcb2\u0200fios\u14cb\u14d0\u14d2\u14d8r;\uc000\ud835\udd1b;\u439epf;\uc000\ud835\udd4fcr;\uc000\ud835\udcb3\u0480AIUacfosu\u14f1\u14f5\u14f9\u14fd\u1504\u150f\u1514\u151a\u1520cy;\u442fcy;\u4407cy;\u442ecute\u803b\xdd\u40dd\u0100iy\u1509\u150drc;\u4176;\u442br;\uc000\ud835\udd1cpf;\uc000\ud835\udd50cr;\uc000\ud835\udcb4ml;\u4178\u0400Hacdefos\u1535\u1539\u153f\u154b\u154f\u155d\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417d;\u4417ot;\u417b\u01f2\u1554\0\u155boWidt\xe8\u0ad9a;\u4396r;\u6128pf;\u6124cr;\uc000\ud835\udcb5\u0be1\u1583\u158a\u1590\0\u15b0\u15b6\u15bf\0\0\0\0\u15c6\u15db\u15eb\u165f\u166d\0\u1695\u169b\u16b2\u16b9\0\u16becute\u803b\xe1\u40e1reve;\u4103\u0300;Ediuy\u159c\u159d\u15a1\u15a3\u15a8\u15ad\u623e;\uc000\u223e\u0333;\u623frc\u803b\xe2\u40e2te\u80bb\xb4\u0306;\u4430lig\u803b\xe6\u40e6\u0100;r\xb2\u15ba;\uc000\ud835\udd1erave\u803b\xe0\u40e0\u0100ep\u15ca\u15d6\u0100fp\u15cf\u15d4sym;\u6135\xe8\u15d3ha;\u43b1\u0100ap\u15dfc\u0100cl\u15e4\u15e7r;\u4101g;\u6a3f\u0264\u15f0\0\0\u160a\u0280;adsv\u15fa\u15fb\u15ff\u1601\u1607\u6227nd;\u6a55;\u6a5clope;\u6a58;\u6a5a\u0380;elmrsz\u1618\u1619\u161b\u161e\u163f\u164f\u1659\u6220;\u69a4e\xbb\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163a\u163c\u163e;\u69a8;\u69a9;\u69aa;\u69ab;\u69ac;\u69ad;\u69ae;\u69aft\u0100;v\u1645\u1646\u621fb\u0100;d\u164c\u164d\u62be;\u699d\u0100pt\u1654\u1657h;\u6222\xbb\xb9arr;\u637c\u0100gp\u1663\u1667on;\u4105f;\uc000\ud835\udd52\u0380;Eaeiop\u12c1\u167b\u167d\u1682\u1684\u1687\u168a;\u6a70cir;\u6a6f;\u624ad;\u624bs;\u4027rox\u0100;e\u12c1\u1692\xf1\u1683ing\u803b\xe5\u40e5\u0180cty\u16a1\u16a6\u16a8r;\uc000\ud835\udcb6;\u402amp\u0100;e\u12c1\u16af\xf1\u0288ilde\u803b\xe3\u40e3ml\u803b\xe4\u40e4\u0100ci\u16c2\u16c8onin\xf4\u0272nt;\u6a11\u0800Nabcdefiklnoprsu\u16ed\u16f1\u1730\u173c\u1743\u1748\u1778\u177d\u17e0\u17e6\u1839\u1850\u170d\u193d\u1948\u1970ot;\u6aed\u0100cr\u16f6\u171ek\u0200ceps\u1700\u1705\u170d\u1713ong;\u624cpsilon;\u43f6rime;\u6035im\u0100;e\u171a\u171b\u623dq;\u62cd\u0176\u1722\u1726ee;\u62bded\u0100;g\u172c\u172d\u6305e\xbb\u172drk\u0100;t\u135c\u1737brk;\u63b6\u0100oy\u1701\u1741;\u4431quo;\u601e\u0280cmprt\u1753\u175b\u1761\u1764\u1768aus\u0100;e\u010a\u0109ptyv;\u69b0s\xe9\u170cno\xf5\u0113\u0180ahw\u176f\u1771\u1773;\u43b2;\u6136een;\u626cr;\uc000\ud835\udd1fg\u0380costuvw\u178d\u179d\u17b3\u17c1\u17d5\u17db\u17de\u0180aiu\u1794\u1796\u179a\xf0\u0760rc;\u65efp\xbb\u1371\u0180dpt\u17a4\u17a8\u17adot;\u6a00lus;\u6a01imes;\u6a02\u0271\u17b9\0\0\u17becup;\u6a06ar;\u6605riangle\u0100du\u17cd\u17d2own;\u65bdp;\u65b3plus;\u6a04e\xe5\u1444\xe5\u14adarow;\u690d\u0180ako\u17ed\u1826\u1835\u0100cn\u17f2\u1823k\u0180lst\u17fa\u05ab\u1802ozenge;\u69ebriangle\u0200;dlr\u1812\u1813\u1818\u181d\u65b4own;\u65beeft;\u65c2ight;\u65b8k;\u6423\u01b1\u182b\0\u1833\u01b2\u182f\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183e\u184d\u0100;q\u1843\u1846\uc000=\u20e5uiv;\uc000\u2261\u20e5t;\u6310\u0200ptwx\u1859\u185e\u1867\u186cf;\uc000\ud835\udd53\u0100;t\u13cb\u1863om\xbb\u13cctie;\u62c8\u0600DHUVbdhmptuv\u1885\u1896\u18aa\u18bb\u18d7\u18db\u18ec\u18ff\u1905\u190a\u1910\u1921\u0200LRlr\u188e\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18a1\u18a2\u18a4\u18a6\u18a8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18b3\u18b5\u18b7\u18b9;\u655d;\u655a;\u655c;\u6559\u0380;HLRhlr\u18ca\u18cb\u18cd\u18cf\u18d1\u18d3\u18d5\u6551;\u656c;\u6563;\u6560;\u656b;\u6562;\u655fox;\u69c9\u0200LRlr\u18e4\u18e6\u18e8\u18ea;\u6555;\u6552;\u6510;\u650c\u0280;DUdu\u06bd\u18f7\u18f9\u18fb\u18fd;\u6565;\u6568;\u652c;\u6534inus;\u629flus;\u629eimes;\u62a0\u0200LRlr\u1919\u191b\u191d\u191f;\u655b;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193b\u6502;\u656a;\u6561;\u655e;\u653c;\u6524;\u651c\u0100ev\u0123\u1942bar\u803b\xa6\u40a6\u0200ceio\u1951\u1956\u195a\u1960r;\uc000\ud835\udcb7mi;\u604fm\u0100;e\u171a\u171cl\u0180;bh\u1968\u1969\u196b\u405c;\u69c5sub;\u67c8\u016c\u1974\u197el\u0100;e\u1979\u197a\u6022t\xbb\u197ap\u0180;Ee\u012f\u1985\u1987;\u6aae\u0100;q\u06dc\u06db\u0ce1\u19a7\0\u19e8\u1a11\u1a15\u1a32\0\u1a37\u1a50\0\0\u1ab4\0\0\u1ac1\0\0\u1b21\u1b2e\u1b4d\u1b52\0\u1bfd\0\u1c0c\u0180cpr\u19ad\u19b2\u19ddute;\u4107\u0300;abcds\u19bf\u19c0\u19c4\u19ca\u19d5\u19d9\u6229nd;\u6a44rcup;\u6a49\u0100au\u19cf\u19d2p;\u6a4bp;\u6a47ot;\u6a40;\uc000\u2229\ufe00\u0100eo\u19e2\u19e5t;\u6041\xee\u0693\u0200aeiu\u19f0\u19fb\u1a01\u1a05\u01f0\u19f5\0\u19f8s;\u6a4don;\u410ddil\u803b\xe7\u40e7rc;\u4109ps\u0100;s\u1a0c\u1a0d\u6a4cm;\u6a50ot;\u410b\u0180dmn\u1a1b\u1a20\u1a26il\u80bb\xb8\u01adptyv;\u69b2t\u8100\xa2;e\u1a2d\u1a2e\u40a2r\xe4\u01b2r;\uc000\ud835\udd20\u0180cei\u1a3d\u1a40\u1a4dy;\u4447ck\u0100;m\u1a47\u1a48\u6713ark\xbb\u1a48;\u43c7r\u0380;Ecefms\u1a5f\u1a60\u1a62\u1a6b\u1aa4\u1aaa\u1aae\u65cb;\u69c3\u0180;el\u1a69\u1a6a\u1a6d\u42c6q;\u6257e\u0261\u1a74\0\0\u1a88rrow\u0100lr\u1a7c\u1a81eft;\u61baight;\u61bb\u0280RSacd\u1a92\u1a94\u1a96\u1a9a\u1a9f\xbb\u0f47;\u64c8st;\u629birc;\u629aash;\u629dnint;\u6a10id;\u6aefcir;\u69c2ubs\u0100;u\u1abb\u1abc\u6663it\xbb\u1abc\u02ec\u1ac7\u1ad4\u1afa\0\u1b0aon\u0100;e\u1acd\u1ace\u403a\u0100;q\xc7\xc6\u026d\u1ad9\0\0\u1ae2a\u0100;t\u1ade\u1adf\u402c;\u4040\u0180;fl\u1ae8\u1ae9\u1aeb\u6201\xee\u1160e\u0100mx\u1af1\u1af6ent\xbb\u1ae9e\xf3\u024d\u01e7\u1afe\0\u1b07\u0100;d\u12bb\u1b02ot;\u6a6dn\xf4\u0246\u0180fry\u1b10\u1b14\u1b17;\uc000\ud835\udd54o\xe4\u0254\u8100\xa9;s\u0155\u1b1dr;\u6117\u0100ao\u1b25\u1b29rr;\u61b5ss;\u6717\u0100cu\u1b32\u1b37r;\uc000\ud835\udcb8\u0100bp\u1b3c\u1b44\u0100;e\u1b41\u1b42\u6acf;\u6ad1\u0100;e\u1b49\u1b4a\u6ad0;\u6ad2dot;\u62ef\u0380delprvw\u1b60\u1b6c\u1b77\u1b82\u1bac\u1bd4\u1bf9arr\u0100lr\u1b68\u1b6a;\u6938;\u6935\u0270\u1b72\0\0\u1b75r;\u62dec;\u62dfarr\u0100;p\u1b7f\u1b80\u61b6;\u693d\u0300;bcdos\u1b8f\u1b90\u1b96\u1ba1\u1ba5\u1ba8\u622arcap;\u6a48\u0100au\u1b9b\u1b9ep;\u6a46p;\u6a4aot;\u628dr;\u6a45;\uc000\u222a\ufe00\u0200alrv\u1bb5\u1bbf\u1bde\u1be3rr\u0100;m\u1bbc\u1bbd\u61b7;\u693cy\u0180evw\u1bc7\u1bd4\u1bd8q\u0270\u1bce\0\0\u1bd2re\xe3\u1b73u\xe3\u1b75ee;\u62ceedge;\u62cfen\u803b\xa4\u40a4earrow\u0100lr\u1bee\u1bf3eft\xbb\u1b80ight\xbb\u1bbde\xe4\u1bdd\u0100ci\u1c01\u1c07onin\xf4\u01f7nt;\u6231lcty;\u632d\u0980AHabcdefhijlorstuwz\u1c38\u1c3b\u1c3f\u1c5d\u1c69\u1c75\u1c8a\u1c9e\u1cac\u1cb7\u1cfb\u1cff\u1d0d\u1d7b\u1d91\u1dab\u1dbb\u1dc6\u1dcdr\xf2\u0381ar;\u6965\u0200glrs\u1c48\u1c4d\u1c52\u1c54ger;\u6020eth;\u6138\xf2\u1133h\u0100;v\u1c5a\u1c5b\u6010\xbb\u090a\u016b\u1c61\u1c67arow;\u690fa\xe3\u0315\u0100ay\u1c6e\u1c73ron;\u410f;\u4434\u0180;ao\u0332\u1c7c\u1c84\u0100gr\u02bf\u1c81r;\u61catseq;\u6a77\u0180glm\u1c91\u1c94\u1c98\u803b\xb0\u40b0ta;\u43b4ptyv;\u69b1\u0100ir\u1ca3\u1ca8sht;\u697f;\uc000\ud835\udd21ar\u0100lr\u1cb3\u1cb5\xbb\u08dc\xbb\u101e\u0280aegsv\u1cc2\u0378\u1cd6\u1cdc\u1ce0m\u0180;os\u0326\u1cca\u1cd4nd\u0100;s\u0326\u1cd1uit;\u6666amma;\u43ddin;\u62f2\u0180;io\u1ce7\u1ce8\u1cf8\u40f7de\u8100\xf7;o\u1ce7\u1cf0ntimes;\u62c7n\xf8\u1cf7cy;\u4452c\u026f\u1d06\0\0\u1d0arn;\u631eop;\u630d\u0280lptuw\u1d18\u1d1d\u1d22\u1d49\u1d55lar;\u4024f;\uc000\ud835\udd55\u0280;emps\u030b\u1d2d\u1d37\u1d3d\u1d42q\u0100;d\u0352\u1d33ot;\u6251inus;\u6238lus;\u6214quare;\u62a1blebarwedg\xe5\xfan\u0180adh\u112e\u1d5d\u1d67ownarrow\xf3\u1c83arpoon\u0100lr\u1d72\u1d76ef\xf4\u1cb4igh\xf4\u1cb6\u0162\u1d7f\u1d85karo\xf7\u0f42\u026f\u1d8a\0\0\u1d8ern;\u631fop;\u630c\u0180cot\u1d98\u1da3\u1da6\u0100ry\u1d9d\u1da1;\uc000\ud835\udcb9;\u4455l;\u69f6rok;\u4111\u0100dr\u1db0\u1db4ot;\u62f1i\u0100;f\u1dba\u1816\u65bf\u0100ah\u1dc0\u1dc3r\xf2\u0429a\xf2\u0fa6angle;\u69a6\u0100ci\u1dd2\u1dd5y;\u445fgrarr;\u67ff\u0900Dacdefglmnopqrstux\u1e01\u1e09\u1e19\u1e38\u0578\u1e3c\u1e49\u1e61\u1e7e\u1ea5\u1eaf\u1ebd\u1ee1\u1f2a\u1f37\u1f44\u1f4e\u1f5a\u0100Do\u1e06\u1d34o\xf4\u1c89\u0100cs\u1e0e\u1e14ute\u803b\xe9\u40e9ter;\u6a6e\u0200aioy\u1e22\u1e27\u1e31\u1e36ron;\u411br\u0100;c\u1e2d\u1e2e\u6256\u803b\xea\u40ealon;\u6255;\u444dot;\u4117\u0100Dr\u1e41\u1e45ot;\u6252;\uc000\ud835\udd22\u0180;rs\u1e50\u1e51\u1e57\u6a9aave\u803b\xe8\u40e8\u0100;d\u1e5c\u1e5d\u6a96ot;\u6a98\u0200;ils\u1e6a\u1e6b\u1e72\u1e74\u6a99nters;\u63e7;\u6113\u0100;d\u1e79\u1e7a\u6a95ot;\u6a97\u0180aps\u1e85\u1e89\u1e97cr;\u4113ty\u0180;sv\u1e92\u1e93\u1e95\u6205et\xbb\u1e93p\u01001;\u1e9d\u1ea4\u0133\u1ea1\u1ea3;\u6004;\u6005\u6003\u0100gs\u1eaa\u1eac;\u414bp;\u6002\u0100gp\u1eb4\u1eb8on;\u4119f;\uc000\ud835\udd56\u0180als\u1ec4\u1ece\u1ed2r\u0100;s\u1eca\u1ecb\u62d5l;\u69e3us;\u6a71i\u0180;lv\u1eda\u1edb\u1edf\u43b5on\xbb\u1edb;\u43f5\u0200csuv\u1eea\u1ef3\u1f0b\u1f23\u0100io\u1eef\u1e31rc\xbb\u1e2e\u0269\u1ef9\0\0\u1efb\xed\u0548ant\u0100gl\u1f02\u1f06tr\xbb\u1e5dess\xbb\u1e7a\u0180aei\u1f12\u1f16\u1f1als;\u403dst;\u625fv\u0100;D\u0235\u1f20D;\u6a78parsl;\u69e5\u0100Da\u1f2f\u1f33ot;\u6253rr;\u6971\u0180cdi\u1f3e\u1f41\u1ef8r;\u612fo\xf4\u0352\u0100ah\u1f49\u1f4b;\u43b7\u803b\xf0\u40f0\u0100mr\u1f53\u1f57l\u803b\xeb\u40ebo;\u60ac\u0180cip\u1f61\u1f64\u1f67l;\u4021s\xf4\u056e\u0100eo\u1f6c\u1f74ctatio\xee\u0559nential\xe5\u0579\u09e1\u1f92\0\u1f9e\0\u1fa1\u1fa7\0\0\u1fc6\u1fcc\0\u1fd3\0\u1fe6\u1fea\u2000\0\u2008\u205allingdotse\xf1\u1e44y;\u4444male;\u6640\u0180ilr\u1fad\u1fb3\u1fc1lig;\u8000\ufb03\u0269\u1fb9\0\0\u1fbdg;\u8000\ufb00ig;\u8000\ufb04;\uc000\ud835\udd23lig;\u8000\ufb01lig;\uc000fj\u0180alt\u1fd9\u1fdc\u1fe1t;\u666dig;\u8000\ufb02ns;\u65b1of;\u4192\u01f0\u1fee\0\u1ff3f;\uc000\ud835\udd57\u0100ak\u05bf\u1ff7\u0100;v\u1ffc\u1ffd\u62d4;\u6ad9artint;\u6a0d\u0100ao\u200c\u2055\u0100cs\u2011\u2052\u03b1\u201a\u2030\u2038\u2045\u2048\0\u2050\u03b2\u2022\u2025\u2027\u202a\u202c\0\u202e\u803b\xbd\u40bd;\u6153\u803b\xbc\u40bc;\u6155;\u6159;\u615b\u01b3\u2034\0\u2036;\u6154;\u6156\u02b4\u203e\u2041\0\0\u2043\u803b\xbe\u40be;\u6157;\u615c5;\u6158\u01b6\u204c\0\u204e;\u615a;\u615d8;\u615el;\u6044wn;\u6322cr;\uc000\ud835\udcbb\u0880Eabcdefgijlnorstv\u2082\u2089\u209f\u20a5\u20b0\u20b4\u20f0\u20f5\u20fa\u20ff\u2103\u2112\u2138\u0317\u213e\u2152\u219e\u0100;l\u064d\u2087;\u6a8c\u0180cmp\u2090\u2095\u209dute;\u41f5ma\u0100;d\u209c\u1cda\u43b3;\u6a86reve;\u411f\u0100iy\u20aa\u20aerc;\u411d;\u4433ot;\u4121\u0200;lqs\u063e\u0642\u20bd\u20c9\u0180;qs\u063e\u064c\u20c4lan\xf4\u0665\u0200;cdl\u0665\u20d2\u20d5\u20e5c;\u6aa9ot\u0100;o\u20dc\u20dd\u6a80\u0100;l\u20e2\u20e3\u6a82;\u6a84\u0100;e\u20ea\u20ed\uc000\u22db\ufe00s;\u6a94r;\uc000\ud835\udd24\u0100;g\u0673\u061bmel;\u6137cy;\u4453\u0200;Eaj\u065a\u210c\u210e\u2110;\u6a92;\u6aa5;\u6aa4\u0200Eaes\u211b\u211d\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6a8arox\xbb\u2124\u0100;q\u212e\u212f\u6a88\u0100;q\u212e\u211bim;\u62e7pf;\uc000\ud835\udd58\u0100ci\u2143\u2146r;\u610am\u0180;el\u066b\u214e\u2150;\u6a8e;\u6a90\u8300>;cdlqr\u05ee\u2160\u216a\u216e\u2173\u2179\u0100ci\u2165\u2167;\u6aa7r;\u6a7aot;\u62d7Par;\u6995uest;\u6a7c\u0280adels\u2184\u216a\u2190\u0656\u219b\u01f0\u2189\0\u218epro\xf8\u209er;\u6978q\u0100lq\u063f\u2196les\xf3\u2088i\xed\u066b\u0100en\u21a3\u21adrtneqq;\uc000\u2269\ufe00\xc5\u21aa\u0500Aabcefkosy\u21c4\u21c7\u21f1\u21f5\u21fa\u2218\u221d\u222f\u2268\u227dr\xf2\u03a0\u0200ilmr\u21d0\u21d4\u21d7\u21dbrs\xf0\u1484f\xbb\u2024il\xf4\u06a9\u0100dr\u21e0\u21e4cy;\u444a\u0180;cw\u08f4\u21eb\u21efir;\u6948;\u61adar;\u610firc;\u4125\u0180alr\u2201\u220e\u2213rts\u0100;u\u2209\u220a\u6665it\xbb\u220alip;\u6026con;\u62b9r;\uc000\ud835\udd25s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223a\u223e\u2243\u225e\u2263rr;\u61fftht;\u623bk\u0100lr\u2249\u2253eftarrow;\u61a9ightarrow;\u61aaf;\uc000\ud835\udd59bar;\u6015\u0180clt\u226f\u2274\u2278r;\uc000\ud835\udcbdas\xe8\u21f4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xbb\u1c5b\u0ae1\u22a3\0\u22aa\0\u22b8\u22c5\u22ce\0\u22d5\u22f3\0\0\u22f8\u2322\u2367\u2362\u237f\0\u2386\u23aa\u23b4cute\u803b\xed\u40ed\u0180;iy\u0771\u22b0\u22b5rc\u803b\xee\u40ee;\u4438\u0100cx\u22bc\u22bfy;\u4435cl\u803b\xa1\u40a1\u0100fr\u039f\u22c9;\uc000\ud835\udd26rave\u803b\xec\u40ec\u0200;ino\u073e\u22dd\u22e9\u22ee\u0100in\u22e2\u22e6nt;\u6a0ct;\u622dfin;\u69dcta;\u6129lig;\u4133\u0180aop\u22fe\u231a\u231d\u0180cgt\u2305\u2308\u2317r;\u412b\u0180elp\u071f\u230f\u2313in\xe5\u078ear\xf4\u0720h;\u4131f;\u62b7ed;\u41b5\u0280;cfot\u04f4\u232c\u2331\u233d\u2341are;\u6105in\u0100;t\u2338\u2339\u621eie;\u69dddo\xf4\u2319\u0280;celp\u0757\u234c\u2350\u235b\u2361al;\u62ba\u0100gr\u2355\u2359er\xf3\u1563\xe3\u234darhk;\u6a17rod;\u6a3c\u0200cgpt\u236f\u2372\u2376\u237by;\u4451on;\u412ff;\uc000\ud835\udd5aa;\u43b9uest\u803b\xbf\u40bf\u0100ci\u238a\u238fr;\uc000\ud835\udcben\u0280;Edsv\u04f4\u239b\u239d\u23a1\u04f3;\u62f9ot;\u62f5\u0100;v\u23a6\u23a7\u62f4;\u62f3\u0100;i\u0777\u23aelde;\u4129\u01eb\u23b8\0\u23bccy;\u4456l\u803b\xef\u40ef\u0300cfmosu\u23cc\u23d7\u23dc\u23e1\u23e7\u23f5\u0100iy\u23d1\u23d5rc;\u4135;\u4439r;\uc000\ud835\udd27ath;\u4237pf;\uc000\ud835\udd5b\u01e3\u23ec\0\u23f1r;\uc000\ud835\udcbfrcy;\u4458kcy;\u4454\u0400acfghjos\u240b\u2416\u2422\u2427\u242d\u2431\u2435\u243bppa\u0100;v\u2413\u2414\u43ba;\u43f0\u0100ey\u241b\u2420dil;\u4137;\u443ar;\uc000\ud835\udd28reen;\u4138cy;\u4445cy;\u445cpf;\uc000\ud835\udd5ccr;\uc000\ud835\udcc0\u0b80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248d\u2491\u250e\u253d\u255a\u2580\u264e\u265e\u2665\u2679\u267d\u269a\u26b2\u26d8\u275d\u2768\u278b\u27c0\u2801\u2812\u0180art\u2477\u247a\u247cr\xf2\u09c6\xf2\u0395ail;\u691barr;\u690e\u0100;g\u0994\u248b;\u6a8bar;\u6962\u0963\u24a5\0\u24aa\0\u24b1\0\0\0\0\0\u24b5\u24ba\0\u24c6\u24c8\u24cd\0\u24f9ute;\u413amptyv;\u69b4ra\xee\u084cbda;\u43bbg\u0180;dl\u088e\u24c1\u24c3;\u6991\xe5\u088e;\u6a85uo\u803b\xab\u40abr\u0400;bfhlpst\u0899\u24de\u24e6\u24e9\u24eb\u24ee\u24f1\u24f5\u0100;f\u089d\u24e3s;\u691fs;\u691d\xeb\u2252p;\u61abl;\u6939im;\u6973l;\u61a2\u0180;ae\u24ff\u2500\u2504\u6aabil;\u6919\u0100;s\u2509\u250a\u6aad;\uc000\u2aad\ufe00\u0180abr\u2515\u2519\u251drr;\u690crk;\u6772\u0100ak\u2522\u252cc\u0100ek\u2528\u252a;\u407b;\u405b\u0100es\u2531\u2533;\u698bl\u0100du\u2539\u253b;\u698f;\u698d\u0200aeuy\u2546\u254b\u2556\u2558ron;\u413e\u0100di\u2550\u2554il;\u413c\xec\u08b0\xe2\u2529;\u443b\u0200cqrs\u2563\u2566\u256d\u257da;\u6936uo\u0100;r\u0e19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694bh;\u61b2\u0280;fgqs\u258b\u258c\u0989\u25f3\u25ff\u6264t\u0280ahlrt\u2598\u25a4\u25b7\u25c2\u25e8rrow\u0100;t\u0899\u25a1a\xe9\u24f6arpoon\u0100du\u25af\u25b4own\xbb\u045ap\xbb\u0966eftarrows;\u61c7ight\u0180ahs\u25cd\u25d6\u25derrow\u0100;s\u08f4\u08a7arpoon\xf3\u0f98quigarro\xf7\u21f0hreetimes;\u62cb\u0180;qs\u258b\u0993\u25falan\xf4\u09ac\u0280;cdgs\u09ac\u260a\u260d\u261d\u2628c;\u6aa8ot\u0100;o\u2614\u2615\u6a7f\u0100;r\u261a\u261b\u6a81;\u6a83\u0100;e\u2622\u2625\uc000\u22da\ufe00s;\u6a93\u0280adegs\u2633\u2639\u263d\u2649\u264bppro\xf8\u24c6ot;\u62d6q\u0100gq\u2643\u2645\xf4\u0989gt\xf2\u248c\xf4\u099bi\xed\u09b2\u0180ilr\u2655\u08e1\u265asht;\u697c;\uc000\ud835\udd29\u0100;E\u099c\u2663;\u6a91\u0161\u2669\u2676r\u0100du\u25b2\u266e\u0100;l\u0965\u2673;\u696alk;\u6584cy;\u4459\u0280;acht\u0a48\u2688\u268b\u2691\u2696r\xf2\u25c1orne\xf2\u1d08ard;\u696bri;\u65fa\u0100io\u269f\u26a4dot;\u4140ust\u0100;a\u26ac\u26ad\u63b0che\xbb\u26ad\u0200Eaes\u26bb\u26bd\u26c9\u26d4;\u6268p\u0100;p\u26c3\u26c4\u6a89rox\xbb\u26c4\u0100;q\u26ce\u26cf\u6a87\u0100;q\u26ce\u26bbim;\u62e6\u0400abnoptwz\u26e9\u26f4\u26f7\u271a\u272f\u2741\u2747\u2750\u0100nr\u26ee\u26f1g;\u67ecr;\u61fdr\xeb\u08c1g\u0180lmr\u26ff\u270d\u2714eft\u0100ar\u09e6\u2707ight\xe1\u09f2apsto;\u67fcight\xe1\u09fdparrow\u0100lr\u2725\u2729ef\xf4\u24edight;\u61ac\u0180afl\u2736\u2739\u273dr;\u6985;\uc000\ud835\udd5dus;\u6a2dimes;\u6a34\u0161\u274b\u274fst;\u6217\xe1\u134e\u0180;ef\u2757\u2758\u1800\u65cange\xbb\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277c\u2785\u2787r\xf2\u08a8orne\xf2\u1d8car\u0100;d\u0f98\u2783;\u696d;\u600eri;\u62bf\u0300achiqt\u2798\u279d\u0a40\u27a2\u27ae\u27bbquo;\u6039r;\uc000\ud835\udcc1m\u0180;eg\u09b2\u27aa\u27ac;\u6a8d;\u6a8f\u0100bu\u252a\u27b3o\u0100;r\u0e1f\u27b9;\u601arok;\u4142\u8400<;cdhilqr\u082b\u27d2\u2639\u27dc\u27e0\u27e5\u27ea\u27f0\u0100ci\u27d7\u27d9;\u6aa6r;\u6a79re\xe5\u25f2mes;\u62c9arr;\u6976uest;\u6a7b\u0100Pi\u27f5\u27f9ar;\u6996\u0180;ef\u2800\u092d\u181b\u65c3r\u0100du\u2807\u280dshar;\u694ahar;\u6966\u0100en\u2817\u2821rtneqq;\uc000\u2268\ufe00\xc5\u281e\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288e\u2893\u28a0\u28a5\u28a8\u28da\u28e2\u28e4\u0a83\u28f3\u2902Dot;\u623a\u0200clpr\u284e\u2852\u2863\u287dr\u803b\xaf\u40af\u0100et\u2857\u2859;\u6642\u0100;e\u285e\u285f\u6720se\xbb\u285f\u0100;s\u103b\u2868to\u0200;dlu\u103b\u2873\u2877\u287bow\xee\u048cef\xf4\u090f\xf0\u13d1ker;\u65ae\u0100oy\u2887\u288cmma;\u6a29;\u443cash;\u6014asuredangle\xbb\u1626r;\uc000\ud835\udd2ao;\u6127\u0180cdn\u28af\u28b4\u28c9ro\u803b\xb5\u40b5\u0200;acd\u1464\u28bd\u28c0\u28c4s\xf4\u16a7ir;\u6af0ot\u80bb\xb7\u01b5us\u0180;bd\u28d2\u1903\u28d3\u6212\u0100;u\u1d3c\u28d8;\u6a2a\u0163\u28de\u28e1p;\u6adb\xf2\u2212\xf0\u0a81\u0100dp\u28e9\u28eeels;\u62a7f;\uc000\ud835\udd5e\u0100ct\u28f8\u28fdr;\uc000\ud835\udcc2pos\xbb\u159d\u0180;lm\u2909\u290a\u290d\u43bctimap;\u62b8\u0c00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297e\u2989\u2998\u29da\u29e9\u2a15\u2a1a\u2a58\u2a5d\u2a83\u2a95\u2aa4\u2aa8\u2b04\u2b07\u2b44\u2b7f\u2bae\u2c34\u2c67\u2c7c\u2ce9\u0100gt\u2947\u294b;\uc000\u22d9\u0338\u0100;v\u2950\u0bcf\uc000\u226b\u20d2\u0180elt\u295a\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61cdightarrow;\u61ce;\uc000\u22d8\u0338\u0100;v\u297b\u0c47\uc000\u226a\u20d2ightarrow;\u61cf\u0100Dd\u298e\u2993ash;\u62afash;\u62ae\u0280bcnpt\u29a3\u29a7\u29ac\u29b1\u29ccla\xbb\u02deute;\u4144g;\uc000\u2220\u20d2\u0280;Eiop\u0d84\u29bc\u29c0\u29c5\u29c8;\uc000\u2a70\u0338d;\uc000\u224b\u0338s;\u4149ro\xf8\u0d84ur\u0100;a\u29d3\u29d4\u666el\u0100;s\u29d3\u0b38\u01f3\u29df\0\u29e3p\u80bb\xa0\u0b37mp\u0100;e\u0bf9\u0c00\u0280aeouy\u29f4\u29fe\u2a03\u2a10\u2a13\u01f0\u29f9\0\u29fb;\u6a43on;\u4148dil;\u4146ng\u0100;d\u0d7e\u2a0aot;\uc000\u2a6d\u0338p;\u6a42;\u443dash;\u6013\u0380;Aadqsx\u0b92\u2a29\u2a2d\u2a3b\u2a41\u2a45\u2a50rr;\u61d7r\u0100hr\u2a33\u2a36k;\u6924\u0100;o\u13f2\u13f0ot;\uc000\u2250\u0338ui\xf6\u0b63\u0100ei\u2a4a\u2a4ear;\u6928\xed\u0b98ist\u0100;s\u0ba0\u0b9fr;\uc000\ud835\udd2b\u0200Eest\u0bc5\u2a66\u2a79\u2a7c\u0180;qs\u0bbc\u2a6d\u0be1\u0180;qs\u0bbc\u0bc5\u2a74lan\xf4\u0be2i\xed\u0bea\u0100;r\u0bb6\u2a81\xbb\u0bb7\u0180Aap\u2a8a\u2a8d\u2a91r\xf2\u2971rr;\u61aear;\u6af2\u0180;sv\u0f8d\u2a9c\u0f8c\u0100;d\u2aa1\u2aa2\u62fc;\u62facy;\u445a\u0380AEadest\u2ab7\u2aba\u2abe\u2ac2\u2ac5\u2af6\u2af9r\xf2\u2966;\uc000\u2266\u0338rr;\u619ar;\u6025\u0200;fqs\u0c3b\u2ace\u2ae3\u2aeft\u0100ar\u2ad4\u2ad9rro\xf7\u2ac1ightarro\xf7\u2a90\u0180;qs\u0c3b\u2aba\u2aealan\xf4\u0c55\u0100;s\u0c55\u2af4\xbb\u0c36i\xed\u0c5d\u0100;r\u0c35\u2afei\u0100;e\u0c1a\u0c25i\xe4\u0d90\u0100pt\u2b0c\u2b11f;\uc000\ud835\udd5f\u8180\xac;in\u2b19\u2b1a\u2b36\u40acn\u0200;Edv\u0b89\u2b24\u2b28\u2b2e;\uc000\u22f9\u0338ot;\uc000\u22f5\u0338\u01e1\u0b89\u2b33\u2b35;\u62f7;\u62f6i\u0100;v\u0cb8\u2b3c\u01e1\u0cb8\u2b41\u2b43;\u62fe;\u62fd\u0180aor\u2b4b\u2b63\u2b69r\u0200;ast\u0b7b\u2b55\u2b5a\u2b5flle\xec\u0b7bl;\uc000\u2afd\u20e5;\uc000\u2202\u0338lint;\u6a14\u0180;ce\u0c92\u2b70\u2b73u\xe5\u0ca5\u0100;c\u0c98\u2b78\u0100;e\u0c92\u2b7d\xf1\u0c98\u0200Aait\u2b88\u2b8b\u2b9d\u2ba7r\xf2\u2988rr\u0180;cw\u2b94\u2b95\u2b99\u619b;\uc000\u2933\u0338;\uc000\u219d\u0338ghtarrow\xbb\u2b95ri\u0100;e\u0ccb\u0cd6\u0380chimpqu\u2bbd\u2bcd\u2bd9\u2b04\u0b78\u2be4\u2bef\u0200;cer\u0d32\u2bc6\u0d37\u2bc9u\xe5\u0d45;\uc000\ud835\udcc3ort\u026d\u2b05\0\0\u2bd6ar\xe1\u2b56m\u0100;e\u0d6e\u2bdf\u0100;q\u0d74\u0d73su\u0100bp\u2beb\u2bed\xe5\u0cf8\xe5\u0d0b\u0180bcp\u2bf6\u2c11\u2c19\u0200;Ees\u2bff\u2c00\u0d22\u2c04\u6284;\uc000\u2ac5\u0338et\u0100;e\u0d1b\u2c0bq\u0100;q\u0d23\u2c00c\u0100;e\u0d32\u2c17\xf1\u0d38\u0200;Ees\u2c22\u2c23\u0d5f\u2c27\u6285;\uc000\u2ac6\u0338et\u0100;e\u0d58\u2c2eq\u0100;q\u0d60\u2c23\u0200gilr\u2c3d\u2c3f\u2c45\u2c47\xec\u0bd7lde\u803b\xf1\u40f1\xe7\u0c43iangle\u0100lr\u2c52\u2c5ceft\u0100;e\u0c1a\u2c5a\xf1\u0c26ight\u0100;e\u0ccb\u2c65\xf1\u0cd7\u0100;m\u2c6c\u2c6d\u43bd\u0180;es\u2c74\u2c75\u2c79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2c8f\u2c94\u2c99\u2c9e\u2ca3\u2cb0\u2cb6\u2cd3\u2ce3ash;\u62adarr;\u6904p;\uc000\u224d\u20d2ash;\u62ac\u0100et\u2ca8\u2cac;\uc000\u2265\u20d2;\uc000>\u20d2nfin;\u69de\u0180Aet\u2cbd\u2cc1\u2cc5rr;\u6902;\uc000\u2264\u20d2\u0100;r\u2cca\u2ccd\uc000<\u20d2ie;\uc000\u22b4\u20d2\u0100At\u2cd8\u2cdcrr;\u6903rie;\uc000\u22b5\u20d2im;\uc000\u223c\u20d2\u0180Aan\u2cf0\u2cf4\u2d02rr;\u61d6r\u0100hr\u2cfa\u2cfdk;\u6923\u0100;o\u13e7\u13e5ear;\u6927\u1253\u1a95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2d2d\0\u2d38\u2d48\u2d60\u2d65\u2d72\u2d84\u1b07\0\0\u2d8d\u2dab\0\u2dc8\u2dce\0\u2ddc\u2e19\u2e2b\u2e3e\u2e43\u0100cs\u2d31\u1a97ute\u803b\xf3\u40f3\u0100iy\u2d3c\u2d45r\u0100;c\u1a9e\u2d42\u803b\xf4\u40f4;\u443e\u0280abios\u1aa0\u2d52\u2d57\u01c8\u2d5alac;\u4151v;\u6a38old;\u69bclig;\u4153\u0100cr\u2d69\u2d6dir;\u69bf;\uc000\ud835\udd2c\u036f\u2d79\0\0\u2d7c\0\u2d82n;\u42dbave\u803b\xf2\u40f2;\u69c1\u0100bm\u2d88\u0df4ar;\u69b5\u0200acit\u2d95\u2d98\u2da5\u2da8r\xf2\u1a80\u0100ir\u2d9d\u2da0r;\u69beoss;\u69bbn\xe5\u0e52;\u69c0\u0180aei\u2db1\u2db5\u2db9cr;\u414dga;\u43c9\u0180cdn\u2dc0\u2dc5\u01cdron;\u43bf;\u69b6pf;\uc000\ud835\udd60\u0180ael\u2dd4\u2dd7\u01d2r;\u69b7rp;\u69b9\u0380;adiosv\u2dea\u2deb\u2dee\u2e08\u2e0d\u2e10\u2e16\u6228r\xf2\u1a86\u0200;efm\u2df7\u2df8\u2e02\u2e05\u6a5dr\u0100;o\u2dfe\u2dff\u6134f\xbb\u2dff\u803b\xaa\u40aa\u803b\xba\u40bagof;\u62b6r;\u6a56lope;\u6a57;\u6a5b\u0180clo\u2e1f\u2e21\u2e27\xf2\u2e01ash\u803b\xf8\u40f8l;\u6298i\u016c\u2e2f\u2e34de\u803b\xf5\u40f5es\u0100;a\u01db\u2e3as;\u6a36ml\u803b\xf6\u40f6bar;\u633d\u0ae1\u2e5e\0\u2e7d\0\u2e80\u2e9d\0\u2ea2\u2eb9\0\0\u2ecb\u0e9c\0\u2f13\0\0\u2f2b\u2fbc\0\u2fc8r\u0200;ast\u0403\u2e67\u2e72\u0e85\u8100\xb6;l\u2e6d\u2e6e\u40b6le\xec\u0403\u0269\u2e78\0\0\u2e7bm;\u6af3;\u6afdy;\u443fr\u0280cimpt\u2e8b\u2e8f\u2e93\u1865\u2e97nt;\u4025od;\u402eil;\u6030enk;\u6031r;\uc000\ud835\udd2d\u0180imo\u2ea8\u2eb0\u2eb4\u0100;v\u2ead\u2eae\u43c6;\u43d5ma\xf4\u0a76ne;\u660e\u0180;tv\u2ebf\u2ec0\u2ec8\u43c0chfork\xbb\u1ffd;\u43d6\u0100au\u2ecf\u2edfn\u0100ck\u2ed5\u2eddk\u0100;h\u21f4\u2edb;\u610e\xf6\u21f4s\u0480;abcdemst\u2ef3\u2ef4\u1908\u2ef9\u2efd\u2f04\u2f06\u2f0a\u2f0e\u402bcir;\u6a23ir;\u6a22\u0100ou\u1d40\u2f02;\u6a25;\u6a72n\u80bb\xb1\u0e9dim;\u6a26wo;\u6a27\u0180ipu\u2f19\u2f20\u2f25ntint;\u6a15f;\uc000\ud835\udd61nd\u803b\xa3\u40a3\u0500;Eaceinosu\u0ec8\u2f3f\u2f41\u2f44\u2f47\u2f81\u2f89\u2f92\u2f7e\u2fb6;\u6ab3p;\u6ab7u\xe5\u0ed9\u0100;c\u0ece\u2f4c\u0300;acens\u0ec8\u2f59\u2f5f\u2f66\u2f68\u2f7eppro\xf8\u2f43urlye\xf1\u0ed9\xf1\u0ece\u0180aes\u2f6f\u2f76\u2f7approx;\u6ab9qq;\u6ab5im;\u62e8i\xed\u0edfme\u0100;s\u2f88\u0eae\u6032\u0180Eas\u2f78\u2f90\u2f7a\xf0\u2f75\u0180dfp\u0eec\u2f99\u2faf\u0180als\u2fa0\u2fa5\u2faalar;\u632eine;\u6312urf;\u6313\u0100;t\u0efb\u2fb4\xef\u0efbrel;\u62b0\u0100ci\u2fc0\u2fc5r;\uc000\ud835\udcc5;\u43c8ncsp;\u6008\u0300fiopsu\u2fda\u22e2\u2fdf\u2fe5\u2feb\u2ff1r;\uc000\ud835\udd2epf;\uc000\ud835\udd62rime;\u6057cr;\uc000\ud835\udcc6\u0180aeo\u2ff8\u3009\u3013t\u0100ei\u2ffe\u3005rnion\xf3\u06b0nt;\u6a16st\u0100;e\u3010\u3011\u403f\xf1\u1f19\xf4\u0f14\u0a80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30e0\u310e\u312b\u3147\u3162\u3172\u318e\u3206\u3215\u3224\u3229\u3258\u326e\u3272\u3290\u32b0\u32b7\u0180art\u3047\u304a\u304cr\xf2\u10b3\xf2\u03ddail;\u691car\xf2\u1c65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307f\u308f\u3094\u30cc\u0100eu\u306d\u3071;\uc000\u223d\u0331te;\u4155i\xe3\u116emptyv;\u69b3g\u0200;del\u0fd1\u3089\u308b\u308d;\u6992;\u69a5\xe5\u0fd1uo\u803b\xbb\u40bbr\u0580;abcfhlpstw\u0fdc\u30ac\u30af\u30b7\u30b9\u30bc\u30be\u30c0\u30c3\u30c7\u30cap;\u6975\u0100;f\u0fe0\u30b4s;\u6920;\u6933s;\u691e\xeb\u225d\xf0\u272el;\u6945im;\u6974l;\u61a3;\u619d\u0100ai\u30d1\u30d5il;\u691ao\u0100;n\u30db\u30dc\u6236al\xf3\u0f1e\u0180abr\u30e7\u30ea\u30eer\xf2\u17e5rk;\u6773\u0100ak\u30f3\u30fdc\u0100ek\u30f9\u30fb;\u407d;\u405d\u0100es\u3102\u3104;\u698cl\u0100du\u310a\u310c;\u698e;\u6990\u0200aeuy\u3117\u311c\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xec\u0ff2\xe2\u30fa;\u4440\u0200clqs\u3134\u3137\u313d\u3144a;\u6937dhar;\u6969uo\u0100;r\u020e\u020dh;\u61b3\u0180acg\u314e\u315f\u0f44l\u0200;ips\u0f78\u3158\u315b\u109cn\xe5\u10bbar\xf4\u0fa9t;\u65ad\u0180ilr\u3169\u1023\u316esht;\u697d;\uc000\ud835\udd2f\u0100ao\u3177\u3186r\u0100du\u317d\u317f\xbb\u047b\u0100;l\u1091\u3184;\u696c\u0100;v\u318b\u318c\u43c1;\u43f1\u0180gns\u3195\u31f9\u31fcht\u0300ahlrst\u31a4\u31b0\u31c2\u31d8\u31e4\u31eerrow\u0100;t\u0fdc\u31ada\xe9\u30c8arpoon\u0100du\u31bb\u31bfow\xee\u317ep\xbb\u1092eft\u0100ah\u31ca\u31d0rrow\xf3\u0feaarpoon\xf3\u0551ightarrows;\u61c9quigarro\xf7\u30cbhreetimes;\u62ccg;\u42daingdotse\xf1\u1f32\u0180ahm\u320d\u3210\u3213r\xf2\u0feaa\xf2\u0551;\u600foust\u0100;a\u321e\u321f\u63b1che\xbb\u321fmid;\u6aee\u0200abpt\u3232\u323d\u3240\u3252\u0100nr\u3237\u323ag;\u67edr;\u61fer\xeb\u1003\u0180afl\u3247\u324a\u324er;\u6986;\uc000\ud835\udd63us;\u6a2eimes;\u6a35\u0100ap\u325d\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6a12ar\xf2\u31e3\u0200achq\u327b\u3280\u10bc\u3285quo;\u603ar;\uc000\ud835\udcc7\u0100bu\u30fb\u328ao\u0100;r\u0214\u0213\u0180hir\u3297\u329b\u32a0re\xe5\u31f8mes;\u62cai\u0200;efl\u32aa\u1059\u1821\u32ab\u65b9tri;\u69celuhar;\u6968;\u611e\u0d61\u32d5\u32db\u32df\u332c\u3338\u3371\0\u337a\u33a4\0\0\u33ec\u33f0\0\u3428\u3448\u345a\u34ad\u34b1\u34ca\u34f1\0\u3616\0\0\u3633cute;\u415bqu\xef\u27ba\u0500;Eaceinpsy\u11ed\u32f3\u32f5\u32ff\u3302\u330b\u330f\u331f\u3326\u3329;\u6ab4\u01f0\u32fa\0\u32fc;\u6ab8on;\u4161u\xe5\u11fe\u0100;d\u11f3\u3307il;\u415frc;\u415d\u0180Eas\u3316\u3318\u331b;\u6ab6p;\u6abaim;\u62e9olint;\u6a13i\xed\u1204;\u4441ot\u0180;be\u3334\u1d47\u3335\u62c5;\u6a66\u0380Aacmstx\u3346\u334a\u3357\u335b\u335e\u3363\u336drr;\u61d8r\u0100hr\u3350\u3352\xeb\u2228\u0100;o\u0a36\u0a34t\u803b\xa7\u40a7i;\u403bwar;\u6929m\u0100in\u3369\xf0nu\xf3\xf1t;\u6736r\u0100;o\u3376\u2055\uc000\ud835\udd30\u0200acoy\u3382\u3386\u3391\u33a0rp;\u666f\u0100hy\u338b\u338fcy;\u4449;\u4448rt\u026d\u3399\0\0\u339ci\xe4\u1464ara\xec\u2e6f\u803b\xad\u40ad\u0100gm\u33a8\u33b4ma\u0180;fv\u33b1\u33b2\u33b2\u43c3;\u43c2\u0400;deglnpr\u12ab\u33c5\u33c9\u33ce\u33d6\u33de\u33e1\u33e6ot;\u6a6a\u0100;q\u12b1\u12b0\u0100;E\u33d3\u33d4\u6a9e;\u6aa0\u0100;E\u33db\u33dc\u6a9d;\u6a9fe;\u6246lus;\u6a24arr;\u6972ar\xf2\u113d\u0200aeit\u33f8\u3408\u340f\u3417\u0100ls\u33fd\u3404lsetm\xe9\u336ahp;\u6a33parsl;\u69e4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341c\u341d\u6aaa\u0100;s\u3422\u3423\u6aac;\uc000\u2aac\ufe00\u0180flp\u342e\u3433\u3442tcy;\u444c\u0100;b\u3438\u3439\u402f\u0100;a\u343e\u343f\u69c4r;\u633ff;\uc000\ud835\udd64a\u0100dr\u344d\u0402es\u0100;u\u3454\u3455\u6660it\xbb\u3455\u0180csu\u3460\u3479\u349f\u0100au\u3465\u346fp\u0100;s\u1188\u346b;\uc000\u2293\ufe00p\u0100;s\u11b4\u3475;\uc000\u2294\ufe00u\u0100bp\u347f\u348f\u0180;es\u1197\u119c\u3486et\u0100;e\u1197\u348d\xf1\u119d\u0180;es\u11a8\u11ad\u3496et\u0100;e\u11a8\u349d\xf1\u11ae\u0180;af\u117b\u34a6\u05b0r\u0165\u34ab\u05b1\xbb\u117car\xf2\u1148\u0200cemt\u34b9\u34be\u34c2\u34c5r;\uc000\ud835\udcc8tm\xee\xf1i\xec\u3415ar\xe6\u11be\u0100ar\u34ce\u34d5r\u0100;f\u34d4\u17bf\u6606\u0100an\u34da\u34edight\u0100ep\u34e3\u34eapsilo\xee\u1ee0h\xe9\u2eafs\xbb\u2852\u0280bcmnp\u34fb\u355e\u1209\u358b\u358e\u0480;Edemnprs\u350e\u350f\u3511\u3515\u351e\u3523\u352c\u3531\u3536\u6282;\u6ac5ot;\u6abd\u0100;d\u11da\u351aot;\u6ac3ult;\u6ac1\u0100Ee\u3528\u352a;\u6acb;\u628alus;\u6abfarr;\u6979\u0180eiu\u353d\u3552\u3555t\u0180;en\u350e\u3545\u354bq\u0100;q\u11da\u350feq\u0100;q\u352b\u3528m;\u6ac7\u0100bp\u355a\u355c;\u6ad5;\u6ad3c\u0300;acens\u11ed\u356c\u3572\u3579\u357b\u3326ppro\xf8\u32faurlye\xf1\u11fe\xf1\u11f3\u0180aes\u3582\u3588\u331bppro\xf8\u331aq\xf1\u3317g;\u666a\u0680123;Edehlmnps\u35a9\u35ac\u35af\u121c\u35b2\u35b4\u35c0\u35c9\u35d5\u35da\u35df\u35e8\u35ed\u803b\xb9\u40b9\u803b\xb2\u40b2\u803b\xb3\u40b3;\u6ac6\u0100os\u35b9\u35bct;\u6abeub;\u6ad8\u0100;d\u1222\u35c5ot;\u6ac4s\u0100ou\u35cf\u35d2l;\u67c9b;\u6ad7arr;\u697bult;\u6ac2\u0100Ee\u35e4\u35e6;\u6acc;\u628blus;\u6ac0\u0180eiu\u35f4\u3609\u360ct\u0180;en\u121c\u35fc\u3602q\u0100;q\u1222\u35b2eq\u0100;q\u35e7\u35e4m;\u6ac8\u0100bp\u3611\u3613;\u6ad4;\u6ad6\u0180Aan\u361c\u3620\u362drr;\u61d9r\u0100hr\u3626\u3628\xeb\u222e\u0100;o\u0a2b\u0a29war;\u692alig\u803b\xdf\u40df\u0be1\u3651\u365d\u3660\u12ce\u3673\u3679\0\u367e\u36c2\0\0\0\0\0\u36db\u3703\0\u3709\u376c\0\0\0\u3787\u0272\u3656\0\0\u365bget;\u6316;\u43c4r\xeb\u0e5f\u0180aey\u3666\u366b\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uc000\ud835\udd31\u0200eiko\u3686\u369d\u36b5\u36bc\u01f2\u368b\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369b\u43b8ym;\u43d1\u0100cn\u36a2\u36b2k\u0100as\u36a8\u36aeppro\xf8\u12c1im\xbb\u12acs\xf0\u129e\u0100as\u36ba\u36ae\xf0\u12c1rn\u803b\xfe\u40fe\u01ec\u031f\u36c6\u22e7es\u8180\xd7;bd\u36cf\u36d0\u36d8\u40d7\u0100;a\u190f\u36d5r;\u6a31;\u6a30\u0180eps\u36e1\u36e3\u3700\xe1\u2a4d\u0200;bcf\u0486\u36ec\u36f0\u36f4ot;\u6336ir;\u6af1\u0100;o\u36f9\u36fc\uc000\ud835\udd65rk;\u6ada\xe1\u3362rime;\u6034\u0180aip\u370f\u3712\u3764d\xe5\u1248\u0380adempst\u3721\u374d\u3740\u3751\u3757\u375c\u375fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65b5own\xbb\u1dbbeft\u0100;e\u2800\u373e\xf1\u092e;\u625cight\u0100;e\u32aa\u374b\xf1\u105aot;\u65ecinus;\u6a3alus;\u6a39b;\u69cdime;\u6a3bezium;\u63e2\u0180cht\u3772\u377d\u3781\u0100ry\u3777\u377b;\uc000\ud835\udcc9;\u4446cy;\u445brok;\u4167\u0100io\u378b\u378ex\xf4\u1777head\u0100lr\u3797\u37a0eftarro\xf7\u084fightarrow\xbb\u0f5d\u0900AHabcdfghlmoprstuw\u37d0\u37d3\u37d7\u37e4\u37f0\u37fc\u380e\u381c\u3823\u3834\u3851\u385d\u386b\u38a9\u38cc\u38d2\u38ea\u38f6r\xf2\u03edar;\u6963\u0100cr\u37dc\u37e2ute\u803b\xfa\u40fa\xf2\u1150r\u01e3\u37ea\0\u37edy;\u445eve;\u416d\u0100iy\u37f5\u37farc\u803b\xfb\u40fb;\u4443\u0180abh\u3803\u3806\u380br\xf2\u13adlac;\u4171a\xf2\u13c3\u0100ir\u3813\u3818sht;\u697e;\uc000\ud835\udd32rave\u803b\xf9\u40f9\u0161\u3827\u3831r\u0100lr\u382c\u382e\xbb\u0957\xbb\u1083lk;\u6580\u0100ct\u3839\u384d\u026f\u383f\0\0\u384arn\u0100;e\u3845\u3846\u631cr\xbb\u3846op;\u630fri;\u65f8\u0100al\u3856\u385acr;\u416b\u80bb\xa8\u0349\u0100gp\u3862\u3866on;\u4173f;\uc000\ud835\udd66\u0300adhlsu\u114b\u3878\u387d\u1372\u3891\u38a0own\xe1\u13b3arpoon\u0100lr\u3888\u388cef\xf4\u382digh\xf4\u382fi\u0180;hl\u3899\u389a\u389c\u43c5\xbb\u13faon\xbb\u389aparrows;\u61c8\u0180cit\u38b0\u38c4\u38c8\u026f\u38b6\0\0\u38c1rn\u0100;e\u38bc\u38bd\u631dr\xbb\u38bdop;\u630eng;\u416fri;\u65f9cr;\uc000\ud835\udcca\u0180dir\u38d9\u38dd\u38e2ot;\u62f0lde;\u4169i\u0100;f\u3730\u38e8\xbb\u1813\u0100am\u38ef\u38f2r\xf2\u38a8l\u803b\xfc\u40fcangle;\u69a7\u0780ABDacdeflnoprsz\u391c\u391f\u3929\u392d\u39b5\u39b8\u39bd\u39df\u39e4\u39e8\u39f3\u39f9\u39fd\u3a01\u3a20r\xf2\u03f7ar\u0100;v\u3926\u3927\u6ae8;\u6ae9as\xe8\u03e1\u0100nr\u3932\u3937grt;\u699c\u0380eknprst\u34e3\u3946\u394b\u3952\u395d\u3964\u3996app\xe1\u2415othin\xe7\u1e96\u0180hir\u34eb\u2ec8\u3959op\xf4\u2fb5\u0100;h\u13b7\u3962\xef\u318d\u0100iu\u3969\u396dgm\xe1\u33b3\u0100bp\u3972\u3984setneq\u0100;q\u397d\u3980\uc000\u228a\ufe00;\uc000\u2acb\ufe00setneq\u0100;q\u398f\u3992\uc000\u228b\ufe00;\uc000\u2acc\ufe00\u0100hr\u399b\u399fet\xe1\u369ciangle\u0100lr\u39aa\u39afeft\xbb\u0925ight\xbb\u1051y;\u4432ash\xbb\u1036\u0180elr\u39c4\u39d2\u39d7\u0180;be\u2dea\u39cb\u39cfar;\u62bbq;\u625alip;\u62ee\u0100bt\u39dc\u1468a\xf2\u1469r;\uc000\ud835\udd33tr\xe9\u39aesu\u0100bp\u39ef\u39f1\xbb\u0d1c\xbb\u0d59pf;\uc000\ud835\udd67ro\xf0\u0efbtr\xe9\u39b4\u0100cu\u3a06\u3a0br;\uc000\ud835\udccb\u0100bp\u3a10\u3a18n\u0100Ee\u3980\u3a16\xbb\u397en\u0100Ee\u3992\u3a1e\xbb\u3990igzag;\u699a\u0380cefoprs\u3a36\u3a3b\u3a56\u3a5b\u3a54\u3a61\u3a6airc;\u4175\u0100di\u3a40\u3a51\u0100bg\u3a45\u3a49ar;\u6a5fe\u0100;q\u15fa\u3a4f;\u6259erp;\u6118r;\uc000\ud835\udd34pf;\uc000\ud835\udd68\u0100;e\u1479\u3a66at\xe8\u1479cr;\uc000\ud835\udccc\u0ae3\u178e\u3a87\0\u3a8b\0\u3a90\u3a9b\0\0\u3a9d\u3aa8\u3aab\u3aaf\0\0\u3ac3\u3ace\0\u3ad8\u17dc\u17dftr\xe9\u17d1r;\uc000\ud835\udd35\u0100Aa\u3a94\u3a97r\xf2\u03c3r\xf2\u09f6;\u43be\u0100Aa\u3aa1\u3aa4r\xf2\u03b8r\xf2\u09eba\xf0\u2713is;\u62fb\u0180dpt\u17a4\u3ab5\u3abe\u0100fl\u3aba\u17a9;\uc000\ud835\udd69im\xe5\u17b2\u0100Aa\u3ac7\u3acar\xf2\u03cer\xf2\u0a01\u0100cq\u3ad2\u17b8r;\uc000\ud835\udccd\u0100pt\u17d6\u3adcr\xe9\u17d4\u0400acefiosu\u3af0\u3afd\u3b08\u3b0c\u3b11\u3b15\u3b1b\u3b21c\u0100uy\u3af6\u3afbte\u803b\xfd\u40fd;\u444f\u0100iy\u3b02\u3b06rc;\u4177;\u444bn\u803b\xa5\u40a5r;\uc000\ud835\udd36cy;\u4457pf;\uc000\ud835\udd6acr;\uc000\ud835\udcce\u0100cm\u3b26\u3b29y;\u444el\u803b\xff\u40ff\u0500acdefhiosw\u3b42\u3b48\u3b54\u3b58\u3b64\u3b69\u3b6d\u3b74\u3b7a\u3b80cute;\u417a\u0100ay\u3b4d\u3b52ron;\u417e;\u4437ot;\u417c\u0100et\u3b5d\u3b61tr\xe6\u155fa;\u43b6r;\uc000\ud835\udd37cy;\u4436grarr;\u61ddpf;\uc000\ud835\udd6bcr;\uc000\ud835\udccf\u0100jn\u3b85\u3b87;\u600dj;\u600c"
        .split("")
        .map((c) => c.charCodeAt(0)));

    // Generated using scripts/write-decode-map.ts
    var xmlDecodeTree = new Uint16Array(
    // prettier-ignore
    "\u0200aglq\t\x15\x18\x1b\u026d\x0f\0\0\x12p;\u4026os;\u4027t;\u403et;\u403cuot;\u4022"
        .split("")
        .map((c) => c.charCodeAt(0)));

    // Adapted from https://github.com/mathiasbynens/he/blob/36afe179392226cf1b6ccdb16ebbb7a5a844d93a/src/he.js#L106-L134
    var _a;
    const decodeMap = new Map([
        [0, 65533],
        // C1 Unicode control character reference replacements
        [128, 8364],
        [130, 8218],
        [131, 402],
        [132, 8222],
        [133, 8230],
        [134, 8224],
        [135, 8225],
        [136, 710],
        [137, 8240],
        [138, 352],
        [139, 8249],
        [140, 338],
        [142, 381],
        [145, 8216],
        [146, 8217],
        [147, 8220],
        [148, 8221],
        [149, 8226],
        [150, 8211],
        [151, 8212],
        [152, 732],
        [153, 8482],
        [154, 353],
        [155, 8250],
        [156, 339],
        [158, 382],
        [159, 376],
    ]);
    /**
     * Polyfill for `String.fromCodePoint`. It is used to create a string from a Unicode code point.
     */
    const fromCodePoint = 
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
    (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function (codePoint) {
        let output = "";
        if (codePoint > 0xffff) {
            codePoint -= 0x10000;
            output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);
            codePoint = 0xdc00 | (codePoint & 0x3ff);
        }
        output += String.fromCharCode(codePoint);
        return output;
    };
    /**
     * Replace the given code point with a replacement character if it is a
     * surrogate or is outside the valid range. Otherwise return the code
     * point unchanged.
     */
    function replaceCodePoint(codePoint) {
        var _a;
        if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {
            return 0xfffd;
        }
        return (_a = decodeMap.get(codePoint)) !== null && _a !== void 0 ? _a : codePoint;
    }

    var CharCodes$1;
    (function (CharCodes) {
        CharCodes[CharCodes["NUM"] = 35] = "NUM";
        CharCodes[CharCodes["SEMI"] = 59] = "SEMI";
        CharCodes[CharCodes["EQUALS"] = 61] = "EQUALS";
        CharCodes[CharCodes["ZERO"] = 48] = "ZERO";
        CharCodes[CharCodes["NINE"] = 57] = "NINE";
        CharCodes[CharCodes["LOWER_A"] = 97] = "LOWER_A";
        CharCodes[CharCodes["LOWER_F"] = 102] = "LOWER_F";
        CharCodes[CharCodes["LOWER_X"] = 120] = "LOWER_X";
        CharCodes[CharCodes["LOWER_Z"] = 122] = "LOWER_Z";
        CharCodes[CharCodes["UPPER_A"] = 65] = "UPPER_A";
        CharCodes[CharCodes["UPPER_F"] = 70] = "UPPER_F";
        CharCodes[CharCodes["UPPER_Z"] = 90] = "UPPER_Z";
    })(CharCodes$1 || (CharCodes$1 = {}));
    /** Bit that needs to be set to convert an upper case ASCII character to lower case */
    const TO_LOWER_BIT = 0b100000;
    var BinTrieFlags;
    (function (BinTrieFlags) {
        BinTrieFlags[BinTrieFlags["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
        BinTrieFlags[BinTrieFlags["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
        BinTrieFlags[BinTrieFlags["JUMP_TABLE"] = 127] = "JUMP_TABLE";
    })(BinTrieFlags || (BinTrieFlags = {}));
    function isNumber$1(code) {
        return code >= CharCodes$1.ZERO && code <= CharCodes$1.NINE;
    }
    function isHexadecimalCharacter(code) {
        return ((code >= CharCodes$1.UPPER_A && code <= CharCodes$1.UPPER_F) ||
            (code >= CharCodes$1.LOWER_A && code <= CharCodes$1.LOWER_F));
    }
    function isAsciiAlphaNumeric(code) {
        return ((code >= CharCodes$1.UPPER_A && code <= CharCodes$1.UPPER_Z) ||
            (code >= CharCodes$1.LOWER_A && code <= CharCodes$1.LOWER_Z) ||
            isNumber$1(code));
    }
    /**
     * Checks if the given character is a valid end character for an entity in an attribute.
     *
     * Attribute values that aren't terminated properly aren't parsed, and shouldn't lead to a parser error.
     * See the example in https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state
     */
    function isEntityInAttributeInvalidEnd(code) {
        return code === CharCodes$1.EQUALS || isAsciiAlphaNumeric(code);
    }
    var EntityDecoderState;
    (function (EntityDecoderState) {
        EntityDecoderState[EntityDecoderState["EntityStart"] = 0] = "EntityStart";
        EntityDecoderState[EntityDecoderState["NumericStart"] = 1] = "NumericStart";
        EntityDecoderState[EntityDecoderState["NumericDecimal"] = 2] = "NumericDecimal";
        EntityDecoderState[EntityDecoderState["NumericHex"] = 3] = "NumericHex";
        EntityDecoderState[EntityDecoderState["NamedEntity"] = 4] = "NamedEntity";
    })(EntityDecoderState || (EntityDecoderState = {}));
    var DecodingMode;
    (function (DecodingMode) {
        /** Entities in text nodes that can end with any character. */
        DecodingMode[DecodingMode["Legacy"] = 0] = "Legacy";
        /** Only allow entities terminated with a semicolon. */
        DecodingMode[DecodingMode["Strict"] = 1] = "Strict";
        /** Entities in attributes have limitations on ending characters. */
        DecodingMode[DecodingMode["Attribute"] = 2] = "Attribute";
    })(DecodingMode || (DecodingMode = {}));
    /**
     * Token decoder with support of writing partial entities.
     */
    class EntityDecoder {
        constructor(
        /** The tree used to decode entities. */
        decodeTree, 
        /**
         * The function that is called when a codepoint is decoded.
         *
         * For multi-byte named entities, this will be called multiple times,
         * with the second codepoint, and the same `consumed` value.
         *
         * @param codepoint The decoded codepoint.
         * @param consumed The number of bytes consumed by the decoder.
         */
        emitCodePoint, 
        /** An object that is used to produce errors. */
        errors) {
            this.decodeTree = decodeTree;
            this.emitCodePoint = emitCodePoint;
            this.errors = errors;
            /** The current state of the decoder. */
            this.state = EntityDecoderState.EntityStart;
            /** Characters that were consumed while parsing an entity. */
            this.consumed = 1;
            /**
             * The result of the entity.
             *
             * Either the result index of a numeric entity, or the codepoint of a
             * numeric entity.
             */
            this.result = 0;
            /** The current index in the decode tree. */
            this.treeIndex = 0;
            /** The number of characters that were consumed in excess. */
            this.excess = 1;
            /** The mode in which the decoder is operating. */
            this.decodeMode = DecodingMode.Strict;
        }
        /** Resets the instance to make it reusable. */
        startEntity(decodeMode) {
            this.decodeMode = decodeMode;
            this.state = EntityDecoderState.EntityStart;
            this.result = 0;
            this.treeIndex = 0;
            this.excess = 1;
            this.consumed = 1;
        }
        /**
         * Write an entity to the decoder. This can be called multiple times with partial entities.
         * If the entity is incomplete, the decoder will return -1.
         *
         * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
         * entity is incomplete, and resume when the next string is written.
         *
         * @param string The string containing the entity (or a continuation of the entity).
         * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
         * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
         */
        write(str, offset) {
            switch (this.state) {
                case EntityDecoderState.EntityStart: {
                    if (str.charCodeAt(offset) === CharCodes$1.NUM) {
                        this.state = EntityDecoderState.NumericStart;
                        this.consumed += 1;
                        return this.stateNumericStart(str, offset + 1);
                    }
                    this.state = EntityDecoderState.NamedEntity;
                    return this.stateNamedEntity(str, offset);
                }
                case EntityDecoderState.NumericStart: {
                    return this.stateNumericStart(str, offset);
                }
                case EntityDecoderState.NumericDecimal: {
                    return this.stateNumericDecimal(str, offset);
                }
                case EntityDecoderState.NumericHex: {
                    return this.stateNumericHex(str, offset);
                }
                case EntityDecoderState.NamedEntity: {
                    return this.stateNamedEntity(str, offset);
                }
            }
        }
        /**
         * Switches between the numeric decimal and hexadecimal states.
         *
         * Equivalent to the `Numeric character reference state` in the HTML spec.
         *
         * @param str The string containing the entity (or a continuation of the entity).
         * @param offset The current offset.
         * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
         */
        stateNumericStart(str, offset) {
            if (offset >= str.length) {
                return -1;
            }
            if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes$1.LOWER_X) {
                this.state = EntityDecoderState.NumericHex;
                this.consumed += 1;
                return this.stateNumericHex(str, offset + 1);
            }
            this.state = EntityDecoderState.NumericDecimal;
            return this.stateNumericDecimal(str, offset);
        }
        addToNumericResult(str, start, end, base) {
            if (start !== end) {
                const digitCount = end - start;
                this.result =
                    this.result * Math.pow(base, digitCount) +
                        parseInt(str.substr(start, digitCount), base);
                this.consumed += digitCount;
            }
        }
        /**
         * Parses a hexadecimal numeric entity.
         *
         * Equivalent to the `Hexademical character reference state` in the HTML spec.
         *
         * @param str The string containing the entity (or a continuation of the entity).
         * @param offset The current offset.
         * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
         */
        stateNumericHex(str, offset) {
            const startIdx = offset;
            while (offset < str.length) {
                const char = str.charCodeAt(offset);
                if (isNumber$1(char) || isHexadecimalCharacter(char)) {
                    offset += 1;
                }
                else {
                    this.addToNumericResult(str, startIdx, offset, 16);
                    return this.emitNumericEntity(char, 3);
                }
            }
            this.addToNumericResult(str, startIdx, offset, 16);
            return -1;
        }
        /**
         * Parses a decimal numeric entity.
         *
         * Equivalent to the `Decimal character reference state` in the HTML spec.
         *
         * @param str The string containing the entity (or a continuation of the entity).
         * @param offset The current offset.
         * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
         */
        stateNumericDecimal(str, offset) {
            const startIdx = offset;
            while (offset < str.length) {
                const char = str.charCodeAt(offset);
                if (isNumber$1(char)) {
                    offset += 1;
                }
                else {
                    this.addToNumericResult(str, startIdx, offset, 10);
                    return this.emitNumericEntity(char, 2);
                }
            }
            this.addToNumericResult(str, startIdx, offset, 10);
            return -1;
        }
        /**
         * Validate and emit a numeric entity.
         *
         * Implements the logic from the `Hexademical character reference start
         * state` and `Numeric character reference end state` in the HTML spec.
         *
         * @param lastCp The last code point of the entity. Used to see if the
         *               entity was terminated with a semicolon.
         * @param expectedLength The minimum number of characters that should be
         *                       consumed. Used to validate that at least one digit
         *                       was consumed.
         * @returns The number of characters that were consumed.
         */
        emitNumericEntity(lastCp, expectedLength) {
            var _a;
            // Ensure we consumed at least one digit.
            if (this.consumed <= expectedLength) {
                (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
                return 0;
            }
            // Figure out if this is a legit end of the entity
            if (lastCp === CharCodes$1.SEMI) {
                this.consumed += 1;
            }
            else if (this.decodeMode === DecodingMode.Strict) {
                return 0;
            }
            this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
            if (this.errors) {
                if (lastCp !== CharCodes$1.SEMI) {
                    this.errors.missingSemicolonAfterCharacterReference();
                }
                this.errors.validateNumericCharacterReference(this.result);
            }
            return this.consumed;
        }
        /**
         * Parses a named entity.
         *
         * Equivalent to the `Named character reference state` in the HTML spec.
         *
         * @param str The string containing the entity (or a continuation of the entity).
         * @param offset The current offset.
         * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
         */
        stateNamedEntity(str, offset) {
            const { decodeTree } = this;
            let current = decodeTree[this.treeIndex];
            // The mask is the number of bytes of the value, including the current byte.
            let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
            for (; offset < str.length; offset++, this.excess++) {
                const char = str.charCodeAt(offset);
                this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
                if (this.treeIndex < 0) {
                    return this.result === 0 ||
                        // If we are parsing an attribute
                        (this.decodeMode === DecodingMode.Attribute &&
                            // We shouldn't have consumed any characters after the entity,
                            (valueLength === 0 ||
                                // And there should be no invalid characters.
                                isEntityInAttributeInvalidEnd(char)))
                        ? 0
                        : this.emitNotTerminatedNamedEntity();
                }
                current = decodeTree[this.treeIndex];
                valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
                // If the branch is a value, store it and continue
                if (valueLength !== 0) {
                    // If the entity is terminated by a semicolon, we are done.
                    if (char === CharCodes$1.SEMI) {
                        return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
                    }
                    // If we encounter a non-terminated (legacy) entity while parsing strictly, then ignore it.
                    if (this.decodeMode !== DecodingMode.Strict) {
                        this.result = this.treeIndex;
                        this.consumed += this.excess;
                        this.excess = 0;
                    }
                }
            }
            return -1;
        }
        /**
         * Emit a named entity that was not terminated with a semicolon.
         *
         * @returns The number of characters consumed.
         */
        emitNotTerminatedNamedEntity() {
            var _a;
            const { result, decodeTree } = this;
            const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
            this.emitNamedEntityData(result, valueLength, this.consumed);
            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
            return this.consumed;
        }
        /**
         * Emit a named entity.
         *
         * @param result The index of the entity in the decode tree.
         * @param valueLength The number of bytes in the entity.
         * @param consumed The number of characters consumed.
         *
         * @returns The number of characters consumed.
         */
        emitNamedEntityData(result, valueLength, consumed) {
            const { decodeTree } = this;
            this.emitCodePoint(valueLength === 1
                ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH
                : decodeTree[result + 1], consumed);
            if (valueLength === 3) {
                // For multi-byte values, we need to emit the second byte.
                this.emitCodePoint(decodeTree[result + 2], consumed);
            }
            return consumed;
        }
        /**
         * Signal to the parser that the end of the input was reached.
         *
         * Remaining data will be emitted and relevant errors will be produced.
         *
         * @returns The number of characters consumed.
         */
        end() {
            var _a;
            switch (this.state) {
                case EntityDecoderState.NamedEntity: {
                    // Emit a named entity if we have one.
                    return this.result !== 0 &&
                        (this.decodeMode !== DecodingMode.Attribute ||
                            this.result === this.treeIndex)
                        ? this.emitNotTerminatedNamedEntity()
                        : 0;
                }
                // Otherwise, emit a numeric entity if we have one.
                case EntityDecoderState.NumericDecimal: {
                    return this.emitNumericEntity(0, 2);
                }
                case EntityDecoderState.NumericHex: {
                    return this.emitNumericEntity(0, 3);
                }
                case EntityDecoderState.NumericStart: {
                    (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
                    return 0;
                }
                case EntityDecoderState.EntityStart: {
                    // Return 0 if we have no entity.
                    return 0;
                }
            }
        }
    }
    /**
     * Creates a function that decodes entities in a string.
     *
     * @param decodeTree The decode tree.
     * @returns A function that decodes entities in a string.
     */
    function getDecoder(decodeTree) {
        let ret = "";
        const decoder = new EntityDecoder(decodeTree, (str) => (ret += fromCodePoint(str)));
        return function decodeWithTrie(str, decodeMode) {
            let lastIndex = 0;
            let offset = 0;
            while ((offset = str.indexOf("&", offset)) >= 0) {
                ret += str.slice(lastIndex, offset);
                decoder.startEntity(decodeMode);
                const len = decoder.write(str, 
                // Skip the "&"
                offset + 1);
                if (len < 0) {
                    lastIndex = offset + decoder.end();
                    break;
                }
                lastIndex = offset + len;
                // If `len` is 0, skip the current `&` and continue.
                offset = len === 0 ? lastIndex + 1 : lastIndex;
            }
            const result = ret + str.slice(lastIndex);
            // Make sure we don't keep a reference to the final string.
            ret = "";
            return result;
        };
    }
    /**
     * Determines the branch of the current node that is taken given the current
     * character. This function is used to traverse the trie.
     *
     * @param decodeTree The trie.
     * @param current The current node.
     * @param nodeIdx The index right after the current node and its value.
     * @param char The current character.
     * @returns The index of the next node, or -1 if no branch is taken.
     */
    function determineBranch(decodeTree, current, nodeIdx, char) {
        const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
        const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
        // Case 1: Single branch encoded in jump offset
        if (branchCount === 0) {
            return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
        }
        // Case 2: Multiple branches encoded in jump table
        if (jumpOffset) {
            const value = char - jumpOffset;
            return value < 0 || value >= branchCount
                ? -1
                : decodeTree[nodeIdx + value] - 1;
        }
        // Case 3: Multiple branches encoded in dictionary
        // Binary search for the character.
        let lo = nodeIdx;
        let hi = lo + branchCount - 1;
        while (lo <= hi) {
            const mid = (lo + hi) >>> 1;
            const midVal = decodeTree[mid];
            if (midVal < char) {
                lo = mid + 1;
            }
            else if (midVal > char) {
                hi = mid - 1;
            }
            else {
                return decodeTree[mid + branchCount];
            }
        }
        return -1;
    }
    getDecoder(htmlDecodeTree);
    getDecoder(xmlDecodeTree);

    var CharCodes;
    (function (CharCodes) {
        CharCodes[CharCodes["Tab"] = 9] = "Tab";
        CharCodes[CharCodes["NewLine"] = 10] = "NewLine";
        CharCodes[CharCodes["FormFeed"] = 12] = "FormFeed";
        CharCodes[CharCodes["CarriageReturn"] = 13] = "CarriageReturn";
        CharCodes[CharCodes["Space"] = 32] = "Space";
        CharCodes[CharCodes["ExclamationMark"] = 33] = "ExclamationMark";
        CharCodes[CharCodes["Number"] = 35] = "Number";
        CharCodes[CharCodes["Amp"] = 38] = "Amp";
        CharCodes[CharCodes["SingleQuote"] = 39] = "SingleQuote";
        CharCodes[CharCodes["DoubleQuote"] = 34] = "DoubleQuote";
        CharCodes[CharCodes["Dash"] = 45] = "Dash";
        CharCodes[CharCodes["Slash"] = 47] = "Slash";
        CharCodes[CharCodes["Zero"] = 48] = "Zero";
        CharCodes[CharCodes["Nine"] = 57] = "Nine";
        CharCodes[CharCodes["Semi"] = 59] = "Semi";
        CharCodes[CharCodes["Lt"] = 60] = "Lt";
        CharCodes[CharCodes["Eq"] = 61] = "Eq";
        CharCodes[CharCodes["Gt"] = 62] = "Gt";
        CharCodes[CharCodes["Questionmark"] = 63] = "Questionmark";
        CharCodes[CharCodes["UpperA"] = 65] = "UpperA";
        CharCodes[CharCodes["LowerA"] = 97] = "LowerA";
        CharCodes[CharCodes["UpperF"] = 70] = "UpperF";
        CharCodes[CharCodes["LowerF"] = 102] = "LowerF";
        CharCodes[CharCodes["UpperZ"] = 90] = "UpperZ";
        CharCodes[CharCodes["LowerZ"] = 122] = "LowerZ";
        CharCodes[CharCodes["LowerX"] = 120] = "LowerX";
        CharCodes[CharCodes["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
    })(CharCodes || (CharCodes = {}));
    /** All the states the tokenizer can be in. */
    var State;
    (function (State) {
        State[State["Text"] = 1] = "Text";
        State[State["BeforeTagName"] = 2] = "BeforeTagName";
        State[State["InTagName"] = 3] = "InTagName";
        State[State["InSelfClosingTag"] = 4] = "InSelfClosingTag";
        State[State["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
        State[State["InClosingTagName"] = 6] = "InClosingTagName";
        State[State["AfterClosingTagName"] = 7] = "AfterClosingTagName";
        // Attributes
        State[State["BeforeAttributeName"] = 8] = "BeforeAttributeName";
        State[State["InAttributeName"] = 9] = "InAttributeName";
        State[State["AfterAttributeName"] = 10] = "AfterAttributeName";
        State[State["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
        State[State["InAttributeValueDq"] = 12] = "InAttributeValueDq";
        State[State["InAttributeValueSq"] = 13] = "InAttributeValueSq";
        State[State["InAttributeValueNq"] = 14] = "InAttributeValueNq";
        // Declarations
        State[State["BeforeDeclaration"] = 15] = "BeforeDeclaration";
        State[State["InDeclaration"] = 16] = "InDeclaration";
        // Processing instructions
        State[State["InProcessingInstruction"] = 17] = "InProcessingInstruction";
        // Comments & CDATA
        State[State["BeforeComment"] = 18] = "BeforeComment";
        State[State["CDATASequence"] = 19] = "CDATASequence";
        State[State["InSpecialComment"] = 20] = "InSpecialComment";
        State[State["InCommentLike"] = 21] = "InCommentLike";
        // Special tags
        State[State["BeforeSpecialS"] = 22] = "BeforeSpecialS";
        State[State["SpecialStartSequence"] = 23] = "SpecialStartSequence";
        State[State["InSpecialTag"] = 24] = "InSpecialTag";
        State[State["BeforeEntity"] = 25] = "BeforeEntity";
        State[State["BeforeNumericEntity"] = 26] = "BeforeNumericEntity";
        State[State["InNamedEntity"] = 27] = "InNamedEntity";
        State[State["InNumericEntity"] = 28] = "InNumericEntity";
        State[State["InHexEntity"] = 29] = "InHexEntity";
    })(State || (State = {}));
    function isWhitespace(c) {
        return (c === CharCodes.Space ||
            c === CharCodes.NewLine ||
            c === CharCodes.Tab ||
            c === CharCodes.FormFeed ||
            c === CharCodes.CarriageReturn);
    }
    function isEndOfTagSection(c) {
        return c === CharCodes.Slash || c === CharCodes.Gt || isWhitespace(c);
    }
    function isNumber(c) {
        return c >= CharCodes.Zero && c <= CharCodes.Nine;
    }
    function isASCIIAlpha(c) {
        return ((c >= CharCodes.LowerA && c <= CharCodes.LowerZ) ||
            (c >= CharCodes.UpperA && c <= CharCodes.UpperZ));
    }
    function isHexDigit(c) {
        return ((c >= CharCodes.UpperA && c <= CharCodes.UpperF) ||
            (c >= CharCodes.LowerA && c <= CharCodes.LowerF));
    }
    var QuoteType;
    (function (QuoteType) {
        QuoteType[QuoteType["NoValue"] = 0] = "NoValue";
        QuoteType[QuoteType["Unquoted"] = 1] = "Unquoted";
        QuoteType[QuoteType["Single"] = 2] = "Single";
        QuoteType[QuoteType["Double"] = 3] = "Double";
    })(QuoteType || (QuoteType = {}));
    /**
     * Sequences used to match longer strings.
     *
     * We don't have `Script`, `Style`, or `Title` here. Instead, we re-use the *End
     * sequences with an increased offset.
     */
    const Sequences = {
        Cdata: new Uint8Array([0x43, 0x44, 0x41, 0x54, 0x41, 0x5b]),
        CdataEnd: new Uint8Array([0x5d, 0x5d, 0x3e]),
        CommentEnd: new Uint8Array([0x2d, 0x2d, 0x3e]),
        ScriptEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74]),
        StyleEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x74, 0x79, 0x6c, 0x65]),
        TitleEnd: new Uint8Array([0x3c, 0x2f, 0x74, 0x69, 0x74, 0x6c, 0x65]), // `</title`
    };
    class Tokenizer {
        constructor({ xmlMode = false, decodeEntities = true, }, cbs) {
            this.cbs = cbs;
            /** The current state the tokenizer is in. */
            this.state = State.Text;
            /** The read buffer. */
            this.buffer = "";
            /** The beginning of the section that is currently being read. */
            this.sectionStart = 0;
            /** The index within the buffer that we are currently looking at. */
            this.index = 0;
            /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */
            this.baseState = State.Text;
            /** For special parsing behavior inside of script and style tags. */
            this.isSpecial = false;
            /** Indicates whether the tokenizer has been paused. */
            this.running = true;
            /** The offset of the current buffer. */
            this.offset = 0;
            this.currentSequence = undefined;
            this.sequenceIndex = 0;
            this.trieIndex = 0;
            this.trieCurrent = 0;
            /** For named entities, the index of the value. For numeric entities, the code point. */
            this.entityResult = 0;
            this.entityExcess = 0;
            this.xmlMode = xmlMode;
            this.decodeEntities = decodeEntities;
            this.entityTrie = xmlMode ? xmlDecodeTree : htmlDecodeTree;
        }
        reset() {
            this.state = State.Text;
            this.buffer = "";
            this.sectionStart = 0;
            this.index = 0;
            this.baseState = State.Text;
            this.currentSequence = undefined;
            this.running = true;
            this.offset = 0;
        }
        write(chunk) {
            this.offset += this.buffer.length;
            this.buffer = chunk;
            this.parse();
        }
        end() {
            if (this.running)
                this.finish();
        }
        pause() {
            this.running = false;
        }
        resume() {
            this.running = true;
            if (this.index < this.buffer.length + this.offset) {
                this.parse();
            }
        }
        /**
         * The current index within all of the written data.
         */
        getIndex() {
            return this.index;
        }
        /**
         * The start of the current section.
         */
        getSectionStart() {
            return this.sectionStart;
        }
        stateText(c) {
            if (c === CharCodes.Lt ||
                (!this.decodeEntities && this.fastForwardTo(CharCodes.Lt))) {
                if (this.index > this.sectionStart) {
                    this.cbs.ontext(this.sectionStart, this.index);
                }
                this.state = State.BeforeTagName;
                this.sectionStart = this.index;
            }
            else if (this.decodeEntities && c === CharCodes.Amp) {
                this.state = State.BeforeEntity;
            }
        }
        stateSpecialStartSequence(c) {
            const isEnd = this.sequenceIndex === this.currentSequence.length;
            const isMatch = isEnd
                ? // If we are at the end of the sequence, make sure the tag name has ended
                    isEndOfTagSection(c)
                : // Otherwise, do a case-insensitive comparison
                    (c | 0x20) === this.currentSequence[this.sequenceIndex];
            if (!isMatch) {
                this.isSpecial = false;
            }
            else if (!isEnd) {
                this.sequenceIndex++;
                return;
            }
            this.sequenceIndex = 0;
            this.state = State.InTagName;
            this.stateInTagName(c);
        }
        /** Look for an end tag. For <title> tags, also decode entities. */
        stateInSpecialTag(c) {
            if (this.sequenceIndex === this.currentSequence.length) {
                if (c === CharCodes.Gt || isWhitespace(c)) {
                    const endOfText = this.index - this.currentSequence.length;
                    if (this.sectionStart < endOfText) {
                        // Spoof the index so that reported locations match up.
                        const actualIndex = this.index;
                        this.index = endOfText;
                        this.cbs.ontext(this.sectionStart, endOfText);
                        this.index = actualIndex;
                    }
                    this.isSpecial = false;
                    this.sectionStart = endOfText + 2; // Skip over the `</`
                    this.stateInClosingTagName(c);
                    return; // We are done; skip the rest of the function.
                }
                this.sequenceIndex = 0;
            }
            if ((c | 0x20) === this.currentSequence[this.sequenceIndex]) {
                this.sequenceIndex += 1;
            }
            else if (this.sequenceIndex === 0) {
                if (this.currentSequence === Sequences.TitleEnd) {
                    // We have to parse entities in <title> tags.
                    if (this.decodeEntities && c === CharCodes.Amp) {
                        this.state = State.BeforeEntity;
                    }
                }
                else if (this.fastForwardTo(CharCodes.Lt)) {
                    // Outside of <title> tags, we can fast-forward.
                    this.sequenceIndex = 1;
                }
            }
            else {
                // If we see a `<`, set the sequence index to 1; useful for eg. `<</script>`.
                this.sequenceIndex = Number(c === CharCodes.Lt);
            }
        }
        stateCDATASequence(c) {
            if (c === Sequences.Cdata[this.sequenceIndex]) {
                if (++this.sequenceIndex === Sequences.Cdata.length) {
                    this.state = State.InCommentLike;
                    this.currentSequence = Sequences.CdataEnd;
                    this.sequenceIndex = 0;
                    this.sectionStart = this.index + 1;
                }
            }
            else {
                this.sequenceIndex = 0;
                this.state = State.InDeclaration;
                this.stateInDeclaration(c); // Reconsume the character
            }
        }
        /**
         * When we wait for one specific character, we can speed things up
         * by skipping through the buffer until we find it.
         *
         * @returns Whether the character was found.
         */
        fastForwardTo(c) {
            while (++this.index < this.buffer.length + this.offset) {
                if (this.buffer.charCodeAt(this.index - this.offset) === c) {
                    return true;
                }
            }
            /*
             * We increment the index at the end of the `parse` loop,
             * so set it to `buffer.length - 1` here.
             *
             * TODO: Refactor `parse` to increment index before calling states.
             */
            this.index = this.buffer.length + this.offset - 1;
            return false;
        }
        /**
         * Comments and CDATA end with `-->` and `]]>`.
         *
         * Their common qualities are:
         * - Their end sequences have a distinct character they start with.
         * - That character is then repeated, so we have to check multiple repeats.
         * - All characters but the start character of the sequence can be skipped.
         */
        stateInCommentLike(c) {
            if (c === this.currentSequence[this.sequenceIndex]) {
                if (++this.sequenceIndex === this.currentSequence.length) {
                    if (this.currentSequence === Sequences.CdataEnd) {
                        this.cbs.oncdata(this.sectionStart, this.index, 2);
                    }
                    else {
                        this.cbs.oncomment(this.sectionStart, this.index, 2);
                    }
                    this.sequenceIndex = 0;
                    this.sectionStart = this.index + 1;
                    this.state = State.Text;
                }
            }
            else if (this.sequenceIndex === 0) {
                // Fast-forward to the first character of the sequence
                if (this.fastForwardTo(this.currentSequence[0])) {
                    this.sequenceIndex = 1;
                }
            }
            else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
                // Allow long sequences, eg. --->, ]]]>
                this.sequenceIndex = 0;
            }
        }
        /**
         * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
         *
         * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
         * We allow anything that wouldn't end the tag.
         */
        isTagStartChar(c) {
            return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);
        }
        startSpecial(sequence, offset) {
            this.isSpecial = true;
            this.currentSequence = sequence;
            this.sequenceIndex = offset;
            this.state = State.SpecialStartSequence;
        }
        stateBeforeTagName(c) {
            if (c === CharCodes.ExclamationMark) {
                this.state = State.BeforeDeclaration;
                this.sectionStart = this.index + 1;
            }
            else if (c === CharCodes.Questionmark) {
                this.state = State.InProcessingInstruction;
                this.sectionStart = this.index + 1;
            }
            else if (this.isTagStartChar(c)) {
                const lower = c | 0x20;
                this.sectionStart = this.index;
                if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
                    this.startSpecial(Sequences.TitleEnd, 3);
                }
                else {
                    this.state =
                        !this.xmlMode && lower === Sequences.ScriptEnd[2]
                            ? State.BeforeSpecialS
                            : State.InTagName;
                }
            }
            else if (c === CharCodes.Slash) {
                this.state = State.BeforeClosingTagName;
            }
            else {
                this.state = State.Text;
                this.stateText(c);
            }
        }
        stateInTagName(c) {
            if (isEndOfTagSection(c)) {
                this.cbs.onopentagname(this.sectionStart, this.index);
                this.sectionStart = -1;
                this.state = State.BeforeAttributeName;
                this.stateBeforeAttributeName(c);
            }
        }
        stateBeforeClosingTagName(c) {
            if (isWhitespace(c)) ;
            else if (c === CharCodes.Gt) {
                this.state = State.Text;
            }
            else {
                this.state = this.isTagStartChar(c)
                    ? State.InClosingTagName
                    : State.InSpecialComment;
                this.sectionStart = this.index;
            }
        }
        stateInClosingTagName(c) {
            if (c === CharCodes.Gt || isWhitespace(c)) {
                this.cbs.onclosetag(this.sectionStart, this.index);
                this.sectionStart = -1;
                this.state = State.AfterClosingTagName;
                this.stateAfterClosingTagName(c);
            }
        }
        stateAfterClosingTagName(c) {
            // Skip everything until ">"
            if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
                this.state = State.Text;
                this.baseState = State.Text;
                this.sectionStart = this.index + 1;
            }
        }
        stateBeforeAttributeName(c) {
            if (c === CharCodes.Gt) {
                this.cbs.onopentagend(this.index);
                if (this.isSpecial) {
                    this.state = State.InSpecialTag;
                    this.sequenceIndex = 0;
                }
                else {
                    this.state = State.Text;
                }
                this.baseState = this.state;
                this.sectionStart = this.index + 1;
            }
            else if (c === CharCodes.Slash) {
                this.state = State.InSelfClosingTag;
            }
            else if (!isWhitespace(c)) {
                this.state = State.InAttributeName;
                this.sectionStart = this.index;
            }
        }
        stateInSelfClosingTag(c) {
            if (c === CharCodes.Gt) {
                this.cbs.onselfclosingtag(this.index);
                this.state = State.Text;
                this.baseState = State.Text;
                this.sectionStart = this.index + 1;
                this.isSpecial = false; // Reset special state, in case of self-closing special tags
            }
            else if (!isWhitespace(c)) {
                this.state = State.BeforeAttributeName;
                this.stateBeforeAttributeName(c);
            }
        }
        stateInAttributeName(c) {
            if (c === CharCodes.Eq || isEndOfTagSection(c)) {
                this.cbs.onattribname(this.sectionStart, this.index);
                this.sectionStart = -1;
                this.state = State.AfterAttributeName;
                this.stateAfterAttributeName(c);
            }
        }
        stateAfterAttributeName(c) {
            if (c === CharCodes.Eq) {
                this.state = State.BeforeAttributeValue;
            }
            else if (c === CharCodes.Slash || c === CharCodes.Gt) {
                this.cbs.onattribend(QuoteType.NoValue, this.index);
                this.state = State.BeforeAttributeName;
                this.stateBeforeAttributeName(c);
            }
            else if (!isWhitespace(c)) {
                this.cbs.onattribend(QuoteType.NoValue, this.index);
                this.state = State.InAttributeName;
                this.sectionStart = this.index;
            }
        }
        stateBeforeAttributeValue(c) {
            if (c === CharCodes.DoubleQuote) {
                this.state = State.InAttributeValueDq;
                this.sectionStart = this.index + 1;
            }
            else if (c === CharCodes.SingleQuote) {
                this.state = State.InAttributeValueSq;
                this.sectionStart = this.index + 1;
            }
            else if (!isWhitespace(c)) {
                this.sectionStart = this.index;
                this.state = State.InAttributeValueNq;
                this.stateInAttributeValueNoQuotes(c); // Reconsume token
            }
        }
        handleInAttributeValue(c, quote) {
            if (c === quote ||
                (!this.decodeEntities && this.fastForwardTo(quote))) {
                this.cbs.onattribdata(this.sectionStart, this.index);
                this.sectionStart = -1;
                this.cbs.onattribend(quote === CharCodes.DoubleQuote
                    ? QuoteType.Double
                    : QuoteType.Single, this.index);
                this.state = State.BeforeAttributeName;
            }
            else if (this.decodeEntities && c === CharCodes.Amp) {
                this.baseState = this.state;
                this.state = State.BeforeEntity;
            }
        }
        stateInAttributeValueDoubleQuotes(c) {
            this.handleInAttributeValue(c, CharCodes.DoubleQuote);
        }
        stateInAttributeValueSingleQuotes(c) {
            this.handleInAttributeValue(c, CharCodes.SingleQuote);
        }
        stateInAttributeValueNoQuotes(c) {
            if (isWhitespace(c) || c === CharCodes.Gt) {
                this.cbs.onattribdata(this.sectionStart, this.index);
                this.sectionStart = -1;
                this.cbs.onattribend(QuoteType.Unquoted, this.index);
                this.state = State.BeforeAttributeName;
                this.stateBeforeAttributeName(c);
            }
            else if (this.decodeEntities && c === CharCodes.Amp) {
                this.baseState = this.state;
                this.state = State.BeforeEntity;
            }
        }
        stateBeforeDeclaration(c) {
            if (c === CharCodes.OpeningSquareBracket) {
                this.state = State.CDATASequence;
                this.sequenceIndex = 0;
            }
            else {
                this.state =
                    c === CharCodes.Dash
                        ? State.BeforeComment
                        : State.InDeclaration;
            }
        }
        stateInDeclaration(c) {
            if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
                this.cbs.ondeclaration(this.sectionStart, this.index);
                this.state = State.Text;
                this.sectionStart = this.index + 1;
            }
        }
        stateInProcessingInstruction(c) {
            if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
                this.cbs.onprocessinginstruction(this.sectionStart, this.index);
                this.state = State.Text;
                this.sectionStart = this.index + 1;
            }
        }
        stateBeforeComment(c) {
            if (c === CharCodes.Dash) {
                this.state = State.InCommentLike;
                this.currentSequence = Sequences.CommentEnd;
                // Allow short comments (eg. <!-->)
                this.sequenceIndex = 2;
                this.sectionStart = this.index + 1;
            }
            else {
                this.state = State.InDeclaration;
            }
        }
        stateInSpecialComment(c) {
            if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
                this.cbs.oncomment(this.sectionStart, this.index, 0);
                this.state = State.Text;
                this.sectionStart = this.index + 1;
            }
        }
        stateBeforeSpecialS(c) {
            const lower = c | 0x20;
            if (lower === Sequences.ScriptEnd[3]) {
                this.startSpecial(Sequences.ScriptEnd, 4);
            }
            else if (lower === Sequences.StyleEnd[3]) {
                this.startSpecial(Sequences.StyleEnd, 4);
            }
            else {
                this.state = State.InTagName;
                this.stateInTagName(c); // Consume the token again
            }
        }
        stateBeforeEntity(c) {
            // Start excess with 1 to include the '&'
            this.entityExcess = 1;
            this.entityResult = 0;
            if (c === CharCodes.Number) {
                this.state = State.BeforeNumericEntity;
            }
            else if (c === CharCodes.Amp) ;
            else {
                this.trieIndex = 0;
                this.trieCurrent = this.entityTrie[0];
                this.state = State.InNamedEntity;
                this.stateInNamedEntity(c);
            }
        }
        stateInNamedEntity(c) {
            this.entityExcess += 1;
            this.trieIndex = determineBranch(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c);
            if (this.trieIndex < 0) {
                this.emitNamedEntity();
                this.index--;
                return;
            }
            this.trieCurrent = this.entityTrie[this.trieIndex];
            const masked = this.trieCurrent & BinTrieFlags.VALUE_LENGTH;
            // If the branch is a value, store it and continue
            if (masked) {
                // The mask is the number of bytes of the value, including the current byte.
                const valueLength = (masked >> 14) - 1;
                // If we have a legacy entity while parsing strictly, just skip the number of bytes
                if (!this.allowLegacyEntity() && c !== CharCodes.Semi) {
                    this.trieIndex += valueLength;
                }
                else {
                    // Add 1 as we have already incremented the excess
                    const entityStart = this.index - this.entityExcess + 1;
                    if (entityStart > this.sectionStart) {
                        this.emitPartial(this.sectionStart, entityStart);
                    }
                    // If this is a surrogate pair, consume the next two bytes
                    this.entityResult = this.trieIndex;
                    this.trieIndex += valueLength;
                    this.entityExcess = 0;
                    this.sectionStart = this.index + 1;
                    if (valueLength === 0) {
                        this.emitNamedEntity();
                    }
                }
            }
        }
        emitNamedEntity() {
            this.state = this.baseState;
            if (this.entityResult === 0) {
                return;
            }
            const valueLength = (this.entityTrie[this.entityResult] & BinTrieFlags.VALUE_LENGTH) >>
                14;
            switch (valueLength) {
                case 1: {
                    this.emitCodePoint(this.entityTrie[this.entityResult] &
                        ~BinTrieFlags.VALUE_LENGTH);
                    break;
                }
                case 2: {
                    this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
                    break;
                }
                case 3: {
                    this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
                    this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
                }
            }
        }
        stateBeforeNumericEntity(c) {
            if ((c | 0x20) === CharCodes.LowerX) {
                this.entityExcess++;
                this.state = State.InHexEntity;
            }
            else {
                this.state = State.InNumericEntity;
                this.stateInNumericEntity(c);
            }
        }
        emitNumericEntity(strict) {
            const entityStart = this.index - this.entityExcess - 1;
            const numberStart = entityStart + 2 + Number(this.state === State.InHexEntity);
            if (numberStart !== this.index) {
                // Emit leading data if any
                if (entityStart > this.sectionStart) {
                    this.emitPartial(this.sectionStart, entityStart);
                }
                this.sectionStart = this.index + Number(strict);
                this.emitCodePoint(replaceCodePoint(this.entityResult));
            }
            this.state = this.baseState;
        }
        stateInNumericEntity(c) {
            if (c === CharCodes.Semi) {
                this.emitNumericEntity(true);
            }
            else if (isNumber(c)) {
                this.entityResult = this.entityResult * 10 + (c - CharCodes.Zero);
                this.entityExcess++;
            }
            else {
                if (this.allowLegacyEntity()) {
                    this.emitNumericEntity(false);
                }
                else {
                    this.state = this.baseState;
                }
                this.index--;
            }
        }
        stateInHexEntity(c) {
            if (c === CharCodes.Semi) {
                this.emitNumericEntity(true);
            }
            else if (isNumber(c)) {
                this.entityResult = this.entityResult * 16 + (c - CharCodes.Zero);
                this.entityExcess++;
            }
            else if (isHexDigit(c)) {
                this.entityResult =
                    this.entityResult * 16 + ((c | 0x20) - CharCodes.LowerA + 10);
                this.entityExcess++;
            }
            else {
                if (this.allowLegacyEntity()) {
                    this.emitNumericEntity(false);
                }
                else {
                    this.state = this.baseState;
                }
                this.index--;
            }
        }
        allowLegacyEntity() {
            return (!this.xmlMode &&
                (this.baseState === State.Text ||
                    this.baseState === State.InSpecialTag));
        }
        /**
         * Remove data that has already been consumed from the buffer.
         */
        cleanup() {
            // If we are inside of text or attributes, emit what we already have.
            if (this.running && this.sectionStart !== this.index) {
                if (this.state === State.Text ||
                    (this.state === State.InSpecialTag && this.sequenceIndex === 0)) {
                    this.cbs.ontext(this.sectionStart, this.index);
                    this.sectionStart = this.index;
                }
                else if (this.state === State.InAttributeValueDq ||
                    this.state === State.InAttributeValueSq ||
                    this.state === State.InAttributeValueNq) {
                    this.cbs.onattribdata(this.sectionStart, this.index);
                    this.sectionStart = this.index;
                }
            }
        }
        shouldContinue() {
            return this.index < this.buffer.length + this.offset && this.running;
        }
        /**
         * Iterates through the buffer, calling the function corresponding to the current state.
         *
         * States that are more likely to be hit are higher up, as a performance improvement.
         */
        parse() {
            while (this.shouldContinue()) {
                const c = this.buffer.charCodeAt(this.index - this.offset);
                switch (this.state) {
                    case State.Text: {
                        this.stateText(c);
                        break;
                    }
                    case State.SpecialStartSequence: {
                        this.stateSpecialStartSequence(c);
                        break;
                    }
                    case State.InSpecialTag: {
                        this.stateInSpecialTag(c);
                        break;
                    }
                    case State.CDATASequence: {
                        this.stateCDATASequence(c);
                        break;
                    }
                    case State.InAttributeValueDq: {
                        this.stateInAttributeValueDoubleQuotes(c);
                        break;
                    }
                    case State.InAttributeName: {
                        this.stateInAttributeName(c);
                        break;
                    }
                    case State.InCommentLike: {
                        this.stateInCommentLike(c);
                        break;
                    }
                    case State.InSpecialComment: {
                        this.stateInSpecialComment(c);
                        break;
                    }
                    case State.BeforeAttributeName: {
                        this.stateBeforeAttributeName(c);
                        break;
                    }
                    case State.InTagName: {
                        this.stateInTagName(c);
                        break;
                    }
                    case State.InClosingTagName: {
                        this.stateInClosingTagName(c);
                        break;
                    }
                    case State.BeforeTagName: {
                        this.stateBeforeTagName(c);
                        break;
                    }
                    case State.AfterAttributeName: {
                        this.stateAfterAttributeName(c);
                        break;
                    }
                    case State.InAttributeValueSq: {
                        this.stateInAttributeValueSingleQuotes(c);
                        break;
                    }
                    case State.BeforeAttributeValue: {
                        this.stateBeforeAttributeValue(c);
                        break;
                    }
                    case State.BeforeClosingTagName: {
                        this.stateBeforeClosingTagName(c);
                        break;
                    }
                    case State.AfterClosingTagName: {
                        this.stateAfterClosingTagName(c);
                        break;
                    }
                    case State.BeforeSpecialS: {
                        this.stateBeforeSpecialS(c);
                        break;
                    }
                    case State.InAttributeValueNq: {
                        this.stateInAttributeValueNoQuotes(c);
                        break;
                    }
                    case State.InSelfClosingTag: {
                        this.stateInSelfClosingTag(c);
                        break;
                    }
                    case State.InDeclaration: {
                        this.stateInDeclaration(c);
                        break;
                    }
                    case State.BeforeDeclaration: {
                        this.stateBeforeDeclaration(c);
                        break;
                    }
                    case State.BeforeComment: {
                        this.stateBeforeComment(c);
                        break;
                    }
                    case State.InProcessingInstruction: {
                        this.stateInProcessingInstruction(c);
                        break;
                    }
                    case State.InNamedEntity: {
                        this.stateInNamedEntity(c);
                        break;
                    }
                    case State.BeforeEntity: {
                        this.stateBeforeEntity(c);
                        break;
                    }
                    case State.InHexEntity: {
                        this.stateInHexEntity(c);
                        break;
                    }
                    case State.InNumericEntity: {
                        this.stateInNumericEntity(c);
                        break;
                    }
                    default: {
                        // `this._state === State.BeforeNumericEntity`
                        this.stateBeforeNumericEntity(c);
                    }
                }
                this.index++;
            }
            this.cleanup();
        }
        finish() {
            if (this.state === State.InNamedEntity) {
                this.emitNamedEntity();
            }
            // If there is remaining data, emit it in a reasonable way
            if (this.sectionStart < this.index) {
                this.handleTrailingData();
            }
            this.cbs.onend();
        }
        /** Handle any trailing data. */
        handleTrailingData() {
            const endIndex = this.buffer.length + this.offset;
            if (this.state === State.InCommentLike) {
                if (this.currentSequence === Sequences.CdataEnd) {
                    this.cbs.oncdata(this.sectionStart, endIndex, 0);
                }
                else {
                    this.cbs.oncomment(this.sectionStart, endIndex, 0);
                }
            }
            else if (this.state === State.InNumericEntity &&
                this.allowLegacyEntity()) {
                this.emitNumericEntity(false);
                // All trailing data will have been consumed
            }
            else if (this.state === State.InHexEntity &&
                this.allowLegacyEntity()) {
                this.emitNumericEntity(false);
                // All trailing data will have been consumed
            }
            else if (this.state === State.InTagName ||
                this.state === State.BeforeAttributeName ||
                this.state === State.BeforeAttributeValue ||
                this.state === State.AfterAttributeName ||
                this.state === State.InAttributeName ||
                this.state === State.InAttributeValueSq ||
                this.state === State.InAttributeValueDq ||
                this.state === State.InAttributeValueNq ||
                this.state === State.InClosingTagName) ;
            else {
                this.cbs.ontext(this.sectionStart, endIndex);
            }
        }
        emitPartial(start, endIndex) {
            if (this.baseState !== State.Text &&
                this.baseState !== State.InSpecialTag) {
                this.cbs.onattribdata(start, endIndex);
            }
            else {
                this.cbs.ontext(start, endIndex);
            }
        }
        emitCodePoint(cp) {
            if (this.baseState !== State.Text &&
                this.baseState !== State.InSpecialTag) {
                this.cbs.onattribentity(cp);
            }
            else {
                this.cbs.ontextentity(cp);
            }
        }
    }

    const formTags = new Set([
        "input",
        "option",
        "optgroup",
        "select",
        "button",
        "datalist",
        "textarea",
    ]);
    const pTag = new Set(["p"]);
    const tableSectionTags = new Set(["thead", "tbody"]);
    const ddtTags = new Set(["dd", "dt"]);
    const rtpTags = new Set(["rt", "rp"]);
    const openImpliesClose = new Map([
        ["tr", new Set(["tr", "th", "td"])],
        ["th", new Set(["th"])],
        ["td", new Set(["thead", "th", "td"])],
        ["body", new Set(["head", "link", "script"])],
        ["li", new Set(["li"])],
        ["p", pTag],
        ["h1", pTag],
        ["h2", pTag],
        ["h3", pTag],
        ["h4", pTag],
        ["h5", pTag],
        ["h6", pTag],
        ["select", formTags],
        ["input", formTags],
        ["output", formTags],
        ["button", formTags],
        ["datalist", formTags],
        ["textarea", formTags],
        ["option", new Set(["option"])],
        ["optgroup", new Set(["optgroup", "option"])],
        ["dd", ddtTags],
        ["dt", ddtTags],
        ["address", pTag],
        ["article", pTag],
        ["aside", pTag],
        ["blockquote", pTag],
        ["details", pTag],
        ["div", pTag],
        ["dl", pTag],
        ["fieldset", pTag],
        ["figcaption", pTag],
        ["figure", pTag],
        ["footer", pTag],
        ["form", pTag],
        ["header", pTag],
        ["hr", pTag],
        ["main", pTag],
        ["nav", pTag],
        ["ol", pTag],
        ["pre", pTag],
        ["section", pTag],
        ["table", pTag],
        ["ul", pTag],
        ["rt", rtpTags],
        ["rp", rtpTags],
        ["tbody", tableSectionTags],
        ["tfoot", tableSectionTags],
    ]);
    const voidElements = new Set([
        "area",
        "base",
        "basefont",
        "br",
        "col",
        "command",
        "embed",
        "frame",
        "hr",
        "img",
        "input",
        "isindex",
        "keygen",
        "link",
        "meta",
        "param",
        "source",
        "track",
        "wbr",
    ]);
    const foreignContextElements = new Set(["math", "svg"]);
    const htmlIntegrationElements = new Set([
        "mi",
        "mo",
        "mn",
        "ms",
        "mtext",
        "annotation-xml",
        "foreignobject",
        "desc",
        "title",
    ]);
    const reNameEnd = /\s|\//;
    class Parser {
        constructor(cbs, options = {}) {
            var _a, _b, _c, _d, _e;
            this.options = options;
            /** The start index of the last event. */
            this.startIndex = 0;
            /** The end index of the last event. */
            this.endIndex = 0;
            /**
             * Store the start index of the current open tag,
             * so we can update the start index for attributes.
             */
            this.openTagStart = 0;
            this.tagname = "";
            this.attribname = "";
            this.attribvalue = "";
            this.attribs = null;
            this.stack = [];
            this.foreignContext = [];
            this.buffers = [];
            this.bufferOffset = 0;
            /** The index of the last written buffer. Used when resuming after a `pause()`. */
            this.writeIndex = 0;
            /** Indicates whether the parser has finished running / `.end` has been called. */
            this.ended = false;
            this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
            this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== void 0 ? _a : !options.xmlMode;
            this.lowerCaseAttributeNames =
                (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;
            this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer)(this.options, this);
            (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
        }
        // Tokenizer event handlers
        /** @internal */
        ontext(start, endIndex) {
            var _a, _b;
            const data = this.getSlice(start, endIndex);
            this.endIndex = endIndex - 1;
            (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data);
            this.startIndex = endIndex;
        }
        /** @internal */
        ontextentity(cp) {
            var _a, _b;
            /*
             * Entities can be emitted on the character, or directly after.
             * We use the section start here to get accurate indices.
             */
            const index = this.tokenizer.getSectionStart();
            this.endIndex = index - 1;
            (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, fromCodePoint(cp));
            this.startIndex = index;
        }
        isVoidElement(name) {
            return !this.options.xmlMode && voidElements.has(name);
        }
        /** @internal */
        onopentagname(start, endIndex) {
            this.endIndex = endIndex;
            let name = this.getSlice(start, endIndex);
            if (this.lowerCaseTagNames) {
                name = name.toLowerCase();
            }
            this.emitOpenTag(name);
        }
        emitOpenTag(name) {
            var _a, _b, _c, _d;
            this.openTagStart = this.startIndex;
            this.tagname = name;
            const impliesClose = !this.options.xmlMode && openImpliesClose.get(name);
            if (impliesClose) {
                while (this.stack.length > 0 &&
                    impliesClose.has(this.stack[this.stack.length - 1])) {
                    const element = this.stack.pop();
                    (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, element, true);
                }
            }
            if (!this.isVoidElement(name)) {
                this.stack.push(name);
                if (foreignContextElements.has(name)) {
                    this.foreignContext.push(true);
                }
                else if (htmlIntegrationElements.has(name)) {
                    this.foreignContext.push(false);
                }
            }
            (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name);
            if (this.cbs.onopentag)
                this.attribs = {};
        }
        endOpenTag(isImplied) {
            var _a, _b;
            this.startIndex = this.openTagStart;
            if (this.attribs) {
                (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs, isImplied);
                this.attribs = null;
            }
            if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
                this.cbs.onclosetag(this.tagname, true);
            }
            this.tagname = "";
        }
        /** @internal */
        onopentagend(endIndex) {
            this.endIndex = endIndex;
            this.endOpenTag(false);
            // Set `startIndex` for next node
            this.startIndex = endIndex + 1;
        }
        /** @internal */
        onclosetag(start, endIndex) {
            var _a, _b, _c, _d, _e, _f;
            this.endIndex = endIndex;
            let name = this.getSlice(start, endIndex);
            if (this.lowerCaseTagNames) {
                name = name.toLowerCase();
            }
            if (foreignContextElements.has(name) ||
                htmlIntegrationElements.has(name)) {
                this.foreignContext.pop();
            }
            if (!this.isVoidElement(name)) {
                const pos = this.stack.lastIndexOf(name);
                if (pos !== -1) {
                    if (this.cbs.onclosetag) {
                        let count = this.stack.length - pos;
                        while (count--) {
                            // We know the stack has sufficient elements.
                            this.cbs.onclosetag(this.stack.pop(), count !== 0);
                        }
                    }
                    else
                        this.stack.length = pos;
                }
                else if (!this.options.xmlMode && name === "p") {
                    // Implicit open before close
                    this.emitOpenTag("p");
                    this.closeCurrentTag(true);
                }
            }
            else if (!this.options.xmlMode && name === "br") {
                // We can't use `emitOpenTag` for implicit open, as `br` would be implicitly closed.
                (_b = (_a = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a, "br");
                (_d = (_c = this.cbs).onopentag) === null || _d === void 0 ? void 0 : _d.call(_c, "br", {}, true);
                (_f = (_e = this.cbs).onclosetag) === null || _f === void 0 ? void 0 : _f.call(_e, "br", false);
            }
            // Set `startIndex` for next node
            this.startIndex = endIndex + 1;
        }
        /** @internal */
        onselfclosingtag(endIndex) {
            this.endIndex = endIndex;
            if (this.options.xmlMode ||
                this.options.recognizeSelfClosing ||
                this.foreignContext[this.foreignContext.length - 1]) {
                this.closeCurrentTag(false);
                // Set `startIndex` for next node
                this.startIndex = endIndex + 1;
            }
            else {
                // Ignore the fact that the tag is self-closing.
                this.onopentagend(endIndex);
            }
        }
        closeCurrentTag(isOpenImplied) {
            var _a, _b;
            const name = this.tagname;
            this.endOpenTag(isOpenImplied);
            // Self-closing tags will be on the top of the stack
            if (this.stack[this.stack.length - 1] === name) {
                // If the opening tag isn't implied, the closing tag has to be implied.
                (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name, !isOpenImplied);
                this.stack.pop();
            }
        }
        /** @internal */
        onattribname(start, endIndex) {
            this.startIndex = start;
            const name = this.getSlice(start, endIndex);
            this.attribname = this.lowerCaseAttributeNames
                ? name.toLowerCase()
                : name;
        }
        /** @internal */
        onattribdata(start, endIndex) {
            this.attribvalue += this.getSlice(start, endIndex);
        }
        /** @internal */
        onattribentity(cp) {
            this.attribvalue += fromCodePoint(cp);
        }
        /** @internal */
        onattribend(quote, endIndex) {
            var _a, _b;
            this.endIndex = endIndex;
            (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote === QuoteType.Double
                ? '"'
                : quote === QuoteType.Single
                    ? "'"
                    : quote === QuoteType.NoValue
                        ? undefined
                        : null);
            if (this.attribs &&
                !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
                this.attribs[this.attribname] = this.attribvalue;
            }
            this.attribvalue = "";
        }
        getInstructionName(value) {
            const index = value.search(reNameEnd);
            let name = index < 0 ? value : value.substr(0, index);
            if (this.lowerCaseTagNames) {
                name = name.toLowerCase();
            }
            return name;
        }
        /** @internal */
        ondeclaration(start, endIndex) {
            this.endIndex = endIndex;
            const value = this.getSlice(start, endIndex);
            if (this.cbs.onprocessinginstruction) {
                const name = this.getInstructionName(value);
                this.cbs.onprocessinginstruction(`!${name}`, `!${value}`);
            }
            // Set `startIndex` for next node
            this.startIndex = endIndex + 1;
        }
        /** @internal */
        onprocessinginstruction(start, endIndex) {
            this.endIndex = endIndex;
            const value = this.getSlice(start, endIndex);
            if (this.cbs.onprocessinginstruction) {
                const name = this.getInstructionName(value);
                this.cbs.onprocessinginstruction(`?${name}`, `?${value}`);
            }
            // Set `startIndex` for next node
            this.startIndex = endIndex + 1;
        }
        /** @internal */
        oncomment(start, endIndex, offset) {
            var _a, _b, _c, _d;
            this.endIndex = endIndex;
            (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, this.getSlice(start, endIndex - offset));
            (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
            // Set `startIndex` for next node
            this.startIndex = endIndex + 1;
        }
        /** @internal */
        oncdata(start, endIndex, offset) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            this.endIndex = endIndex;
            const value = this.getSlice(start, endIndex - offset);
            if (this.options.xmlMode || this.options.recognizeCDATA) {
                (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);
                (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
                (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
            }
            else {
                (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, `[CDATA[${value}]]`);
                (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
            }
            // Set `startIndex` for next node
            this.startIndex = endIndex + 1;
        }
        /** @internal */
        onend() {
            var _a, _b;
            if (this.cbs.onclosetag) {
                // Set the end index for all remaining tags
                this.endIndex = this.startIndex;
                for (let index = this.stack.length; index > 0; this.cbs.onclosetag(this.stack[--index], true))
                    ;
            }
            (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);
        }
        /**
         * Resets the parser to a blank state, ready to parse a new HTML document
         */
        reset() {
            var _a, _b, _c, _d;
            (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);
            this.tokenizer.reset();
            this.tagname = "";
            this.attribname = "";
            this.attribs = null;
            this.stack.length = 0;
            this.startIndex = 0;
            this.endIndex = 0;
            (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
            this.buffers.length = 0;
            this.bufferOffset = 0;
            this.writeIndex = 0;
            this.ended = false;
        }
        /**
         * Resets the parser, then parses a complete document and
         * pushes it to the handler.
         *
         * @param data Document to parse.
         */
        parseComplete(data) {
            this.reset();
            this.end(data);
        }
        getSlice(start, end) {
            while (start - this.bufferOffset >= this.buffers[0].length) {
                this.shiftBuffer();
            }
            let slice = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
            while (end - this.bufferOffset > this.buffers[0].length) {
                this.shiftBuffer();
                slice += this.buffers[0].slice(0, end - this.bufferOffset);
            }
            return slice;
        }
        shiftBuffer() {
            this.bufferOffset += this.buffers[0].length;
            this.writeIndex--;
            this.buffers.shift();
        }
        /**
         * Parses a chunk of data and calls the corresponding callbacks.
         *
         * @param chunk Chunk to parse.
         */
        write(chunk) {
            var _a, _b;
            if (this.ended) {
                (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".write() after done!"));
                return;
            }
            this.buffers.push(chunk);
            if (this.tokenizer.running) {
                this.tokenizer.write(chunk);
                this.writeIndex++;
            }
        }
        /**
         * Parses the end of the buffer and clears the stack, calls onend.
         *
         * @param chunk Optional final chunk to parse.
         */
        end(chunk) {
            var _a, _b;
            if (this.ended) {
                (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".end() after done!"));
                return;
            }
            if (chunk)
                this.write(chunk);
            this.ended = true;
            this.tokenizer.end();
        }
        /**
         * Pauses parsing. The parser won't emit events until `resume` is called.
         */
        pause() {
            this.tokenizer.pause();
        }
        /**
         * Resumes parsing after `pause` was called.
         */
        resume() {
            this.tokenizer.resume();
            while (this.tokenizer.running &&
                this.writeIndex < this.buffers.length) {
                this.tokenizer.write(this.buffers[this.writeIndex++]);
            }
            if (this.ended)
                this.tokenizer.end();
        }
        /**
         * Alias of `write`, for backwards compatibility.
         *
         * @param chunk Chunk to parse.
         * @deprecated
         */
        parseChunk(chunk) {
            this.write(chunk);
        }
        /**
         * Alias of `end`, for backwards compatibility.
         *
         * @param chunk Optional final chunk to parse.
         * @deprecated
         */
        done(chunk) {
            this.end(chunk);
        }
    }

    const xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
    const xmlCodeMap = new Map([
        [34, "&quot;"],
        [38, "&amp;"],
        [39, "&apos;"],
        [60, "&lt;"],
        [62, "&gt;"],
    ]);
    // For compatibility with node < 4, we wrap `codePointAt`
    const getCodePoint = 
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    String.prototype.codePointAt != null
        ? (str, index) => str.codePointAt(index)
        : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            (c, index) => (c.charCodeAt(index) & 0xfc00) === 0xd800
                ? (c.charCodeAt(index) - 0xd800) * 0x400 +
                    c.charCodeAt(index + 1) -
                    0xdc00 +
                    0x10000
                : c.charCodeAt(index);
    /**
     * Encodes all non-ASCII characters, as well as characters not valid in XML
     * documents using XML entities.
     *
     * If a character has no equivalent entity, a
     * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
     */
    function encodeXML(str) {
        let ret = "";
        let lastIdx = 0;
        let match;
        while ((match = xmlReplacer.exec(str)) !== null) {
            const i = match.index;
            const char = str.charCodeAt(i);
            const next = xmlCodeMap.get(char);
            if (next !== undefined) {
                ret += str.substring(lastIdx, i) + next;
                lastIdx = i + 1;
            }
            else {
                ret += `${str.substring(lastIdx, i)}&#x${getCodePoint(str, i).toString(16)};`;
                // Increase by 1 if we have a surrogate pair
                lastIdx = xmlReplacer.lastIndex += Number((char & 0xfc00) === 0xd800);
            }
        }
        return ret + str.substr(lastIdx);
    }
    /**
     * Creates a function that escapes all characters matched by the given regular
     * expression using the given map of characters to escape to their entities.
     *
     * @param regex Regular expression to match characters to escape.
     * @param map Map of characters to escape to their entities.
     *
     * @returns Function that escapes all characters matched by the given regular
     * expression using the given map of characters to escape to their entities.
     */
    function getEscaper(regex, map) {
        return function escape(data) {
            let match;
            let lastIdx = 0;
            let result = "";
            while ((match = regex.exec(data))) {
                if (lastIdx !== match.index) {
                    result += data.substring(lastIdx, match.index);
                }
                // We know that this character will be in the map.
                result += map.get(match[0].charCodeAt(0));
                // Every match will be of length 1
                lastIdx = match.index + 1;
            }
            return result + data.substring(lastIdx);
        };
    }
    /**
     * Encodes all characters that have to be escaped in HTML attributes,
     * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
     *
     * @param data String to escape.
     */
    const escapeAttribute = getEscaper(/["&\u00A0]/g, new Map([
        [34, "&quot;"],
        [38, "&amp;"],
        [160, "&nbsp;"],
    ]));
    /**
     * Encodes all characters that have to be escaped in HTML text,
     * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
     *
     * @param data String to escape.
     */
    const escapeText = getEscaper(/[&<>\u00A0]/g, new Map([
        [38, "&amp;"],
        [60, "&lt;"],
        [62, "&gt;"],
        [160, "&nbsp;"],
    ]));

    const elementNames = new Map([
        "altGlyph",
        "altGlyphDef",
        "altGlyphItem",
        "animateColor",
        "animateMotion",
        "animateTransform",
        "clipPath",
        "feBlend",
        "feColorMatrix",
        "feComponentTransfer",
        "feComposite",
        "feConvolveMatrix",
        "feDiffuseLighting",
        "feDisplacementMap",
        "feDistantLight",
        "feDropShadow",
        "feFlood",
        "feFuncA",
        "feFuncB",
        "feFuncG",
        "feFuncR",
        "feGaussianBlur",
        "feImage",
        "feMerge",
        "feMergeNode",
        "feMorphology",
        "feOffset",
        "fePointLight",
        "feSpecularLighting",
        "feSpotLight",
        "feTile",
        "feTurbulence",
        "foreignObject",
        "glyphRef",
        "linearGradient",
        "radialGradient",
        "textPath",
    ].map((val) => [val.toLowerCase(), val]));
    const attributeNames = new Map([
        "definitionURL",
        "attributeName",
        "attributeType",
        "baseFrequency",
        "baseProfile",
        "calcMode",
        "clipPathUnits",
        "diffuseConstant",
        "edgeMode",
        "filterUnits",
        "glyphRef",
        "gradientTransform",
        "gradientUnits",
        "kernelMatrix",
        "kernelUnitLength",
        "keyPoints",
        "keySplines",
        "keyTimes",
        "lengthAdjust",
        "limitingConeAngle",
        "markerHeight",
        "markerUnits",
        "markerWidth",
        "maskContentUnits",
        "maskUnits",
        "numOctaves",
        "pathLength",
        "patternContentUnits",
        "patternTransform",
        "patternUnits",
        "pointsAtX",
        "pointsAtY",
        "pointsAtZ",
        "preserveAlpha",
        "preserveAspectRatio",
        "primitiveUnits",
        "refX",
        "refY",
        "repeatCount",
        "repeatDur",
        "requiredExtensions",
        "requiredFeatures",
        "specularConstant",
        "specularExponent",
        "spreadMethod",
        "startOffset",
        "stdDeviation",
        "stitchTiles",
        "surfaceScale",
        "systemLanguage",
        "tableValues",
        "targetX",
        "targetY",
        "textLength",
        "viewBox",
        "viewTarget",
        "xChannelSelector",
        "yChannelSelector",
        "zoomAndPan",
    ].map((val) => [val.toLowerCase(), val]));

    /*
     * Module dependencies
     */
    const unencodedElements = new Set([
        "style",
        "script",
        "xmp",
        "iframe",
        "noembed",
        "noframes",
        "plaintext",
        "noscript",
    ]);
    function replaceQuotes(value) {
        return value.replace(/"/g, "&quot;");
    }
    /**
     * Format attributes
     */
    function formatAttributes(attributes, opts) {
        var _a;
        if (!attributes)
            return;
        const encode = ((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) === false
            ? replaceQuotes
            : opts.xmlMode || opts.encodeEntities !== "utf8"
                ? encodeXML
                : escapeAttribute;
        return Object.keys(attributes)
            .map((key) => {
            var _a, _b;
            const value = (_a = attributes[key]) !== null && _a !== void 0 ? _a : "";
            if (opts.xmlMode === "foreign") {
                /* Fix up mixed-case attribute names */
                key = (_b = attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
            }
            if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
                return key;
            }
            return `${key}="${encode(value)}"`;
        })
            .join(" ");
    }
    /**
     * Self-enclosing tags
     */
    const singleTag = new Set([
        "area",
        "base",
        "basefont",
        "br",
        "col",
        "command",
        "embed",
        "frame",
        "hr",
        "img",
        "input",
        "isindex",
        "keygen",
        "link",
        "meta",
        "param",
        "source",
        "track",
        "wbr",
    ]);
    /**
     * Renders a DOM node or an array of DOM nodes to a string.
     *
     * Can be thought of as the equivalent of the `outerHTML` of the passed node(s).
     *
     * @param node Node to be rendered.
     * @param options Changes serialization behavior
     */
    function render(node, options = {}) {
        const nodes = "length" in node ? node : [node];
        let output = "";
        for (let i = 0; i < nodes.length; i++) {
            output += renderNode(nodes[i], options);
        }
        return output;
    }
    function renderNode(node, options) {
        switch (node.type) {
            case Root:
                return render(node.children, options);
            // @ts-expect-error We don't use `Doctype` yet
            case Doctype:
            case Directive:
                return renderDirective(node);
            case Comment$1:
                return renderComment(node);
            case CDATA$1:
                return renderCdata(node);
            case Script:
            case Style:
            case Tag:
                return renderTag(node, options);
            case Text$1:
                return renderText(node, options);
        }
    }
    const foreignModeIntegrationPoints = new Set([
        "mi",
        "mo",
        "mn",
        "ms",
        "mtext",
        "annotation-xml",
        "foreignObject",
        "desc",
        "title",
    ]);
    const foreignElements = new Set(["svg", "math"]);
    function renderTag(elem, opts) {
        var _a;
        // Handle SVG / MathML in HTML
        if (opts.xmlMode === "foreign") {
            /* Fix up mixed-case element names */
            elem.name = (_a = elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
            /* Exit foreign mode at integration points */
            if (elem.parent &&
                foreignModeIntegrationPoints.has(elem.parent.name)) {
                opts = { ...opts, xmlMode: false };
            }
        }
        if (!opts.xmlMode && foreignElements.has(elem.name)) {
            opts = { ...opts, xmlMode: "foreign" };
        }
        let tag = `<${elem.name}`;
        const attribs = formatAttributes(elem.attribs, opts);
        if (attribs) {
            tag += ` ${attribs}`;
        }
        if (elem.children.length === 0 &&
            (opts.xmlMode
                ? // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
                    opts.selfClosingTags !== false
                : // User explicitly asked for self-closing tags, even in HTML mode
                    opts.selfClosingTags && singleTag.has(elem.name))) {
            if (!opts.xmlMode)
                tag += " ";
            tag += "/>";
        }
        else {
            tag += ">";
            if (elem.children.length > 0) {
                tag += render(elem.children, opts);
            }
            if (opts.xmlMode || !singleTag.has(elem.name)) {
                tag += `</${elem.name}>`;
            }
        }
        return tag;
    }
    function renderDirective(elem) {
        return `<${elem.data}>`;
    }
    function renderText(elem, opts) {
        var _a;
        let data = elem.data || "";
        // If entities weren't decoded, no need to encode them back
        if (((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) !== false &&
            !(!opts.xmlMode &&
                elem.parent &&
                unencodedElements.has(elem.parent.name))) {
            data =
                opts.xmlMode || opts.encodeEntities !== "utf8"
                    ? encodeXML(data)
                    : escapeText(data);
        }
        return data;
    }
    function renderCdata(elem) {
        return `<![CDATA[${elem.children[0].data}]]>`;
    }
    function renderComment(elem) {
        return `<!--${elem.data}-->`;
    }

    // Helper methods
    /**
     * Parses the data, returns the resulting document.
     *
     * @param data The data that should be parsed.
     * @param options Optional options for the parser and DOM builder.
     */
    function parseDocument(data, options) {
        const handler = new DomHandler(undefined, options);
        new Parser(handler, options).end(data);
        return handler.root;
    }

    function getDefaultExportFromCjs (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    var cjs;
    var hasRequiredCjs;

    function requireCjs () {
    	if (hasRequiredCjs) return cjs;
    	hasRequiredCjs = 1;

    	var isMergeableObject = function isMergeableObject(value) {
    		return isNonNullObject(value)
    			&& !isSpecial(value)
    	};

    	function isNonNullObject(value) {
    		return !!value && typeof value === 'object'
    	}

    	function isSpecial(value) {
    		var stringValue = Object.prototype.toString.call(value);

    		return stringValue === '[object RegExp]'
    			|| stringValue === '[object Date]'
    			|| isReactElement(value)
    	}

    	// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
    	var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
    	var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

    	function isReactElement(value) {
    		return value.$$typeof === REACT_ELEMENT_TYPE
    	}

    	function emptyTarget(val) {
    		return Array.isArray(val) ? [] : {}
    	}

    	function cloneUnlessOtherwiseSpecified(value, options) {
    		return (options.clone !== false && options.isMergeableObject(value))
    			? deepmerge(emptyTarget(value), value, options)
    			: value
    	}

    	function defaultArrayMerge(target, source, options) {
    		return target.concat(source).map(function(element) {
    			return cloneUnlessOtherwiseSpecified(element, options)
    		})
    	}

    	function getMergeFunction(key, options) {
    		if (!options.customMerge) {
    			return deepmerge
    		}
    		var customMerge = options.customMerge(key);
    		return typeof customMerge === 'function' ? customMerge : deepmerge
    	}

    	function getEnumerableOwnPropertySymbols(target) {
    		return Object.getOwnPropertySymbols
    			? Object.getOwnPropertySymbols(target).filter(function(symbol) {
    				return Object.propertyIsEnumerable.call(target, symbol)
    			})
    			: []
    	}

    	function getKeys(target) {
    		return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))
    	}

    	function propertyIsOnObject(object, property) {
    		try {
    			return property in object
    		} catch(_) {
    			return false
    		}
    	}

    	// Protects from prototype poisoning and unexpected merging up the prototype chain.
    	function propertyIsUnsafe(target, key) {
    		return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
    			&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
    				&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.
    	}

    	function mergeObject(target, source, options) {
    		var destination = {};
    		if (options.isMergeableObject(target)) {
    			getKeys(target).forEach(function(key) {
    				destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
    			});
    		}
    		getKeys(source).forEach(function(key) {
    			if (propertyIsUnsafe(target, key)) {
    				return
    			}

    			if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
    				destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
    			} else {
    				destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
    			}
    		});
    		return destination
    	}

    	function deepmerge(target, source, options) {
    		options = options || {};
    		options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    		options.isMergeableObject = options.isMergeableObject || isMergeableObject;
    		// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
    		// implementations can use it. The caller may not replace it.
    		options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;

    		var sourceIsArray = Array.isArray(source);
    		var targetIsArray = Array.isArray(target);
    		var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

    		if (!sourceAndTargetTypesMatch) {
    			return cloneUnlessOtherwiseSpecified(source, options)
    		} else if (sourceIsArray) {
    			return options.arrayMerge(target, source, options)
    		} else {
    			return mergeObject(target, source, options)
    		}
    	}

    	deepmerge.all = function deepmergeAll(array, options) {
    		if (!Array.isArray(array)) {
    			throw new Error('first argument should be an array')
    		}

    		return array.reduce(function(prev, next) {
    			return deepmerge(prev, next, options)
    		}, {})
    	};

    	var deepmerge_1 = deepmerge;

    	cjs = deepmerge_1;
    	return cjs;
    }

    var cjsExports = requireCjs();
    var merge = /*@__PURE__*/getDefaultExportFromCjs(cjsExports);

    /**
     * Make a recursive function that will only run to a given depth
     * and switches to an alternative function at that depth. \
     * No limitation if `n` is `undefined` (Just wraps `f` in that case).
     *
     * @param   { number | undefined } n   Allowed depth of recursion. `undefined` for no limitation.
     * @param   { Function }           f   Function that accepts recursive callback as the first argument.
     * @param   { Function }           [g] Function to run instead, when maximum depth was reached. Do nothing by default.
     * @returns { Function }
     */
    function limitedDepthRecursive (n, f, g = () => undefined) {
      if (n === undefined) {
        const f1 = function (...args) { return f(f1, ...args); };
        return f1;
      }
      if (n >= 0) {
        return function (...args) { return f(limitedDepthRecursive(n - 1, f, g), ...args); };
      }
      return g;
    }

    /**
     * Return the same string or a substring with
     * the given character occurrences removed from each side.
     *
     * @param   { string } str  A string to trim.
     * @param   { string } char A character to be trimmed.
     * @returns { string }
     */
    function trimCharacter (str, char) {
      let start = 0;
      let end = str.length;
      while (start < end && str[start] === char) { ++start; }
      while (end > start && str[end - 1] === char) { --end; }
      return (start > 0 || end < str.length)
        ? str.substring(start, end)
        : str;
    }

    /**
     * Return the same string or a substring with
     * the given character occurrences removed from the end only.
     *
     * @param   { string } str  A string to trim.
     * @param   { string } char A character to be trimmed.
     * @returns { string }
     */
    function trimCharacterEnd (str, char) {
      let end = str.length;
      while (end > 0 && str[end - 1] === char) { --end; }
      return (end < str.length)
        ? str.substring(0, end)
        : str;
    }

    /**
     * Return a new string will all characters replaced with unicode escape sequences.
     * This extreme kind of escaping can used to be safely compose regular expressions.
     *
     * @param { string } str A string to escape.
     * @returns { string } A string of unicode escape sequences.
     */
    function unicodeEscape (str) {
      return str.replace(/[\s\S]/g, c => '\\u' + c.charCodeAt().toString(16).padStart(4, '0'));
    }

    /**
     * Deduplicate an array by a given key callback.
     * Item properties are merged recursively and with the preference for last defined values.
     * Of items with the same key, merged item takes the place of the last item,
     * others are omitted.
     *
     * @param { any[] } items An array to deduplicate.
     * @param { (x: any) => string } getKey Callback to get a value that distinguishes unique items.
     * @returns { any[] }
     */
    function mergeDuplicatesPreferLast (items, getKey) {
      const map = new Map();
      for (let i = items.length; i-- > 0;) {
        const item = items[i];
        const key = getKey(item);
        map.set(
          key,
          (map.has(key))
            ? merge(item, map.get(key), { arrayMerge: overwriteMerge$1 })
            : item
        );
      }
      return [...map.values()].reverse();
    }

    const overwriteMerge$1 = (acc, src, options) => [...src];

    /**
     * Get a nested property from an object.
     *
     * @param   { object }   obj  The object to query for the value.
     * @param   { string[] } path The path to the property.
     * @returns { any }
     */
    function get (obj, path) {
      for (const key of path) {
        if (!obj) { return undefined; }
        obj = obj[key];
      }
      return obj;
    }

    /**
     * Convert a number into alphabetic sequence representation (Sequence without zeroes).
     *
     * For example: `a, ..., z, aa, ..., zz, aaa, ...`.
     *
     * @param   { number } num              Number to convert. Must be >= 1.
     * @param   { string } [baseChar = 'a'] Character for 1 in the sequence.
     * @param   { number } [base = 26]      Number of characters in the sequence.
     * @returns { string }
     */
    function numberToLetterSequence (num, baseChar = 'a', base = 26) {
      const digits = [];
      do {
        num -= 1;
        digits.push(num % base);
        num = (num / base) >> 0; // quick `floor`
      } while (num > 0);
      const baseCode = baseChar.charCodeAt(0);
      return digits
        .reverse()
        .map(n => String.fromCharCode(baseCode + n))
        .join('');
    }

    const I = ['I', 'X', 'C', 'M'];
    const V = ['V', 'L', 'D'];

    /**
     * Convert a number to it's Roman representation. No large numbers extension.
     *
     * @param   { number } num Number to convert. `0 < num <= 3999`.
     * @returns { string }
     */
    function numberToRoman (num) {
      return [...(num) + '']
        .map(n => +n)
        .reverse()
        .map((v, i) => ((v % 5 < 4)
          ? (v < 5 ? '' : V[i]) + I[i].repeat(v % 5)
          : I[i] + (v < 5 ? V[i] : I[i + 1])))
        .reverse()
        .join('');
    }

    /**
     * Helps to build text from words.
     */
    class InlineTextBuilder {
      /**
       * Creates an instance of InlineTextBuilder.
       *
       * If `maxLineLength` is not provided then it is either `options.wordwrap` or unlimited.
       *
       * @param { Options } options           HtmlToText options.
       * @param { number }  [ maxLineLength ] This builder will try to wrap text to fit this line length.
       */
      constructor (options, maxLineLength = undefined) {
        /** @type { string[][] } */
        this.lines = [];
        /** @type { string[] }   */
        this.nextLineWords = [];
        this.maxLineLength = maxLineLength || options.wordwrap || Number.MAX_VALUE;
        this.nextLineAvailableChars = this.maxLineLength;
        this.wrapCharacters = get(options, ['longWordSplit', 'wrapCharacters']) || [];
        this.forceWrapOnLimit = get(options, ['longWordSplit', 'forceWrapOnLimit']) || false;

        this.stashedSpace = false;
        this.wordBreakOpportunity = false;
      }

      /**
       * Add a new word.
       *
       * @param { string } word A word to add.
       * @param { boolean } [noWrap] Don't wrap text even if the line is too long.
       */
      pushWord (word, noWrap = false) {
        if (this.nextLineAvailableChars <= 0 && !noWrap) {
          this.startNewLine();
        }
        const isLineStart = this.nextLineWords.length === 0;
        const cost = word.length + (isLineStart ? 0 : 1);
        if ((cost <= this.nextLineAvailableChars) || noWrap) { // Fits into available budget

          this.nextLineWords.push(word);
          this.nextLineAvailableChars -= cost;

        } else { // Does not fit - try to split the word

          // The word is moved to a new line - prefer to wrap between words.
          const [first, ...rest] = this.splitLongWord(word);
          if (!isLineStart) { this.startNewLine(); }
          this.nextLineWords.push(first);
          this.nextLineAvailableChars -= first.length;
          for (const part of rest) {
            this.startNewLine();
            this.nextLineWords.push(part);
            this.nextLineAvailableChars -= part.length;
          }

        }
      }

      /**
       * Pop a word from the currently built line.
       * This doesn't affect completed lines.
       *
       * @returns { string }
       */
      popWord () {
        const lastWord = this.nextLineWords.pop();
        if (lastWord !== undefined) {
          const isLineStart = this.nextLineWords.length === 0;
          const cost = lastWord.length + (isLineStart ? 0 : 1);
          this.nextLineAvailableChars += cost;
        }
        return lastWord;
      }

      /**
       * Concat a word to the last word already in the builder.
       * Adds a new word in case there are no words yet in the last line.
       *
       * @param { string } word A word to be concatenated.
       * @param { boolean } [noWrap] Don't wrap text even if the line is too long.
       */
      concatWord (word, noWrap = false) {
        if (this.wordBreakOpportunity && word.length > this.nextLineAvailableChars) {
          this.pushWord(word, noWrap);
          this.wordBreakOpportunity = false;
        } else {
          const lastWord = this.popWord();
          this.pushWord((lastWord) ? lastWord.concat(word) : word, noWrap);
        }
      }

      /**
       * Add current line (and more empty lines if provided argument > 1) to the list of complete lines and start a new one.
       *
       * @param { number } n Number of line breaks that will be added to the resulting string.
       */
      startNewLine (n = 1) {
        this.lines.push(this.nextLineWords);
        if (n > 1) {
          this.lines.push(...Array.from({ length: n - 1 }, () => []));
        }
        this.nextLineWords = [];
        this.nextLineAvailableChars = this.maxLineLength;
      }

      /**
       * No words in this builder.
       *
       * @returns { boolean }
       */
      isEmpty () {
        return this.lines.length === 0
            && this.nextLineWords.length === 0;
      }

      clear () {
        this.lines.length = 0;
        this.nextLineWords.length = 0;
        this.nextLineAvailableChars = this.maxLineLength;
      }

      /**
       * Join all lines of words inside the InlineTextBuilder into a complete string.
       *
       * @returns { string }
       */
      toString () {
        return [...this.lines, this.nextLineWords]
          .map(words => words.join(' '))
          .join('\n');
      }

      /**
       * Split a long word up to fit within the word wrap limit.
       * Use either a character to split looking back from the word wrap limit,
       * or truncate to the word wrap limit.
       *
       * @param   { string }   word Input word.
       * @returns { string[] }      Parts of the word.
       */
      splitLongWord (word) {
        const parts = [];
        let idx = 0;
        while (word.length > this.maxLineLength) {

          const firstLine = word.substring(0, this.maxLineLength);
          const remainingChars = word.substring(this.maxLineLength);

          const splitIndex = firstLine.lastIndexOf(this.wrapCharacters[idx]);

          if (splitIndex > -1) { // Found a character to split on

            word = firstLine.substring(splitIndex + 1) + remainingChars;
            parts.push(firstLine.substring(0, splitIndex + 1));

          } else { // Not found a character to split on

            idx++;
            if (idx < this.wrapCharacters.length) { // There is next character to try

              word = firstLine + remainingChars;

            } else { // No more characters to try

              if (this.forceWrapOnLimit) {
                parts.push(firstLine);
                word = remainingChars;
                if (word.length > this.maxLineLength) {
                  continue;
                }
              } else {
                word = firstLine + remainingChars;
              }
              break;

            }

          }

        }
        parts.push(word); // Add remaining part to array
        return parts;
      }
    }

    /* eslint-disable max-classes-per-file */


    class StackItem {
      constructor (next = null) { this.next = next; }

      getRoot () { return (this.next) ? this.next : this; }
    }

    class BlockStackItem extends StackItem {
      constructor (options, next = null, leadingLineBreaks = 1, maxLineLength = undefined) {
        super(next);
        this.leadingLineBreaks = leadingLineBreaks;
        this.inlineTextBuilder = new InlineTextBuilder(options, maxLineLength);
        this.rawText = '';
        this.stashedLineBreaks = 0;
        this.isPre = next && next.isPre;
        this.isNoWrap = next && next.isNoWrap;
      }
    }

    class ListStackItem extends BlockStackItem {
      constructor (
        options,
        next = null,
        {
          interRowLineBreaks = 1,
          leadingLineBreaks = 2,
          maxLineLength = undefined,
          maxPrefixLength = 0,
          prefixAlign = 'left',
        } = {}
      ) {
        super(options, next, leadingLineBreaks, maxLineLength);
        this.maxPrefixLength = maxPrefixLength;
        this.prefixAlign = prefixAlign;
        this.interRowLineBreaks = interRowLineBreaks;
      }
    }

    class ListItemStackItem extends BlockStackItem {
      constructor (
        options,
        next = null,
        {
          leadingLineBreaks = 1,
          maxLineLength = undefined,
          prefix = '',
        } = {}
      ) {
        super(options, next, leadingLineBreaks, maxLineLength);
        this.prefix = prefix;
      }
    }

    class TableStackItem extends StackItem {
      constructor (next = null) {
        super(next);
        this.rows = [];
        this.isPre = next && next.isPre;
        this.isNoWrap = next && next.isNoWrap;
      }
    }

    class TableRowStackItem extends StackItem {
      constructor (next = null) {
        super(next);
        this.cells = [];
        this.isPre = next && next.isPre;
        this.isNoWrap = next && next.isNoWrap;
      }
    }

    class TableCellStackItem extends StackItem {
      constructor (options, next = null, maxColumnWidth = undefined) {
        super(next);
        this.inlineTextBuilder = new InlineTextBuilder(options, maxColumnWidth);
        this.rawText = '';
        this.stashedLineBreaks = 0;
        this.isPre = next && next.isPre;
        this.isNoWrap = next && next.isNoWrap;
      }
    }

    class TransformerStackItem extends StackItem {
      constructor (next = null, transform) {
        super(next);
        this.transform = transform;
      }
    }

    function charactersToCodes (str) {
      return [...str]
        .map(c => '\\u' + c.charCodeAt(0).toString(16).padStart(4, '0'))
        .join('');
    }

    /**
     * Helps to handle HTML whitespaces.
     *
     * @class WhitespaceProcessor
     */
    class WhitespaceProcessor {

      /**
       * Creates an instance of WhitespaceProcessor.
       *
       * @param { Options } options    HtmlToText options.
       * @memberof WhitespaceProcessor
       */
      constructor (options) {
        this.whitespaceChars = (options.preserveNewlines)
          ? options.whitespaceCharacters.replace(/\n/g, '')
          : options.whitespaceCharacters;
        const whitespaceCodes = charactersToCodes(this.whitespaceChars);
        this.leadingWhitespaceRe = new RegExp(`^[${whitespaceCodes}]`);
        this.trailingWhitespaceRe = new RegExp(`[${whitespaceCodes}]$`);
        this.allWhitespaceOrEmptyRe = new RegExp(`^[${whitespaceCodes}]*$`);
        this.newlineOrNonWhitespaceRe = new RegExp(`(\\n|[^\\n${whitespaceCodes}])`, 'g');
        this.newlineOrNonNewlineStringRe = new RegExp(`(\\n|[^\\n]+)`, 'g');

        if (options.preserveNewlines) {

          const wordOrNewlineRe = new RegExp(`\\n|[^\\n${whitespaceCodes}]+`, 'gm');

          /**
           * Shrink whitespaces and wrap text, add to the builder.
           *
           * @param { string }                  text              Input text.
           * @param { InlineTextBuilder }       inlineTextBuilder A builder to receive processed text.
           * @param { (str: string) => string } [ transform ]     A transform to be applied to words.
           * @param { boolean }                 [noWrap] Don't wrap text even if the line is too long.
           */
          this.shrinkWrapAdd = function (text, inlineTextBuilder, transform = (str => str), noWrap = false) {
            if (!text) { return; }
            const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
            let anyMatch = false;
            let m = wordOrNewlineRe.exec(text);
            if (m) {
              anyMatch = true;
              if (m[0] === '\n') {
                inlineTextBuilder.startNewLine();
              } else if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {
                inlineTextBuilder.pushWord(transform(m[0]), noWrap);
              } else {
                inlineTextBuilder.concatWord(transform(m[0]), noWrap);
              }
              while ((m = wordOrNewlineRe.exec(text)) !== null) {
                if (m[0] === '\n') {
                  inlineTextBuilder.startNewLine();
                } else {
                  inlineTextBuilder.pushWord(transform(m[0]), noWrap);
                }
              }
            }
            inlineTextBuilder.stashedSpace = (previouslyStashedSpace && !anyMatch) || (this.testTrailingWhitespace(text));
            // No need to stash a space in case last added item was a new line,
            // but that won't affect anything later anyway.
          };

        } else {

          const wordRe = new RegExp(`[^${whitespaceCodes}]+`, 'g');

          this.shrinkWrapAdd = function (text, inlineTextBuilder, transform = (str => str), noWrap = false) {
            if (!text) { return; }
            const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
            let anyMatch = false;
            let m = wordRe.exec(text);
            if (m) {
              anyMatch = true;
              if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {
                inlineTextBuilder.pushWord(transform(m[0]), noWrap);
              } else {
                inlineTextBuilder.concatWord(transform(m[0]), noWrap);
              }
              while ((m = wordRe.exec(text)) !== null) {
                inlineTextBuilder.pushWord(transform(m[0]), noWrap);
              }
            }
            inlineTextBuilder.stashedSpace = (previouslyStashedSpace && !anyMatch) || this.testTrailingWhitespace(text);
          };

        }
      }

      /**
       * Add text with only minimal processing.
       * Everything between newlines considered a single word.
       * No whitespace is trimmed.
       * Not affected by preserveNewlines option - `\n` always starts a new line.
       *
       * `noWrap` argument is `true` by default - this won't start a new line
       * even if there is not enough space left in the current line.
       *
       * @param { string }            text              Input text.
       * @param { InlineTextBuilder } inlineTextBuilder A builder to receive processed text.
       * @param { boolean }           [noWrap] Don't wrap text even if the line is too long.
       */
      addLiteral (text, inlineTextBuilder, noWrap = true) {
        if (!text) { return; }
        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
        let anyMatch = false;
        let m = this.newlineOrNonNewlineStringRe.exec(text);
        if (m) {
          anyMatch = true;
          if (m[0] === '\n') {
            inlineTextBuilder.startNewLine();
          } else if (previouslyStashedSpace) {
            inlineTextBuilder.pushWord(m[0], noWrap);
          } else {
            inlineTextBuilder.concatWord(m[0], noWrap);
          }
          while ((m = this.newlineOrNonNewlineStringRe.exec(text)) !== null) {
            if (m[0] === '\n') {
              inlineTextBuilder.startNewLine();
            } else {
              inlineTextBuilder.pushWord(m[0], noWrap);
            }
          }
        }
        inlineTextBuilder.stashedSpace = (previouslyStashedSpace && !anyMatch);
      }

      /**
       * Test whether the given text starts with HTML whitespace character.
       *
       * @param   { string }  text  The string to test.
       * @returns { boolean }
       */
      testLeadingWhitespace (text) {
        return this.leadingWhitespaceRe.test(text);
      }

      /**
       * Test whether the given text ends with HTML whitespace character.
       *
       * @param   { string }  text  The string to test.
       * @returns { boolean }
       */
      testTrailingWhitespace (text) {
        return this.trailingWhitespaceRe.test(text);
      }

      /**
       * Test whether the given text contains any non-whitespace characters.
       *
       * @param   { string }  text  The string to test.
       * @returns { boolean }
       */
      testContainsWords (text) {
        return !this.allWhitespaceOrEmptyRe.test(text);
      }

      /**
       * Return the number of newlines if there are no words.
       *
       * If any word is found then return zero regardless of the actual number of newlines.
       *
       * @param   { string }  text  Input string.
       * @returns { number }
       */
      countNewlinesNoWords (text) {
        this.newlineOrNonWhitespaceRe.lastIndex = 0;
        let counter = 0;
        let match;
        while ((match = this.newlineOrNonWhitespaceRe.exec(text)) !== null) {
          if (match[0] === '\n') {
            counter++;
          } else {
            return 0;
          }
        }
        return counter;
      }

    }

    /**
     * Helps to build text from inline and block elements.
     *
     * @class BlockTextBuilder
     */
    class BlockTextBuilder {

      /**
       * Creates an instance of BlockTextBuilder.
       *
       * @param { Options } options HtmlToText options.
       * @param { import('selderee').Picker<DomNode, TagDefinition> } picker Selectors decision tree picker.
       * @param { any} [metadata] Optional metadata for HTML document, for use in formatters.
       */
      constructor (options, picker, metadata = undefined) {
        this.options = options;
        this.picker = picker;
        this.metadata = metadata;
        this.whitespaceProcessor = new WhitespaceProcessor(options);
        /** @type { StackItem } */
        this._stackItem = new BlockStackItem(options);
        /** @type { TransformerStackItem } */
        this._wordTransformer = undefined;
      }

      /**
       * Put a word-by-word transform function onto the transformations stack.
       *
       * Mainly used for uppercasing. Can be bypassed to add unformatted text such as URLs.
       *
       * Word transformations applied before wrapping.
       *
       * @param { (str: string) => string } wordTransform Word transformation function.
       */
      pushWordTransform (wordTransform) {
        this._wordTransformer = new TransformerStackItem(this._wordTransformer, wordTransform);
      }

      /**
       * Remove a function from the word transformations stack.
       *
       * @returns { (str: string) => string } A function that was removed.
       */
      popWordTransform () {
        if (!this._wordTransformer) { return undefined; }
        const transform = this._wordTransformer.transform;
        this._wordTransformer = this._wordTransformer.next;
        return transform;
      }

      /**
       * Ignore wordwrap option in followup inline additions and disable automatic wrapping.
       */
      startNoWrap () {
        this._stackItem.isNoWrap = true;
      }

      /**
       * Return automatic wrapping to behavior defined by options.
       */
      stopNoWrap () {
        this._stackItem.isNoWrap = false;
      }

      /** @returns { (str: string) => string } */
      _getCombinedWordTransformer () {
        const wt = (this._wordTransformer)
          ? ((str) => applyTransformer(str, this._wordTransformer))
          : undefined;
        const ce = this.options.encodeCharacters;
        return (wt)
          ? ((ce) ? (str) => ce(wt(str)) : wt)
          : ce;
      }

      _popStackItem () {
        const item = this._stackItem;
        this._stackItem = item.next;
        return item;
      }

      /**
       * Add a line break into currently built block.
       */
      addLineBreak () {
        if (!(
          this._stackItem instanceof BlockStackItem
          || this._stackItem instanceof ListItemStackItem
          || this._stackItem instanceof TableCellStackItem
        )) { return; }
        if (this._stackItem.isPre) {
          this._stackItem.rawText += '\n';
        } else {
          this._stackItem.inlineTextBuilder.startNewLine();
        }
      }

      /**
       * Allow to break line in case directly following text will not fit.
       */
      addWordBreakOpportunity () {
        if (
          this._stackItem instanceof BlockStackItem
          || this._stackItem instanceof ListItemStackItem
          || this._stackItem instanceof TableCellStackItem
        ) {
          this._stackItem.inlineTextBuilder.wordBreakOpportunity = true;
        }
      }

      /**
       * Add a node inline into the currently built block.
       *
       * @param { string } str
       * Text content of a node to add.
       *
       * @param { object } [param1]
       * Object holding the parameters of the operation.
       *
       * @param { boolean } [param1.noWordTransform]
       * Ignore word transformers if there are any.
       * Don't encode characters as well.
       * (Use this for things like URL addresses).
       */
      addInline (str, { noWordTransform = false } = {}) {
        if (!(
          this._stackItem instanceof BlockStackItem
          || this._stackItem instanceof ListItemStackItem
          || this._stackItem instanceof TableCellStackItem
        )) { return; }

        if (this._stackItem.isPre) {
          this._stackItem.rawText += str;
          return;
        }

        if (
          str.length === 0 || // empty string
          (
            this._stackItem.stashedLineBreaks && // stashed linebreaks make whitespace irrelevant
            !this.whitespaceProcessor.testContainsWords(str) // no words to add
          )
        ) { return; }

        if (this.options.preserveNewlines) {
          const newlinesNumber = this.whitespaceProcessor.countNewlinesNoWords(str);
          if (newlinesNumber > 0) {
            this._stackItem.inlineTextBuilder.startNewLine(newlinesNumber);
            // keep stashedLineBreaks unchanged
            return;
          }
        }

        if (this._stackItem.stashedLineBreaks) {
          this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);
        }
        this.whitespaceProcessor.shrinkWrapAdd(
          str,
          this._stackItem.inlineTextBuilder,
          (noWordTransform) ? undefined : this._getCombinedWordTransformer(),
          this._stackItem.isNoWrap
        );
        this._stackItem.stashedLineBreaks = 0; // inline text doesn't introduce line breaks
      }

      /**
       * Add a string inline into the currently built block.
       *
       * Use this for markup elements that don't have to adhere
       * to text layout rules.
       *
       * @param { string } str Text to add.
       */
      addLiteral (str) {
        if (!(
          this._stackItem instanceof BlockStackItem
          || this._stackItem instanceof ListItemStackItem
          || this._stackItem instanceof TableCellStackItem
        )) { return; }

        if (str.length === 0) { return; }

        if (this._stackItem.isPre) {
          this._stackItem.rawText += str;
          return;
        }

        if (this._stackItem.stashedLineBreaks) {
          this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);
        }
        this.whitespaceProcessor.addLiteral(
          str,
          this._stackItem.inlineTextBuilder,
          this._stackItem.isNoWrap
        );
        this._stackItem.stashedLineBreaks = 0;
      }

      /**
       * Start building a new block.
       *
       * @param { object } [param0]
       * Object holding the parameters of the block.
       *
       * @param { number } [param0.leadingLineBreaks]
       * This block should have at least this number of line breaks to separate it from any preceding block.
       *
       * @param { number }  [param0.reservedLineLength]
       * Reserve this number of characters on each line for block markup.
       *
       * @param { boolean } [param0.isPre]
       * Should HTML whitespace be preserved inside this block.
       */
      openBlock ({ leadingLineBreaks = 1, reservedLineLength = 0, isPre = false } = {}) {
        const maxLineLength = Math.max(20, this._stackItem.inlineTextBuilder.maxLineLength - reservedLineLength);
        this._stackItem = new BlockStackItem(
          this.options,
          this._stackItem,
          leadingLineBreaks,
          maxLineLength
        );
        if (isPre) { this._stackItem.isPre = true; }
      }

      /**
       * Finalize currently built block, add it's content to the parent block.
       *
       * @param { object } [param0]
       * Object holding the parameters of the block.
       *
       * @param { number } [param0.trailingLineBreaks]
       * This block should have at least this number of line breaks to separate it from any following block.
       *
       * @param { (str: string) => string } [param0.blockTransform]
       * A function to transform the block text before adding to the parent block.
       * This happens after word wrap and should be used in combination with reserved line length
       * in order to keep line lengths correct.
       * Used for whole block markup.
       */
      closeBlock ({ trailingLineBreaks = 1, blockTransform = undefined } = {}) {
        const block = this._popStackItem();
        const blockText = (blockTransform) ? blockTransform(getText(block)) : getText(block);
        addText(this._stackItem, blockText, block.leadingLineBreaks, Math.max(block.stashedLineBreaks, trailingLineBreaks));
      }

      /**
       * Start building a new list.
       *
       * @param { object } [param0]
       * Object holding the parameters of the list.
       *
       * @param { number } [param0.maxPrefixLength]
       * Length of the longest list item prefix.
       * If not supplied or too small then list items won't be aligned properly.
       *
       * @param { 'left' | 'right' } [param0.prefixAlign]
       * Specify how prefixes of different lengths have to be aligned
       * within a column.
       *
       * @param { number } [param0.interRowLineBreaks]
       * Minimum number of line breaks between list items.
       *
       * @param { number } [param0.leadingLineBreaks]
       * This list should have at least this number of line breaks to separate it from any preceding block.
       */
      openList ({ maxPrefixLength = 0, prefixAlign = 'left', interRowLineBreaks = 1, leadingLineBreaks = 2 } = {}) {
        this._stackItem = new ListStackItem(this.options, this._stackItem, {
          interRowLineBreaks: interRowLineBreaks,
          leadingLineBreaks: leadingLineBreaks,
          maxLineLength: this._stackItem.inlineTextBuilder.maxLineLength,
          maxPrefixLength: maxPrefixLength,
          prefixAlign: prefixAlign
        });
      }

      /**
       * Start building a new list item.
       *
       * @param {object} param0
       * Object holding the parameters of the list item.
       *
       * @param { string } [param0.prefix]
       * Prefix for this list item (item number, bullet point, etc).
       */
      openListItem ({ prefix = '' } = {}) {
        if (!(this._stackItem instanceof ListStackItem)) {
          throw new Error('Can\'t add a list item to something that is not a list! Check the formatter.');
        }
        const list = this._stackItem;
        const prefixLength = Math.max(prefix.length, list.maxPrefixLength);
        const maxLineLength = Math.max(20, list.inlineTextBuilder.maxLineLength - prefixLength);
        this._stackItem = new ListItemStackItem(this.options, list, {
          prefix: prefix,
          maxLineLength: maxLineLength,
          leadingLineBreaks: list.interRowLineBreaks
        });
      }

      /**
       * Finalize currently built list item, add it's content to the parent list.
       */
      closeListItem () {
        const listItem = this._popStackItem();
        const list = listItem.next;

        const prefixLength = Math.max(listItem.prefix.length, list.maxPrefixLength);
        const spacing = '\n' + ' '.repeat(prefixLength);
        const prefix = (list.prefixAlign === 'right')
          ? listItem.prefix.padStart(prefixLength)
          : listItem.prefix.padEnd(prefixLength);
        const text = prefix + getText(listItem).replace(/\n/g, spacing);

        addText(
          list,
          text,
          listItem.leadingLineBreaks,
          Math.max(listItem.stashedLineBreaks, list.interRowLineBreaks)
        );
      }

      /**
       * Finalize currently built list, add it's content to the parent block.
       *
       * @param { object } param0
       * Object holding the parameters of the list.
       *
       * @param { number } [param0.trailingLineBreaks]
       * This list should have at least this number of line breaks to separate it from any following block.
       */
      closeList ({ trailingLineBreaks = 2 } = {}) {
        const list = this._popStackItem();
        const text = getText(list);
        if (text) {
          addText(this._stackItem, text, list.leadingLineBreaks, trailingLineBreaks);
        }
      }

      /**
       * Start building a table.
       */
      openTable () {
        this._stackItem = new TableStackItem(this._stackItem);
      }

      /**
       * Start building a table row.
       */
      openTableRow () {
        if (!(this._stackItem instanceof TableStackItem)) {
          throw new Error('Can\'t add a table row to something that is not a table! Check the formatter.');
        }
        this._stackItem = new TableRowStackItem(this._stackItem);
      }

      /**
       * Start building a table cell.
       *
       * @param { object } [param0]
       * Object holding the parameters of the cell.
       *
       * @param { number } [param0.maxColumnWidth]
       * Wrap cell content to this width. Fall back to global wordwrap value if undefined.
       */
      openTableCell ({ maxColumnWidth = undefined } = {}) {
        if (!(this._stackItem instanceof TableRowStackItem)) {
          throw new Error('Can\'t add a table cell to something that is not a table row! Check the formatter.');
        }
        this._stackItem = new TableCellStackItem(this.options, this._stackItem, maxColumnWidth);
      }

      /**
       * Finalize currently built table cell and add it to parent table row's cells.
       *
       * @param { object } [param0]
       * Object holding the parameters of the cell.
       *
       * @param { number } [param0.colspan] How many columns this cell should occupy.
       * @param { number } [param0.rowspan] How many rows this cell should occupy.
       */
      closeTableCell ({ colspan = 1, rowspan = 1 } = {}) {
        const cell = this._popStackItem();
        const text = trimCharacter(getText(cell), '\n');
        cell.next.cells.push({ colspan: colspan, rowspan: rowspan, text: text });
      }

      /**
       * Finalize currently built table row and add it to parent table's rows.
       */
      closeTableRow () {
        const row = this._popStackItem();
        row.next.rows.push(row.cells);
      }

      /**
       * Finalize currently built table and add the rendered text to the parent block.
       *
       * @param { object } param0
       * Object holding the parameters of the table.
       *
       * @param { TablePrinter } param0.tableToString
       * A function to convert a table of stringified cells into a complete table.
       *
       * @param { number } [param0.leadingLineBreaks]
       * This table should have at least this number of line breaks to separate if from any preceding block.
       *
       * @param { number } [param0.trailingLineBreaks]
       * This table should have at least this number of line breaks to separate it from any following block.
       */
      closeTable ({ tableToString, leadingLineBreaks = 2, trailingLineBreaks = 2 }) {
        const table = this._popStackItem();
        const output = tableToString(table.rows);
        if (output) {
          addText(this._stackItem, output, leadingLineBreaks, trailingLineBreaks);
        }
      }

      /**
       * Return the rendered text content of this builder.
       *
       * @returns { string }
       */
      toString () {
        return getText(this._stackItem.getRoot());
        // There should only be the root item if everything is closed properly.
      }

    }

    function getText (stackItem) {
      if (!(
        stackItem instanceof BlockStackItem
        || stackItem instanceof ListItemStackItem
        || stackItem instanceof TableCellStackItem
      )) {
        throw new Error('Only blocks, list items and table cells can be requested for text contents.');
      }
      return (stackItem.inlineTextBuilder.isEmpty())
        ? stackItem.rawText
        : stackItem.rawText + stackItem.inlineTextBuilder.toString();
    }

    function addText (stackItem, text, leadingLineBreaks, trailingLineBreaks) {
      if (!(
        stackItem instanceof BlockStackItem
        || stackItem instanceof ListItemStackItem
        || stackItem instanceof TableCellStackItem
      )) {
        throw new Error('Only blocks, list items and table cells can contain text.');
      }
      const parentText = getText(stackItem);
      const lineBreaks = Math.max(stackItem.stashedLineBreaks, leadingLineBreaks);
      stackItem.inlineTextBuilder.clear();
      if (parentText) {
        stackItem.rawText = parentText + '\n'.repeat(lineBreaks) + text;
      } else {
        stackItem.rawText = text;
        stackItem.leadingLineBreaks = lineBreaks;
      }
      stackItem.stashedLineBreaks = trailingLineBreaks;
    }

    /**
     * @param { string } str A string to transform.
     * @param { TransformerStackItem } transformer A transformer item (with possible continuation).
     * @returns { string }
     */
    function applyTransformer (str, transformer) {
      return ((transformer) ? applyTransformer(transformer.transform(str), transformer.next) : str);
    }

    /**
     * Compile selectors into a decision tree,
     * return a function intended for batch processing.
     *
     * @param   { Options } [options = {}]   HtmlToText options (defaults, formatters, user options merged, deduplicated).
     * @returns { (html: string, metadata?: any) => string } Pre-configured converter function.
     * @static
     */
    function compile$1 (options = {}) {
      const selectorsWithoutFormat = options.selectors.filter(s => !s.format);
      if (selectorsWithoutFormat.length) {
        throw new Error(
          'Following selectors have no specified format: ' +
          selectorsWithoutFormat.map(s => `\`${s.selector}\``).join(', ')
        );
      }
      const picker = new DecisionTree(
        options.selectors.map(s => [s.selector, s])
      ).build(hp2Builder);

      if (typeof options.encodeCharacters !== 'function') {
        options.encodeCharacters = makeReplacerFromDict(options.encodeCharacters);
      }

      const baseSelectorsPicker = new DecisionTree(
        options.baseElements.selectors.map((s, i) => [s, i + 1])
      ).build(hp2Builder);
      function findBaseElements (dom) {
        return findBases(dom, options, baseSelectorsPicker);
      }

      const limitedWalk = limitedDepthRecursive(
        options.limits.maxDepth,
        recursiveWalk,
        function (dom, builder) {
          builder.addInline(options.limits.ellipsis || '');
        }
      );

      return function (html, metadata = undefined) {
        return process(html, metadata, options, picker, findBaseElements, limitedWalk);
      };
    }


    /**
     * Convert given HTML according to preprocessed options.
     *
     * @param { string } html HTML content to convert.
     * @param { any } metadata Optional metadata for HTML document, for use in formatters.
     * @param { Options } options HtmlToText options (preprocessed).
     * @param { import('selderee').Picker<DomNode, TagDefinition> } picker
     * Tag definition picker for DOM nodes processing.
     * @param { (dom: DomNode[]) => DomNode[] } findBaseElements
     * Function to extract elements from HTML DOM
     * that will only be present in the output text.
     * @param { RecursiveCallback } walk Recursive callback.
     * @returns { string }
     */
    function process (html, metadata, options, picker, findBaseElements, walk) {
      const maxInputLength = options.limits.maxInputLength;
      if (maxInputLength && html && html.length > maxInputLength) {
        console.warn(
          `Input length ${html.length} is above allowed limit of ${maxInputLength}. Truncating without ellipsis.`
        );
        html = html.substring(0, maxInputLength);
      }

      const document = parseDocument(html, { decodeEntities: options.decodeEntities });
      const bases = findBaseElements(document.children);
      const builder = new BlockTextBuilder(options, picker, metadata);
      walk(bases, builder);
      return builder.toString();
    }


    function findBases (dom, options, baseSelectorsPicker) {
      const results = [];

      function recursiveWalk (walk, /** @type { DomNode[] } */ dom) {
        dom = dom.slice(0, options.limits.maxChildNodes);
        for (const elem of dom) {
          if (elem.type !== 'tag') {
            continue;
          }
          const pickedSelectorIndex = baseSelectorsPicker.pick1(elem);
          if (pickedSelectorIndex > 0) {
            results.push({ selectorIndex: pickedSelectorIndex, element: elem });
          } else if (elem.children) {
            walk(elem.children);
          }
          if (results.length >= options.limits.maxBaseElements) {
            return;
          }
        }
      }

      const limitedWalk = limitedDepthRecursive(
        options.limits.maxDepth,
        recursiveWalk
      );
      limitedWalk(dom);

      if (options.baseElements.orderBy !== 'occurrence') { // 'selectors'
        results.sort((a, b) => a.selectorIndex - b.selectorIndex);
      }
      return (options.baseElements.returnDomByDefault && results.length === 0)
        ? dom
        : results.map(x => x.element);
    }

    /**
     * Function to walk through DOM nodes and accumulate their string representations.
     *
     * @param   { RecursiveCallback } walk    Recursive callback.
     * @param   { DomNode[] }         [dom]   Nodes array to process.
     * @param   { BlockTextBuilder }  builder Passed around to accumulate output text.
     * @private
     */
    function recursiveWalk (walk, dom, builder) {
      if (!dom) { return; }

      const options = builder.options;

      const tooManyChildNodes = dom.length > options.limits.maxChildNodes;
      if (tooManyChildNodes) {
        dom = dom.slice(0, options.limits.maxChildNodes);
        dom.push({
          data: options.limits.ellipsis,
          type: 'text'
        });
      }

      for (const elem of dom) {
        switch (elem.type) {
          case 'text': {
            builder.addInline(elem.data);
            break;
          }
          case 'tag': {
            const tagDefinition = builder.picker.pick1(elem);
            const format = options.formatters[tagDefinition.format];
            format(elem, walk, builder, tagDefinition.options || {});
            break;
          }
        }
      }

      return;
    }

    /**
     * @param { Object<string,string | false> } dict
     * A dictionary where keys are characters to replace
     * and values are replacement strings.
     *
     * First code point from dict keys is used.
     * Compound emojis with ZWJ are not supported (not until Node 16).
     *
     * @returns { ((str: string) => string) | undefined }
     */
    function makeReplacerFromDict (dict) {
      if (!dict || Object.keys(dict).length === 0) {
        return undefined;
      }
      /** @type { [string, string][] } */
      const entries = Object.entries(dict).filter(([, v]) => v !== false);
      const regex = new RegExp(
        entries
          .map(([c]) => `(${unicodeEscape([...c][0])})`)
          .join('|'),
        'g'
      );
      const values = entries.map(([, v]) => v);
      const replacer = (m, ...cgs) => values[cgs.findIndex(cg => cg)];
      return (str) => str.replace(regex, replacer);
    }

    /**
     * Dummy formatter that discards the input and does nothing.
     *
     * @type { FormatCallback }
     */
    function formatSkip (elem, walk, builder, formatOptions) {
      /* do nothing */
    }

    /**
     * Insert the given string literal inline instead of a tag.
     *
     * @type { FormatCallback }
     */
    function formatInlineString (elem, walk, builder, formatOptions) {
      builder.addLiteral(formatOptions.string || '');
    }

    /**
     * Insert a block with the given string literal instead of a tag.
     *
     * @type { FormatCallback }
     */
    function formatBlockString (elem, walk, builder, formatOptions) {
      builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
      builder.addLiteral(formatOptions.string || '');
      builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
    }

    /**
     * Process an inline-level element.
     *
     * @type { FormatCallback }
     */
    function formatInline (elem, walk, builder, formatOptions) {
      walk(elem.children, builder);
    }

    /**
     * Process a block-level container.
     *
     * @type { FormatCallback }
     */
    function formatBlock$1 (elem, walk, builder, formatOptions) {
      builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
      walk(elem.children, builder);
      builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
    }

    function renderOpenTag (elem) {
      const attrs = (elem.attribs && elem.attribs.length)
        ? ' ' + Object.entries(elem.attribs)
          .map(([k, v]) => ((v === '') ? k : `${k}=${v.replace(/"/g, '&quot;')}`))
          .join(' ')
        : '';
      return `<${elem.name}${attrs}>`;
    }

    function renderCloseTag (elem) {
      return `</${elem.name}>`;
    }

    /**
     * Render an element as inline HTML tag, walk through it's children.
     *
     * @type { FormatCallback }
     */
    function formatInlineTag (elem, walk, builder, formatOptions) {
      builder.startNoWrap();
      builder.addLiteral(renderOpenTag(elem));
      builder.stopNoWrap();
      walk(elem.children, builder);
      builder.startNoWrap();
      builder.addLiteral(renderCloseTag(elem));
      builder.stopNoWrap();
    }

    /**
     * Render an element as HTML block bag, walk through it's children.
     *
     * @type { FormatCallback }
     */
    function formatBlockTag (elem, walk, builder, formatOptions) {
      builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
      builder.startNoWrap();
      builder.addLiteral(renderOpenTag(elem));
      builder.stopNoWrap();
      walk(elem.children, builder);
      builder.startNoWrap();
      builder.addLiteral(renderCloseTag(elem));
      builder.stopNoWrap();
      builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
    }

    /**
     * Render an element with all it's children as inline HTML.
     *
     * @type { FormatCallback }
     */
    function formatInlineHtml (elem, walk, builder, formatOptions) {
      builder.startNoWrap();
      builder.addLiteral(
        render(elem, { decodeEntities: builder.options.decodeEntities })
      );
      builder.stopNoWrap();
    }

    /**
     * Render an element with all it's children as HTML block.
     *
     * @type { FormatCallback }
     */
    function formatBlockHtml (elem, walk, builder, formatOptions) {
      builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
      builder.startNoWrap();
      builder.addLiteral(
        render(elem, { decodeEntities: builder.options.decodeEntities })
      );
      builder.stopNoWrap();
      builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
    }

    /**
     * Render inline element wrapped with given strings.
     *
     * @type { FormatCallback }
     */
    function formatInlineSurround (elem, walk, builder, formatOptions) {
      builder.addLiteral(formatOptions.prefix || '');
      walk(elem.children, builder);
      builder.addLiteral(formatOptions.suffix || '');
    }

    var genericFormatters = /*#__PURE__*/Object.freeze({
      __proto__: null,
      block: formatBlock$1,
      blockHtml: formatBlockHtml,
      blockString: formatBlockString,
      blockTag: formatBlockTag,
      inline: formatInline,
      inlineHtml: formatInlineHtml,
      inlineString: formatInlineString,
      inlineSurround: formatInlineSurround,
      inlineTag: formatInlineTag,
      skip: formatSkip
    });

    function getRow (matrix, j) {
      if (!matrix[j]) { matrix[j] = []; }
      return matrix[j];
    }

    function findFirstVacantIndex (row, x = 0) {
      while (row[x]) { x++; }
      return x;
    }

    function transposeInPlace (matrix, maxSize) {
      for (let i = 0; i < maxSize; i++) {
        const rowI = getRow(matrix, i);
        for (let j = 0; j < i; j++) {
          const rowJ = getRow(matrix, j);
          if (rowI[j] || rowJ[i]) {
            const temp = rowI[j];
            rowI[j] = rowJ[i];
            rowJ[i] = temp;
          }
        }
      }
    }

    function putCellIntoLayout (cell, layout, baseRow, baseCol) {
      for (let r = 0; r < cell.rowspan; r++) {
        const layoutRow = getRow(layout, baseRow + r);
        for (let c = 0; c < cell.colspan; c++) {
          layoutRow[baseCol + c] = cell;
        }
      }
    }

    function getOrInitOffset (offsets, index) {
      if (offsets[index] === undefined) {
        offsets[index] = (index === 0) ? 0 : 1 + getOrInitOffset(offsets, index - 1);
      }
      return offsets[index];
    }

    function updateOffset (offsets, base, span, value) {
      offsets[base + span] = Math.max(
        getOrInitOffset(offsets, base + span),
        getOrInitOffset(offsets, base) + value
      );
    }

    /**
     * Render a table into a string.
     * Cells can contain multiline text and span across multiple rows and columns.
     *
     * Modifies cells to add lines array.
     *
     * @param { TablePrinterCell[][] } tableRows Table to render.
     * @param { number } rowSpacing Number of spaces between columns.
     * @param { number } colSpacing Number of empty lines between rows.
     * @returns { string }
     */
    function tableToString (tableRows, rowSpacing, colSpacing) {
      const layout = [];
      let colNumber = 0;
      const rowNumber = tableRows.length;
      const rowOffsets = [0];
      // Fill the layout table and row offsets row-by-row.
      for (let j = 0; j < rowNumber; j++) {
        const layoutRow = getRow(layout, j);
        const cells = tableRows[j];
        let x = 0;
        for (let i = 0; i < cells.length; i++) {
          const cell = cells[i];
          x = findFirstVacantIndex(layoutRow, x);
          putCellIntoLayout(cell, layout, j, x);
          x += cell.colspan;
          cell.lines = cell.text.split('\n');
          const cellHeight = cell.lines.length;
          updateOffset(rowOffsets, j, cell.rowspan, cellHeight + rowSpacing);
        }
        colNumber = (layoutRow.length > colNumber) ? layoutRow.length : colNumber;
      }

      transposeInPlace(layout, (rowNumber > colNumber) ? rowNumber : colNumber);

      const outputLines = [];
      const colOffsets = [0];
      // Fill column offsets and output lines column-by-column.
      for (let x = 0; x < colNumber; x++) {
        let y = 0;
        let cell;
        const rowsInThisColumn = Math.min(rowNumber, layout[x].length);
        while (y < rowsInThisColumn) {
          cell = layout[x][y];
          if (cell) {
            if (!cell.rendered) {
              let cellWidth = 0;
              for (let j = 0; j < cell.lines.length; j++) {
                const line = cell.lines[j];
                const lineOffset = rowOffsets[y] + j;
                outputLines[lineOffset] = (outputLines[lineOffset] || '').padEnd(colOffsets[x]) + line;
                cellWidth = (line.length > cellWidth) ? line.length : cellWidth;
              }
              updateOffset(colOffsets, x, cell.colspan, cellWidth + colSpacing);
              cell.rendered = true;
            }
            y += cell.rowspan;
          } else {
            const lineOffset = rowOffsets[y];
            outputLines[lineOffset] = (outputLines[lineOffset] || '');
            y++;
          }
        }
      }

      return outputLines.join('\n');
    }

    /**
     * Process a line-break.
     *
     * @type { FormatCallback }
     */
    function formatLineBreak (elem, walk, builder, formatOptions) {
      builder.addLineBreak();
    }

    /**
     * Process a `wbr` tag (word break opportunity).
     *
     * @type { FormatCallback }
     */
    function formatWbr (elem, walk, builder, formatOptions) {
      builder.addWordBreakOpportunity();
    }

    /**
     * Process a horizontal line.
     *
     * @type { FormatCallback }
     */
    function formatHorizontalLine (elem, walk, builder, formatOptions) {
      builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
      builder.addInline('-'.repeat(formatOptions.length || builder.options.wordwrap || 40));
      builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
    }

    /**
     * Process a paragraph.
     *
     * @type { FormatCallback }
     */
    function formatParagraph (elem, walk, builder, formatOptions) {
      builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
      walk(elem.children, builder);
      builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
    }

    /**
     * Process a preformatted content.
     *
     * @type { FormatCallback }
     */
    function formatPre (elem, walk, builder, formatOptions) {
      builder.openBlock({
        isPre: true,
        leadingLineBreaks: formatOptions.leadingLineBreaks || 2
      });
      walk(elem.children, builder);
      builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
    }

    /**
     * Process a heading.
     *
     * @type { FormatCallback }
     */
    function formatHeading (elem, walk, builder, formatOptions) {
      builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
      if (formatOptions.uppercase !== false) {
        builder.pushWordTransform(str => str.toUpperCase());
        walk(elem.children, builder);
        builder.popWordTransform();
      } else {
        walk(elem.children, builder);
      }
      builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
    }

    /**
     * Process a blockquote.
     *
     * @type { FormatCallback }
     */
    function formatBlockquote (elem, walk, builder, formatOptions) {
      builder.openBlock({
        leadingLineBreaks: formatOptions.leadingLineBreaks || 2,
        reservedLineLength: 2
      });
      walk(elem.children, builder);
      builder.closeBlock({
        trailingLineBreaks: formatOptions.trailingLineBreaks || 2,
        blockTransform: str => ((formatOptions.trimEmptyLines !== false) ? trimCharacter(str, '\n') : str)
          .split('\n')
          .map(line => '> ' + line)
          .join('\n')
      });
    }

    function withBrackets (str, brackets) {
      if (!brackets) { return str; }

      const lbr = (typeof brackets[0] === 'string')
        ? brackets[0]
        : '[';
      const rbr = (typeof brackets[1] === 'string')
        ? brackets[1]
        : ']';
      return lbr + str + rbr;
    }

    function pathRewrite (path, rewriter, baseUrl, metadata, elem) {
      const modifiedPath = (typeof rewriter === 'function')
        ? rewriter(path, metadata, elem)
        : path;
      return (modifiedPath[0] === '/' && baseUrl)
        ? trimCharacterEnd(baseUrl, '/') + modifiedPath
        : modifiedPath;
    }

    /**
     * Process an image.
     *
     * @type { FormatCallback }
     */
    function formatImage (elem, walk, builder, formatOptions) {
      const attribs = elem.attribs || {};
      const alt = (attribs.alt)
        ? attribs.alt
        : '';
      const src = (!attribs.src)
        ? ''
        : pathRewrite(attribs.src, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);
      const text = (!src)
        ? alt
        : (!alt)
          ? withBrackets(src, formatOptions.linkBrackets)
          : alt + ' ' + withBrackets(src, formatOptions.linkBrackets);

      builder.addInline(text, { noWordTransform: true });
    }

    // a img baseUrl
    // a img pathRewrite
    // a img linkBrackets

    // a     ignoreHref: false
    //            ignoreText ?
    // a     noAnchorUrl: true
    //            can be replaced with selector
    // a     hideLinkHrefIfSameAsText: false
    //            how to compare, what to show (text, href, normalized) ?
    // a     mailto protocol removed without options

    // a     protocols: mailto, tel, ...
    //            can be matched with selector?

    // anchors, protocols - only if no pathRewrite fn is provided

    // normalize-url ?

    // a
    // a[href^="#"] - format:skip by default
    // a[href^="mailto:"] - ?

    /**
     * Process an anchor.
     *
     * @type { FormatCallback }
     */
    function formatAnchor (elem, walk, builder, formatOptions) {
      function getHref () {
        if (formatOptions.ignoreHref) { return ''; }
        if (!elem.attribs || !elem.attribs.href) { return ''; }
        let href = elem.attribs.href.replace(/^mailto:/, '');
        if (formatOptions.noAnchorUrl && href[0] === '#') { return ''; }
        href = pathRewrite(href, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);
        return href;
      }
      const href = getHref();
      if (!href) {
        walk(elem.children, builder);
      } else {
        let text = '';
        builder.pushWordTransform(
          str => {
            if (str) { text += str; }
            return str;
          }
        );
        walk(elem.children, builder);
        builder.popWordTransform();

        const hideSameLink = formatOptions.hideLinkHrefIfSameAsText && href === text;
        if (!hideSameLink) {
          builder.addInline(
            (!text)
              ? href
              : ' ' + withBrackets(href, formatOptions.linkBrackets),
            { noWordTransform: true }
          );
        }
      }
    }

    /**
     * @param { DomNode }           elem               List items with their prefixes.
     * @param { RecursiveCallback } walk               Recursive callback to process child nodes.
     * @param { BlockTextBuilder }  builder            Passed around to accumulate output text.
     * @param { FormatOptions }     formatOptions      Options specific to a formatter.
     * @param { () => string }      nextPrefixCallback Function that returns increasing index each time it is called.
     */
    function formatList (elem, walk, builder, formatOptions, nextPrefixCallback) {
      const isNestedList = get(elem, ['parent', 'name']) === 'li';

      // With Roman numbers, index length is not as straightforward as with Arabic numbers or letters,
      // so the dumb length comparison is the most robust way to get the correct value.
      let maxPrefixLength = 0;
      const listItems = (elem.children || [])
        // it might be more accurate to check only for html spaces here, but no significant benefit
        .filter(child => child.type !== 'text' || !/^\s*$/.test(child.data))
        .map(function (child) {
          if (child.name !== 'li') {
            return { node: child, prefix: '' };
          }
          const prefix = (isNestedList)
            ? nextPrefixCallback().trimStart()
            : nextPrefixCallback();
          if (prefix.length > maxPrefixLength) { maxPrefixLength = prefix.length; }
          return { node: child, prefix: prefix };
        });
      if (!listItems.length) { return; }

      builder.openList({
        interRowLineBreaks: 1,
        leadingLineBreaks: isNestedList ? 1 : (formatOptions.leadingLineBreaks || 2),
        maxPrefixLength: maxPrefixLength,
        prefixAlign: 'left'
      });

      for (const { node, prefix } of listItems) {
        builder.openListItem({ prefix: prefix });
        walk([node], builder);
        builder.closeListItem();
      }

      builder.closeList({ trailingLineBreaks: isNestedList ? 1 : (formatOptions.trailingLineBreaks || 2) });
    }

    /**
     * Process an unordered list.
     *
     * @type { FormatCallback }
     */
    function formatUnorderedList (elem, walk, builder, formatOptions) {
      const prefix = formatOptions.itemPrefix || ' * ';
      return formatList(elem, walk, builder, formatOptions, () => prefix);
    }

    /**
     * Process an ordered list.
     *
     * @type { FormatCallback }
     */
    function formatOrderedList (elem, walk, builder, formatOptions) {
      let nextIndex = Number(elem.attribs.start || '1');
      const indexFunction = getOrderedListIndexFunction(elem.attribs.type);
      const nextPrefixCallback = () => ' ' + indexFunction(nextIndex++) + '. ';
      return formatList(elem, walk, builder, formatOptions, nextPrefixCallback);
    }

    /**
     * Return a function that can be used to generate index markers of a specified format.
     *
     * @param   { string } [olType='1'] Marker type.
     * @returns { (i: number) => string }
     */
    function getOrderedListIndexFunction (olType = '1') {
      switch (olType) {
        case 'a': return (i) => numberToLetterSequence(i, 'a');
        case 'A': return (i) => numberToLetterSequence(i, 'A');
        case 'i': return (i) => numberToRoman(i).toLowerCase();
        case 'I': return (i) => numberToRoman(i);
        case '1':
        default: return (i) => (i).toString();
      }
    }

    /**
     * Given a list of class and ID selectors (prefixed with '.' and '#'),
     * return them as separate lists of names without prefixes.
     *
     * @param { string[] } selectors Class and ID selectors (`[".class", "#id"]` etc).
     * @returns { { classes: string[], ids: string[] } }
     */
    function splitClassesAndIds (selectors) {
      const classes = [];
      const ids = [];
      for (const selector of selectors) {
        if (selector.startsWith('.')) {
          classes.push(selector.substring(1));
        } else if (selector.startsWith('#')) {
          ids.push(selector.substring(1));
        }
      }
      return { classes: classes, ids: ids };
    }

    function isDataTable (attr, tables) {
      if (tables === true) { return true; }
      if (!attr) { return false; }

      const { classes, ids } = splitClassesAndIds(tables);
      const attrClasses = (attr['class'] || '').split(' ');
      const attrIds = (attr['id'] || '').split(' ');

      return attrClasses.some(x => classes.includes(x)) || attrIds.some(x => ids.includes(x));
    }

    /**
     * Process a table (either as a container or as a data table, depending on options).
     *
     * @type { FormatCallback }
     */
    function formatTable (elem, walk, builder, formatOptions) {
      return isDataTable(elem.attribs, builder.options.tables)
        ? formatDataTable(elem, walk, builder, formatOptions)
        : formatBlock(elem, walk, builder, formatOptions);
    }

    function formatBlock (elem, walk, builder, formatOptions) {
      builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks });
      walk(elem.children, builder);
      builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks });
    }

    /**
     * Process a data table.
     *
     * @type { FormatCallback }
     */
    function formatDataTable (elem, walk, builder, formatOptions) {
      builder.openTable();
      elem.children.forEach(walkTable);
      builder.closeTable({
        tableToString: (rows) => tableToString(rows, formatOptions.rowSpacing ?? 0, formatOptions.colSpacing ?? 3),
        leadingLineBreaks: formatOptions.leadingLineBreaks,
        trailingLineBreaks: formatOptions.trailingLineBreaks
      });

      function formatCell (cellNode) {
        const colspan = +get(cellNode, ['attribs', 'colspan']) || 1;
        const rowspan = +get(cellNode, ['attribs', 'rowspan']) || 1;
        builder.openTableCell({ maxColumnWidth: formatOptions.maxColumnWidth });
        walk(cellNode.children, builder);
        builder.closeTableCell({ colspan: colspan, rowspan: rowspan });
      }

      function walkTable (elem) {
        if (elem.type !== 'tag') { return; }

        const formatHeaderCell = (formatOptions.uppercaseHeaderCells !== false)
          ? (cellNode) => {
            builder.pushWordTransform(str => str.toUpperCase());
            formatCell(cellNode);
            builder.popWordTransform();
          }
          : formatCell;

        switch (elem.name) {
          case 'thead':
          case 'tbody':
          case 'tfoot':
          case 'center':
            elem.children.forEach(walkTable);
            return;

          case 'tr': {
            builder.openTableRow();
            for (const childOfTr of elem.children) {
              if (childOfTr.type !== 'tag') { continue; }
              switch (childOfTr.name) {
                case 'th': {
                  formatHeaderCell(childOfTr);
                  break;
                }
                case 'td': {
                  formatCell(childOfTr);
                  break;
                }
                  // do nothing
              }
            }
            builder.closeTableRow();
            break;
          }
            // do nothing
        }
      }
    }

    var textFormatters = /*#__PURE__*/Object.freeze({
      __proto__: null,
      anchor: formatAnchor,
      blockquote: formatBlockquote,
      dataTable: formatDataTable,
      heading: formatHeading,
      horizontalLine: formatHorizontalLine,
      image: formatImage,
      lineBreak: formatLineBreak,
      orderedList: formatOrderedList,
      paragraph: formatParagraph,
      pre: formatPre,
      table: formatTable,
      unorderedList: formatUnorderedList,
      wbr: formatWbr
    });

    /**
     * Default options.
     *
     * @constant
     * @type { Options }
     * @default
     * @private
     */
    const DEFAULT_OPTIONS = {
      baseElements: {
        selectors: [ 'body' ],
        orderBy: 'selectors', // 'selectors' | 'occurrence'
        returnDomByDefault: true
      },
      decodeEntities: true,
      encodeCharacters: {},
      formatters: {},
      limits: {
        ellipsis: '...',
        maxBaseElements: undefined,
        maxChildNodes: undefined,
        maxDepth: undefined,
        maxInputLength: (1 << 24) // 16_777_216
      },
      longWordSplit: {
        forceWrapOnLimit: false,
        wrapCharacters: []
      },
      preserveNewlines: false,
      selectors: [
        { selector: '*', format: 'inline' },
        {
          selector: 'a',
          format: 'anchor',
          options: {
            baseUrl: null,
            hideLinkHrefIfSameAsText: false,
            ignoreHref: false,
            linkBrackets: ['[', ']'],
            noAnchorUrl: true
          }
        },
        { selector: 'article', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
        { selector: 'aside', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
        {
          selector: 'blockquote',
          format: 'blockquote',
          options: { leadingLineBreaks: 2, trailingLineBreaks: 2, trimEmptyLines: true }
        },
        { selector: 'br', format: 'lineBreak' },
        { selector: 'div', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
        { selector: 'footer', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
        { selector: 'form', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
        { selector: 'h1', format: 'heading', options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
        { selector: 'h2', format: 'heading', options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
        { selector: 'h3', format: 'heading', options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
        { selector: 'h4', format: 'heading', options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
        { selector: 'h5', format: 'heading', options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
        { selector: 'h6', format: 'heading', options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
        { selector: 'header', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
        {
          selector: 'hr',
          format: 'horizontalLine',
          options: { leadingLineBreaks: 2, length: undefined, trailingLineBreaks: 2 }
        },
        {
          selector: 'img',
          format: 'image',
          options: { baseUrl: null, linkBrackets: ['[', ']'] }
        },
        { selector: 'main', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
        { selector: 'nav', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
        {
          selector: 'ol',
          format: 'orderedList',
          options: { leadingLineBreaks: 2, trailingLineBreaks: 2 }
        },
        { selector: 'p', format: 'paragraph', options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },
        { selector: 'pre', format: 'pre', options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },
        { selector: 'section', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
        {
          selector: 'table',
          format: 'table',
          options: {
            colSpacing: 3,
            leadingLineBreaks: 2,
            maxColumnWidth: 60,
            rowSpacing: 0,
            trailingLineBreaks: 2,
            uppercaseHeaderCells: true
          }
        },
        {
          selector: 'ul',
          format: 'unorderedList',
          options: { itemPrefix: ' * ', leadingLineBreaks: 2, trailingLineBreaks: 2 }
        },
        { selector: 'wbr', format: 'wbr' },
      ],
      tables: [], // deprecated
      whitespaceCharacters: ' \t\r\n\f\u200b',
      wordwrap: 80
    };

    const concatMerge = (acc, src, options) => [...acc, ...src];
    const overwriteMerge = (acc, src, options) => [...src];
    const selectorsMerge = (acc, src, options) => (
      (acc.some(s => typeof s === 'object'))
        ? concatMerge(acc, src) // selectors
        : overwriteMerge(acc, src) // baseElements.selectors
    );

    /**
     * Preprocess options, compile selectors into a decision tree,
     * return a function intended for batch processing.
     *
     * @param   { Options } [options = {}]   HtmlToText options.
     * @returns { (html: string, metadata?: any) => string } Pre-configured converter function.
     * @static
     */
    function compile (options = {}) {
      options = merge(
        DEFAULT_OPTIONS,
        options,
        {
          arrayMerge: overwriteMerge,
          customMerge: (key) => ((key === 'selectors') ? selectorsMerge : undefined)
        }
      );
      options.formatters = Object.assign({}, genericFormatters, textFormatters, options.formatters);
      options.selectors = mergeDuplicatesPreferLast(options.selectors, (s => s.selector));

      handleDeprecatedOptions(options);

      return compile$1(options);
    }

    /**
     * Convert given HTML content to plain text string.
     *
     * @param   { string }  html           HTML content to convert.
     * @param   { Options } [options = {}] HtmlToText options.
     * @param   { any }     [metadata]     Optional metadata for HTML document, for use in formatters.
     * @returns { string }                 Plain text string.
     * @static
     *
     * @example
     * const { convert } = require('html-to-text');
     * const text = convert('<h1>Hello World</h1>', {
     *   wordwrap: 130
     * });
     * console.log(text); // HELLO WORLD
     */
    function convert (html, options = {}, metadata = undefined) {
      return compile(options)(html, metadata);
    }

    /**
     * Map previously existing and now deprecated options to the new options layout.
     * This is a subject for cleanup in major releases.
     *
     * @param { Options } options HtmlToText options.
     */
    function handleDeprecatedOptions (options) {
      if (options.tags) {
        const tagDefinitions = Object.entries(options.tags).map(
          ([selector, definition]) => ({ ...definition, selector: selector || '*' })
        );
        options.selectors.push(...tagDefinitions);
        options.selectors = mergeDuplicatesPreferLast(options.selectors, (s => s.selector));
      }

      function set (obj, path, value) {
        const valueKey = path.pop();
        for (const key of path) {
          let nested = obj[key];
          if (!nested) {
            nested = {};
            obj[key] = nested;
          }
          obj = nested;
        }
        obj[valueKey] = value;
      }

      if (options['baseElement']) {
        const baseElement = options['baseElement'];
        set(
          options,
          ['baseElements', 'selectors'],
          (Array.isArray(baseElement) ? baseElement : [baseElement])
        );
      }
      if (options['returnDomByDefault'] !== undefined) {
        set(options, ['baseElements', 'returnDomByDefault'], options['returnDomByDefault']);
      }

      for (const definition of options.selectors) {
        if (definition.format === 'anchor' && get(definition, ['options', 'noLinkBrackets'])) {
          set(definition, ['options', 'linkBrackets'], false);
        }
      }
    }

    function convertHtmlToText(htmlString) {
      const text = convert(htmlString, {
        wordwrap: false,
        ignoreImage: true, // Ignore images
        ignoreHref: false,  // Process links but only keep their content
        preserveNewlines: false, // Preserve newlines for better formatting
        selectors: [
          { selector: '*', format: 'inline' },  // Convert everything to plain text
          { selector: 'a', format: 'inline' },  // Keep the content of links, ignore the href
          { selector: 'img', format: 'skip' },  // Skip all images
          { selector: 'pre', format: 'skip' },  // Skip code blocks
        ],
        baseElements: { selectors: ['body'], returnDomByDefault: false },  // Only process body content
        decodeEntities: true,  // Decode HTML entities
        limits: {
          // maxDepth: 10,  // Limit depth to avoid unnecessary content
          // maxInputLength: 1000000,  // Limit input length for performance
          ellipsis: '',
        }
      });
      return text
        .replace(/(\r?\n|\r){3,}/g, '\n\n')  // Replace 3 or more newlines with 2 newlines
        .replace(/\t{3,}/g, '\t\t')          // Replace 3 or more tabs with 2 tabs
        .replace(/[ ]{3,}/g, '  ')           // Replace 3 or more spaces with 2 spaces
        .replace(/[\s*]{2,}/g, '\n')        // Replace multiple mixed whitespaces and asterisks with a single newline
        .replace(/\*{3,}/g, '**')            // Replace 3 or more asterisks with 2 asterisks
    }
    var processHtml = {
      convertHtmlToText,
    };

    return processHtml;

})();
