import{a as j}from"../chunk-PKPYJS5H.js";import"../chunk-EL7DUS2A.js";import{u as U}from"../chunk-AOCDFDRO.js";import{d as t,e as l,f as y,g as h,i as Q}from"../chunk-Y3AVQXKT.js";Q();var W,B,_,M,A,m,L,b,k,C,T,O,x,v,G,P,R,I,$,o,H,D,w,K,F=class F extends j{constructor(e,r){super();l(this,o);l(this,W);l(this,B,0);l(this,_,!1);l(this,M,!1);l(this,A,!1);l(this,m,new EventTarget);l(this,L);l(this,b,!1);l(this,k);l(this,C);l(this,T);l(this,O);l(this,x);l(this,v);l(this,G);l(this,P,new Map);l(this,R,new Set);l(this,I);l(this,$,[]);y(this,k,e),y(this,L,U()),y(this,I,r?.extensions??{}),y(this,T,new Promise(d=>{t(this,k).addEventListener("message",s=>{if(s.data.type==="here")d();else throw new Error("Invalid message")},{once:!0})})),y(this,O,new Promise(d=>{let s=c=>{c.data.type==="ready"&&(y(this,C,c.data.id),t(this,k).removeEventListener("message",s),d())};t(this,k).addEventListener("message",s)})),y(this,W,h(this,o,H).call(this,r))}static async create(e,r){let d=new F(e,r);return await t(d,W),d}get waitReady(){return new Promise(e=>{t(this,W).then(()=>{t(this,b)?e():e(new Promise(r=>{t(this,m).addEventListener("connected",()=>{r()})}))})})}get debug(){return t(this,B)}get ready(){return t(this,_)}get closed(){return t(this,M)}get isLeader(){return t(this,A)}async close(){var e;t(this,M)||(y(this,M,!0),t(this,x)?.close(),t(this,v)?.close(),(e=t(this,G))==null||e.call(this),t(this,k).terminate())}async[Symbol.asyncDispose](){await this.close()}async execProtocolRaw(e){return await h(this,o,w).call(this,"execProtocolRaw",e)}async execProtocol(e){return await h(this,o,w).call(this,"execProtocol",e)}async syncToFs(){await h(this,o,w).call(this,"syncToFs")}async listen(e,r){return await this.waitReady,t(this,P).has(e)||t(this,P).set(e,new Set),t(this,P).get(e)?.add(r),await this.exec(`LISTEN ${e}`),async()=>{await this.unlisten(e,r)}}async unlisten(e,r){await this.waitReady,r?t(this,P).get(e)?.delete(r):t(this,P).delete(e),t(this,P).get(e)?.size===0&&await this.exec(`UNLISTEN ${e}`)}onNotification(e){return t(this,R).add(e),()=>{t(this,R).delete(e)}}offNotification(e){t(this,R).delete(e)}async dumpDataDir(){return await h(this,o,w).call(this,"dumpDataDir")}onLeaderChange(e){return t(this,m).addEventListener("leader-change",e),()=>{t(this,m).removeEventListener("leader-change",e)}}offLeaderChange(e){t(this,m).removeEventListener("leader-change",e)}async _handleBlob(e){await h(this,o,w).call(this,"_handleBlob",e)}async _getWrittenBlob(){return await h(this,o,w).call(this,"_getWrittenBlob")}async _cleanupBlob(){await h(this,o,w).call(this,"_cleanupBlob")}async _checkReady(){await this.waitReady}async _runExclusiveQuery(e){await h(this,o,w).call(this,"_acquireQueryLock");try{return await e()}finally{await h(this,o,w).call(this,"_releaseQueryLock")}}async _runExclusiveTransaction(e){await h(this,o,w).call(this,"_acquireTransactionLock");try{return await e()}finally{await h(this,o,w).call(this,"_releaseTransactionLock")}}};W=new WeakMap,B=new WeakMap,_=new WeakMap,M=new WeakMap,A=new WeakMap,m=new WeakMap,L=new WeakMap,b=new WeakMap,k=new WeakMap,C=new WeakMap,T=new WeakMap,O=new WeakMap,x=new WeakMap,v=new WeakMap,G=new WeakMap,P=new WeakMap,R=new WeakMap,I=new WeakMap,$=new WeakMap,o=new WeakSet,H=async function(e={}){for(let[i,u]of Object.entries(t(this,I))){if(u instanceof URL)throw new Error("URL extensions are not supported on the client side of a worker");{let a=await u.setup(this,{},!0);if(a.emscriptenOpts&&console.warn(`PGlite extension ${i} returned emscriptenOpts, these are not supported on the client side of a worker`),a.namespaceObj){let E=this;E[i]=a.namespaceObj}a.bundlePath&&console.warn(`PGlite extension ${i} returned bundlePath, this is not supported on the client side of a worker`),a.init&&await a.init(),a.close&&t(this,$).push(a.close)}}await t(this,T);let{extensions:r,...d}=e;t(this,k).postMessage({type:"init",options:d}),await t(this,O);let s=`pglite-tab-close:${t(this,L)}`;y(this,G,await N(s));let c=`pglite-broadcast:${t(this,C)}`;y(this,x,new BroadcastChannel(c));let p=`pglite-tab:${t(this,L)}`;y(this,v,new BroadcastChannel(p)),t(this,x).addEventListener("message",async i=>{i.data.type==="leader-here"?(y(this,b,!1),t(this,m).dispatchEvent(new Event("leader-change")),h(this,o,D).call(this)):i.data.type==="notify"&&h(this,o,K).call(this,i.data.channel,i.data.payload)}),t(this,v).addEventListener("message",async i=>{i.data.type==="connected"&&(y(this,b,!0),t(this,m).dispatchEvent(new Event("connected")),y(this,B,await h(this,o,w).call(this,"getDebugLevel")),y(this,_,!0))}),t(this,k).addEventListener("message",async i=>{i.data.type==="leader-now"&&(y(this,A,!0),t(this,m).dispatchEvent(new Event("leader-change")))}),h(this,o,D).call(this),this._initArrayTypes()},D=async function(){t(this,b)||(t(this,x).postMessage({type:"tab-here",id:t(this,L)}),setTimeout(()=>h(this,o,D).call(this),16))},w=async function(e,...r){let d=U(),s={type:"rpc-call",callId:d,method:e,args:r};return t(this,v).postMessage(s),await new Promise((c,p)=>{let i=E=>{if(E.data.callId!==d)return;a();let f=E.data;if(f.type==="rpc-return")c(f.result);else if(f.type==="rpc-error"){let S=new Error(f.error.message);Object.assign(S,f.error),p(S)}else p(new Error("Invalid message"))},u=()=>{a(),p(new q)},a=()=>{t(this,v).removeEventListener("message",i),t(this,m).removeEventListener("leader-change",u)};t(this,m).addEventListener("leader-change",u),t(this,v).addEventListener("message",i)})},K=function(e,r){let d=t(this,P).get(e);if(d)for(let s of d)queueMicrotask(()=>s(r));for(let s of t(this,R))queueMicrotask(()=>s(e,r))};var z=F;async function te({init:g}){postMessage({type:"here"});let n=await new Promise(u=>{addEventListener("message",a=>{a.data.type==="init"&&u(a.data.options)},{once:!0})}),e=n.id??`${import.meta.url}:${n.dataDir??""}`;postMessage({type:"ready",id:e});let r=`pglite-election-lock:${e}`,d=`pglite-broadcast:${e}`,s=new BroadcastChannel(d),c=new Set;await N(r);let p=g(n);s.onmessage=async u=>{let a=u.data;switch(a.type){case"tab-here":J(a.id,await p,c);break}},s.postMessage({type:"leader-here",id:e}),postMessage({type:"leader-now"}),(await p).onNotification((u,a)=>{s.postMessage({type:"notify",channel:u,payload:a})})}function J(g,n,e){if(e.has(g))return;e.add(g);let r=`pglite-tab:${g}`,d=`pglite-tab-close:${g}`,s=new BroadcastChannel(r);navigator.locks.request(d,()=>new Promise(p=>{s.close(),e.delete(g),p()}));let c=V(g,n);s.addEventListener("message",async p=>{let i=p.data;switch(i.type){case"rpc-call":{await n.waitReady;let{callId:u,method:a,args:E}=i;try{let f=await c[a](...E);s.postMessage({type:"rpc-return",callId:u,result:f})}catch(f){console.error(f),s.postMessage({type:"rpc-error",callId:u,error:{message:f.message}})}break}}}),s.postMessage({type:"connected"})}function V(g,n){let e=null,r=null,d=`pglite-tab-close:${g}`;return N(d).then(()=>{r&&n.exec("ROLLBACK"),e?.(),r?.()}),{async getDebugLevel(){return n.debug},async close(){await n.close()},async execProtocol(s){return(await n.execProtocol(s)).map(([p,i])=>{if(i.byteLength!==i.buffer.byteLength){let u=new ArrayBuffer(i.byteLength),a=new Uint8Array(u);return a.set(i),[p,a]}else return[p,i]})},async execProtocolRaw(s){let c=await n.execProtocolRaw(s);if(c.byteLength!==c.buffer.byteLength){let p=new ArrayBuffer(c.byteLength),i=new Uint8Array(p);return i.set(c),i}else return c},async dumpDataDir(){return await n.dumpDataDir()},async syncToFs(){return await n.syncToFs()},async _handleBlob(s){return await n._handleBlob(s)},async _getWrittenBlob(){return await n._getWrittenBlob()},async _cleanupBlob(){return await n._cleanupBlob()},async _checkReady(){return await n._checkReady()},async _acquireQueryLock(){return new Promise(s=>{n._runExclusiveQuery(()=>new Promise(c=>{e=c,s()}))})},async _releaseQueryLock(){e?.(),e=null},async _acquireTransactionLock(){return new Promise(s=>{n._runExclusiveTransaction(()=>new Promise(c=>{r=c,s()}))})},async _releaseTransactionLock(){r?.(),r=null}}}var q=class extends Error{constructor(){super("Leader changed, pending operation in indeterminate state")}};async function N(g){let n;return await new Promise(e=>{navigator.locks.request(g,()=>new Promise(r=>{n=r,e()}))}),n}export{q as LeaderChangedError,z as PGliteWorker,te as worker};
//# sourceMappingURL=index.js.map