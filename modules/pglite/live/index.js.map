{"version":3,"sources":["../../src/live/index.ts"],"sourcesContent":["import type {\n  Extension,\n  PGliteInterface,\n  Results,\n  Transaction,\n} from '../interface'\nimport type {\n  LiveNamespace,\n  LiveQueryReturn,\n  LiveChangesReturn,\n  Change,\n} from './interface'\nimport { uuid, formatQuery } from '../utils.js'\n\nconst MAX_RETRIES = 5\n\nconst setup = async (pg: PGliteInterface, _emscriptenOpts: any) => {\n  // The notify triggers are only ever added and never removed\n  // Keep track of which triggers have been added to avoid adding them multiple times\n  const tableNotifyTriggersAdded = new Set<string>()\n\n  const namespaceObj: LiveNamespace = {\n    async query<T>(\n      query: string,\n      params: any[] | undefined | null,\n      callback: (results: Results<T>) => void,\n    ) {\n      const id = uuid().replace(/-/g, '')\n\n      let results: Results<T>\n      let tables: { table_name: string; schema_name: string }[]\n\n      const init = async () => {\n        await pg.transaction(async (tx) => {\n          // Create a temporary view with the query\n          const formattedQuery = await formatQuery(pg, query, params, tx)\n          await tx.query(\n            `CREATE OR REPLACE TEMP VIEW live_query_${id}_view AS ${formattedQuery}`,\n          )\n\n          // Get the tables used in the view and add triggers to notify when they change\n          tables = await getTablesForView(tx, `live_query_${id}_view`)\n          await addNotifyTriggersToTables(tx, tables, tableNotifyTriggersAdded)\n\n          // Create prepared statement to get the results\n          await tx.exec(`\n            PREPARE live_query_${id}_get AS\n            SELECT * FROM live_query_${id}_view;\n          `)\n\n          // Get the initial results\n          results = await tx.query<T>(`EXECUTE live_query_${id}_get;`)\n        })\n      }\n      await init()\n\n      // Function to refresh the query\n      const refresh = async (count = 0) => {\n        try {\n          results = await pg.query<T>(`EXECUTE live_query_${id}_get;`)\n        } catch (e) {\n          const msg = (e as Error).message\n          if (\n            msg === `prepared statement \"live_query_${id}_get\" does not exist`\n          ) {\n            // If the prepared statement does not exist, reset and try again\n            // This can happen if using the multi-tab worker\n            if (count > MAX_RETRIES) {\n              throw e\n            }\n            await init()\n            refresh(count + 1)\n          } else {\n            throw e\n          }\n        }\n        callback(results)\n      }\n\n      // Setup the listeners\n      const unsubList: Array<() => Promise<void>> = await Promise.all(\n        tables!.map((table) =>\n          pg.listen(\n            `table_change__${table.schema_name}__${table.table_name}`,\n            async () => {\n              refresh()\n            },\n          ),\n        ),\n      )\n\n      // Function to unsubscribe from the query\n      const unsubscribe = async () => {\n        await Promise.all(unsubList.map((unsub) => unsub()))\n        await pg.exec(`\n            DROP VIEW IF EXISTS live_query_${id}_view;\n            DEALLOCATE live_query_${id}_get;\n          `)\n      }\n\n      // Run the callback with the initial results\n      callback(results!)\n\n      // Return the initial results\n      return {\n        initialResults: results!,\n        unsubscribe,\n        refresh,\n      } satisfies LiveQueryReturn<T>\n    },\n\n    async changes<T>(\n      query: string,\n      params: any[] | undefined | null,\n      key: string,\n      callback: (changes: Array<Change<T>>) => void,\n    ) {\n      const id = uuid().replace(/-/g, '')\n\n      let tables: { table_name: string; schema_name: string }[]\n      let stateSwitch: 1 | 2 = 1\n      let changes: Results<Change<T>>\n\n      const init = async () => {\n        await pg.transaction(async (tx) => {\n          // Create a temporary view with the query\n          const formattedQuery = await formatQuery(pg, query, params, tx)\n          await tx.query(\n            `CREATE OR REPLACE TEMP VIEW live_query_${id}_view AS ${formattedQuery}`,\n          )\n\n          // Get the tables used in the view and add triggers to notify when they change\n          tables = await getTablesForView(tx, `live_query_${id}_view`)\n          await addNotifyTriggersToTables(tx, tables, tableNotifyTriggersAdded)\n\n          // Get the columns of the view\n          const columns = [\n            ...(\n              await tx.query<any>(`\n                SELECT column_name, data_type, udt_name\n                FROM information_schema.columns \n                WHERE table_name = 'live_query_${id}_view'\n              `)\n            ).rows,\n            { column_name: '__after__', data_type: 'integer' },\n          ]\n\n          // Init state tables as empty temp table\n          await tx.exec(`\n            CREATE TEMP TABLE live_query_${id}_state1 (LIKE live_query_${id}_view INCLUDING ALL);\n            CREATE TEMP TABLE live_query_${id}_state2 (LIKE live_query_${id}_view INCLUDING ALL);\n          `)\n\n          // Create Diff views and prepared statements\n          for (const curr of [1, 2]) {\n            const prev = curr === 1 ? 2 : 1\n            await tx.exec(`\n              PREPARE live_query_${id}_diff${curr} AS\n              WITH\n                prev AS (SELECT LAG(\"${key}\") OVER () as __after__, * FROM live_query_${id}_state${prev}),\n                curr AS (SELECT LAG(\"${key}\") OVER () as __after__, * FROM live_query_${id}_state${curr}),\n                data_diff AS (\n                  -- INSERT operations: Include all columns\n                  SELECT \n                    'INSERT' AS __op__,\n                    ${columns\n                      .map(\n                        ({ column_name }) =>\n                          `curr.\"${column_name}\" AS \"${column_name}\"`,\n                      )\n                      .join(',\\n')},\n                    ARRAY[]::text[] AS __changed_columns__\n                  FROM curr\n                  LEFT JOIN prev ON curr.${key} = prev.${key}\n                  WHERE prev.${key} IS NULL\n                UNION ALL\n                  -- DELETE operations: Include only the primary key\n                  SELECT \n                    'DELETE' AS __op__,\n                    ${columns\n                      .map(({ column_name, data_type, udt_name }) => {\n                        if (column_name === key) {\n                          return `prev.\"${column_name}\" AS \"${column_name}\"`\n                        } else {\n                          return `NULL${data_type === 'USER-DEFINED' ? `::${udt_name}` : ``} AS \"${column_name}\"`\n                        }\n                      })\n                      .join(',\\n')},\n                      ARRAY[]::text[] AS __changed_columns__\n                  FROM prev\n                  LEFT JOIN curr ON prev.${key} = curr.${key}\n                  WHERE curr.${key} IS NULL\n                UNION ALL\n                  -- UPDATE operations: Include only changed columns\n                  SELECT \n                    'UPDATE' AS __op__,\n                    ${columns\n                      .map(({ column_name, data_type, udt_name }) =>\n                        column_name === key\n                          ? `curr.\"${column_name}\" AS \"${column_name}\"`\n                          : `CASE \n                              WHEN curr.\"${column_name}\" IS DISTINCT FROM prev.\"${column_name}\" \n                              THEN curr.\"${column_name}\"\n                              ELSE NULL${data_type === 'USER-DEFINED' ? `::${udt_name}` : ``}\n                              END AS \"${column_name}\"`,\n                      )\n                      .join(',\\n')},\n                      ARRAY(SELECT unnest FROM unnest(ARRAY[${columns\n                        .filter(({ column_name }) => column_name !== key)\n                        .map(\n                          ({ column_name }) =>\n                            `CASE\n                              WHEN curr.\"${column_name}\" IS DISTINCT FROM prev.\"${column_name}\" \n                              THEN '${column_name}' \n                              ELSE NULL \n                              END`,\n                        )\n                        .join(\n                          ', ',\n                        )}]) WHERE unnest IS NOT NULL) AS __changed_columns__\n                  FROM curr\n                  INNER JOIN prev ON curr.${key} = prev.${key}\n                  WHERE NOT (curr IS NOT DISTINCT FROM prev)\n                )\n              SELECT * FROM data_diff;\n            `)\n          }\n        })\n      }\n\n      await init()\n\n      const refresh = async () => {\n        let reset = false\n        for (let i = 0; i < 5; i++) {\n          try {\n            await pg.transaction(async (tx) => {\n              // Populate the state table\n              await tx.exec(`\n                DELETE FROM live_query_${id}_state${stateSwitch};\n                INSERT INTO live_query_${id}_state${stateSwitch} \n                  SELECT * FROM live_query_${id}_view;\n              `)\n\n              // Get the changes\n              changes = await tx.query<any>(\n                `EXECUTE live_query_${id}_diff${stateSwitch};`,\n              )\n            })\n            break\n          } catch (e) {\n            const msg = (e as Error).message\n            if (\n              msg ===\n              `relation \"live_query_${id}_state${stateSwitch}\" does not exist`\n            ) {\n              // If the state table does not exist, reset and try again\n              // This can happen if using the multi-tab worker\n              reset = true\n              await init()\n              continue\n            } else {\n              throw e\n            }\n          }\n        }\n\n        // Switch state\n        stateSwitch = stateSwitch === 1 ? 2 : 1\n\n        callback([\n          ...(reset\n            ? [\n                {\n                  __op__: 'RESET' as const,\n                },\n              ]\n            : []),\n          ...changes!.rows,\n        ])\n      }\n\n      // Setup the listeners\n      const unsubList: Array<() => Promise<void>> = await Promise.all(\n        tables!.map((table) =>\n          pg.listen(\n            `table_change__${table.schema_name}__${table.table_name}`,\n            async () => refresh(),\n          ),\n        ),\n      )\n\n      // Function to unsubscribe from the query\n      const unsubscribe = async () => {\n        await Promise.all(unsubList.map((unsub) => unsub()))\n        await pg.exec(`\n          DROP VIEW IF EXISTS live_query_${id}_view;\n          DROP TABLE IF EXISTS live_query_${id}_state1;\n          DROP TABLE IF EXISTS live_query_${id}_state2;\n          DEALLOCATE live_query_${id}_diff1;\n          DEALLOCATE live_query_${id}_diff2;\n        `)\n      }\n\n      // Run the callback with the initial changes\n      await refresh()\n\n      // Fields\n      const fields = changes!.fields.filter(\n        (field) =>\n          !['__after__', '__op__', '__changed_columns__'].includes(field.name),\n      )\n\n      // Return the initial results\n      return {\n        fields,\n        initialChanges: changes!.rows,\n        unsubscribe,\n        refresh,\n      } satisfies LiveChangesReturn<T>\n    },\n\n    async incrementalQuery<T>(\n      query: string,\n      params: any[] | undefined | null,\n      key: string,\n      callback: (results: Results<T>) => void,\n    ) {\n      const rowsMap: Map<any, any> = new Map()\n      const afterMap: Map<any, any> = new Map()\n      let lastRows: T[] = []\n      let firstRun = true\n\n      const { fields, unsubscribe, refresh } = await namespaceObj.changes<T>(\n        query,\n        params,\n        key,\n        (changes) => {\n          // Process the changes\n          for (const change of changes) {\n            const {\n              __op__: op,\n              __changed_columns__: changedColumns,\n              ...obj\n            } = change as typeof change & { [key: string]: any }\n            switch (op) {\n              case 'RESET':\n                rowsMap.clear()\n                afterMap.clear()\n                break\n              case 'INSERT':\n                rowsMap.set(obj[key], obj)\n                afterMap.set(obj.__after__, obj[key])\n                break\n              case 'DELETE': {\n                const oldObj = rowsMap.get(obj[key])\n                rowsMap.delete(obj[key])\n                afterMap.delete(oldObj.__after__)\n                break\n              }\n              case 'UPDATE': {\n                const newObj = { ...(rowsMap.get(obj[key]) ?? {}) }\n                for (const columnName of changedColumns) {\n                  newObj[columnName] = obj[columnName]\n                  if (columnName === '__after__') {\n                    afterMap.set(obj.__after__, obj[key])\n                  }\n                }\n                rowsMap.set(obj[key], newObj)\n                break\n              }\n            }\n          }\n\n          // Get the rows in order\n          const rows: T[] = []\n          let lastKey: any = null\n          for (let i = 0; i < rowsMap.size; i++) {\n            const nextKey = afterMap.get(lastKey)\n            const obj = rowsMap.get(nextKey)\n            if (!obj) {\n              break\n            }\n            // Remove the __after__ key from the exposed row\n            const cleanObj = { ...obj }\n            delete cleanObj.__after__\n            rows.push(cleanObj)\n            lastKey = nextKey\n          }\n          lastRows = rows\n\n          // Run the callback\n          if (!firstRun) {\n            callback({\n              rows,\n              fields,\n            })\n          }\n        },\n      )\n\n      firstRun = false\n      callback({\n        rows: lastRows,\n        fields,\n      })\n\n      return {\n        initialResults: {\n          rows: lastRows,\n          fields,\n        },\n        unsubscribe,\n        refresh,\n      } satisfies LiveQueryReturn<T>\n    },\n  }\n\n  return {\n    namespaceObj,\n  }\n}\n\nexport const live = {\n  name: 'Live Queries',\n  setup,\n} satisfies Extension\n\nexport type PGliteWithLive = PGliteInterface & {\n  live: LiveNamespace\n}\n\n/**\n * Get a list of all the tables used in a view\n * @param tx a transaction or or PGlite instance\n * @param viewName the name of the view\n * @returns list of tables used in the view\n */\nasync function getTablesForView(\n  tx: Transaction | PGliteInterface,\n  viewName: string,\n): Promise<{ table_name: string; schema_name: string }[]> {\n  return (\n    await tx.query<{\n      table_name: string\n      schema_name: string\n    }>(\n      `\n        SELECT DISTINCT\n          cl.relname AS table_name,\n          n.nspname AS schema_name\n        FROM pg_rewrite r\n        JOIN pg_depend d ON r.oid = d.objid\n        JOIN pg_class cl ON d.refobjid = cl.oid\n        JOIN pg_namespace n ON cl.relnamespace = n.oid\n        WHERE\n        r.ev_class = (\n            SELECT oid FROM pg_class WHERE relname = $1 AND relkind = 'v'\n        )\n        AND d.deptype = 'n';\n      `,\n      [viewName],\n    )\n  ).rows.filter((row) => row.table_name !== viewName)\n}\n\n/**\n * Add triggers to tables to notify when they change\n * @param tx a transaction or PGlite instance\n * @param tables list of tables to add triggers to\n */\nasync function addNotifyTriggersToTables(\n  tx: Transaction | PGliteInterface,\n  tables: { table_name: string; schema_name: string }[],\n  tableNotifyTriggersAdded: Set<string>,\n) {\n  const triggers = tables\n    .filter(\n      (table) =>\n        !tableNotifyTriggersAdded.has(\n          `${table.schema_name}_${table.table_name}`,\n        ),\n    )\n    .map((table) => {\n      return `\n      CREATE OR REPLACE FUNCTION \"_notify_${table.schema_name}_${table.table_name}\"() RETURNS TRIGGER AS $$\n      BEGIN\n        PERFORM pg_notify('table_change__${table.schema_name}__${table.table_name}', '');\n        RETURN NULL;\n      END;\n      $$ LANGUAGE plpgsql;\n      CREATE OR REPLACE TRIGGER \"_notify_trigger_${table.schema_name}_${table.table_name}\"\n      AFTER INSERT OR UPDATE OR DELETE ON \"${table.schema_name}\".\"${table.table_name}\"\n      FOR EACH STATEMENT EXECUTE FUNCTION \"_notify_${table.schema_name}_${table.table_name}\"();\n      `\n    })\n    .join('\\n')\n  if (triggers.trim() !== '') {\n    await tx.exec(triggers)\n  }\n  tables.map((table) =>\n    tableNotifyTriggersAdded.add(`${table.schema_name}_${table.table_name}`),\n  )\n}\n"],"mappings":"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","names":["init_esm_shims","MAX_RETRIES","setup","pg","_emscriptenOpts","tableNotifyTriggersAdded","namespaceObj","query","params","callback","id","uuid","results","tables","init","tx","formattedQuery","formatQuery","getTablesForView","addNotifyTriggersToTables","refresh","count","e","unsubList","table","unsubscribe","unsub","key","stateSwitch","changes","columns","curr","prev","column_name","data_type","udt_name","reset","i","field","rowsMap","afterMap","lastRows","firstRun","fields","change","op","changedColumns","obj","oldObj","newObj","columnName","rows","lastKey","nextKey","cleanObj","live","viewName","row","triggers"]}