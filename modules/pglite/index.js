import{b as xe,d as ee,e as be,f as ve,g as V,h as $,i as te,j as ie}from"./chunk-SJVDOE3S.js";import{a as fe}from"./chunk-PKPYJS5H.js";import"./chunk-EL7DUS2A.js";import{a as se,b as re,c as ne,d as oe,e as ae,f as Ee,g as K,h as Pe,m as _e,p as Te,q as le,r as ce,s as de,t as ue,u as Fe,v as Oe}from"./chunk-AOCDFDRO.js";import{c as ge,d as r,e as f,f as h,g as D,i as y}from"./chunk-Y3AVQXKT.js";y();y();y();var Ie=new Error("timeout while waiting for mutex to become available"),ke=new Error("mutex already locked"),Se=new Error("request for lock canceled"),De=function(d,t,e,i){function l(n){return n instanceof e?n:new e(function(a){a(n)})}return new(e||(e=Promise))(function(n,a){function p(s){try{u(i.next(s))}catch(c){a(c)}}function o(s){try{u(i.throw(s))}catch(c){a(c)}}function u(s){s.done?n(s.value):l(s.value).then(p,o)}u((i=i.apply(d,t||[])).next())})},X=class{constructor(t,e=Se){this._value=t,this._cancelError=e,this._weightedQueues=[],this._weightedWaiters=[]}acquire(t=1){if(t<=0)throw new Error(`invalid weight ${t}: must be positive`);return new Promise((e,i)=>{this._weightedQueues[t-1]||(this._weightedQueues[t-1]=[]),this._weightedQueues[t-1].push({resolve:e,reject:i}),this._dispatch()})}runExclusive(t,e=1){return De(this,void 0,void 0,function*(){let[i,l]=yield this.acquire(e);try{return yield t(i)}finally{l()}})}waitForUnlock(t=1){if(t<=0)throw new Error(`invalid weight ${t}: must be positive`);return new Promise(e=>{this._weightedWaiters[t-1]||(this._weightedWaiters[t-1]=[]),this._weightedWaiters[t-1].push(e),this._dispatch()})}isLocked(){return this._value<=0}getValue(){return this._value}setValue(t){this._value=t,this._dispatch()}release(t=1){if(t<=0)throw new Error(`invalid weight ${t}: must be positive`);this._value+=t,this._dispatch()}cancel(){this._weightedQueues.forEach(t=>t.forEach(e=>e.reject(this._cancelError))),this._weightedQueues=[]}_dispatch(){var t;for(let e=this._value;e>0;e--){let i=(t=this._weightedQueues[e-1])===null||t===void 0?void 0:t.shift();if(!i)continue;let l=this._value,n=e;this._value-=e,e=this._value+1,i.resolve([l,this._newReleaser(n)])}this._drainUnlockWaiters()}_newReleaser(t){let e=!1;return()=>{e||(e=!0,this.release(t))}}_drainUnlockWaiters(){for(let t=this._value;t>0;t--)this._weightedWaiters[t-1]&&(this._weightedWaiters[t-1].forEach(e=>e()),this._weightedWaiters[t-1]=[])}},Ae=function(d,t,e,i){function l(n){return n instanceof e?n:new e(function(a){a(n)})}return new(e||(e=Promise))(function(n,a){function p(s){try{u(i.next(s))}catch(c){a(c)}}function o(s){try{u(i.throw(s))}catch(c){a(c)}}function u(s){s.done?n(s.value):l(s.value).then(p,o)}u((i=i.apply(d,t||[])).next())})},_=class{constructor(t){this._semaphore=new X(1,t)}acquire(){return Ae(this,void 0,void 0,function*(){let[,t]=yield this._semaphore.acquire();return t})}runExclusive(t){return this._semaphore.runExclusive(()=>t())}isLocked(){return this._semaphore.isLocked()}waitForUnlock(){return this._semaphore.waitForUnlock()}release(){this._semaphore.isLocked()&&this._semaphore.release()}cancel(){return this._semaphore.cancel()}};y();import Me from"./postgres.js";var pe=Me;y();var he=ge(xe(),1);async function Y(d){if(le){let t=await import("fs"),e=await import("zlib"),{Writable:i}=await import("stream"),{pipeline:l}=await import("stream/promises");if(!t.existsSync(d))throw new Error(`Extension bundle not found: ${d}`);let n=e.createGunzip(),a=[];return await l(t.createReadStream(d),n,new i({write(p,o,u){a.push(p),u()}})),new Blob(a)}else{let t=await fetch(d.toString());if(!t.ok||!t.body)return null;if(t.headers.get("Content-Encoding")==="gzip")return t.blob();{let e=new DecompressionStream("gzip");return new Response(t.body.pipeThrough(e)).blob()}}}async function me(d,t){for(let e in d.pg_extensions){let i;try{i=await d.pg_extensions[e]}catch(l){console.error("Failed to fetch extension:",e,l);continue}if(i){let l=new Uint8Array(await i.arrayBuffer());Re(d,e,l,t)}else console.error("Could not get binary data for extension:",e)}}function Re(d,t,e,i){he.default.untar(e).forEach(n=>{if(!n.name.startsWith(".")){let a=d.WASM_PREFIX+"/"+n.name;if(n.name.endsWith(".so")){let p=(...u)=>{i("pgfs:ext OK",a,u)},o=(...u)=>{i("pgfs:ext FAIL",a,u)};d.FS.createPreloadedFile(Be(a),n.name.split("/").pop().slice(0,-3),n.data,!0,!0,p,o,!1)}else d.FS.writeFile(a,n.data)}})}function Be(d){let t=d.lastIndexOf("/");return t>0?d.slice(0,t):d}var A,T,F,M,R,C,Q,z,B,L,q,G,O,v,w,S,b,we,N,H=class H extends fe{constructor(e={},i={}){super();f(this,b);f(this,A,!1);f(this,T,!1);f(this,F,!1);f(this,M,!1);f(this,R,!1);f(this,C,new _);f(this,Q,new _);f(this,z,new _);f(this,B,!1);this.debug=0;f(this,L);f(this,q,[]);f(this,G,new K);f(this,O);f(this,v);f(this,w,new Map);f(this,S,new Set);typeof e=="string"?i={dataDir:e,...i}:i=e,this.dataDir=i.dataDir,i?.debug!==void 0&&(this.debug=i.debug),i?.relaxedDurability!==void 0&&h(this,R,i.relaxedDurability),h(this,L,i.extensions??{}),this.waitReady=D(this,b,we).call(this,i??{})}static async create(e,i){let l=typeof e=="string"?{dataDir:e,...i??{}}:e??{},n=new H(l);return await n.waitReady,n}get Module(){return this.mod}get ready(){return r(this,A)&&!r(this,T)&&!r(this,F)}get closed(){return r(this,F)}async close(){await this._checkReady(),h(this,T,!0);for(let e of r(this,q))await e();try{await this.execProtocol(se.end()),this.mod._pg_shutdown()}catch(e){let i=e;if(!(i.name==="ExitStatus"&&i.status===0))throw e}await this.fs.close(this.mod.FS),h(this,F,!0),h(this,T,!1)}async[Symbol.asyncDispose](){await this.close()}async _handleBlob(e){h(this,O,e?await e.arrayBuffer():void 0)}async _cleanupBlob(){h(this,O,void 0)}async _getWrittenBlob(){if(!r(this,v))return;let e=new Blob(r(this,v));return h(this,v,void 0),e}async _checkReady(){if(r(this,T))throw new Error("PGlite is closing");if(r(this,F))throw new Error("PGlite is closed");r(this,A)||await this.waitReady}async execProtocolRaw(e,{syncToFs:i=!0}={}){let l=e.length,n=this.mod;n._interactive_write(l),n.HEAPU8.set(e,1),n._interactive_one();let a=l+2,p=a+n._interactive_read(),o=n.HEAPU8.subarray(a,p);return i&&await this.syncToFs(),o}async execProtocol(e,{syncToFs:i=!0,throwOnError:l=!0,onNotice:n}={}){let a=await this.execProtocolRaw(e,{syncToFs:i}),p=[];return r(this,G).parse(a,o=>{if(o instanceof re){if(h(this,G,new K),l)throw o}else if(o instanceof ae)this.debug>0&&console.warn(o),n&&n(o);else if(o instanceof oe)switch(o.text){case"BEGIN":h(this,M,!0);break;case"COMMIT":case"ROLLBACK":h(this,M,!1);break}else if(o instanceof ne){let u=r(this,w).get(o.channel);u&&u.forEach(s=>{queueMicrotask(()=>s(o.payload))}),r(this,S).forEach(s=>{queueMicrotask(()=>s(o.channel,o.payload))})}p.push([o,a])}),p}isInTransaction(){return r(this,M)}async syncToFs(){if(r(this,B))return;h(this,B,!0);let e=async()=>{await r(this,z).runExclusive(async()=>{h(this,B,!1),await this.fs.syncToFs(this.mod.FS,r(this,R))})};r(this,R)?e():await e()}async listen(e,i){return r(this,w).has(e)||r(this,w).set(e,new Set),r(this,w).get(e).add(i),await this.exec(`LISTEN "${e}"`),async()=>{await this.unlisten(e,i)}}async unlisten(e,i){i?(r(this,w).get(e)?.delete(i),r(this,w).get(e)?.size===0&&(await this.exec(`UNLISTEN "${e}"`),r(this,w).delete(e))):(await this.exec(`UNLISTEN "${e}"`),r(this,w).delete(e))}onNotification(e){return r(this,S).add(e),()=>{r(this,S).delete(e)}}offNotification(e){r(this,S).delete(e)}async dumpDataDir(e){let i=this.dataDir?.split("/").pop()??"pgdata";return this.fs.dumpTar(this.mod.FS,i,e)}_runExclusiveQuery(e){return r(this,C).runExclusive(e)}_runExclusiveTransaction(e){return r(this,Q).runExclusive(e)}};A=new WeakMap,T=new WeakMap,F=new WeakMap,M=new WeakMap,R=new WeakMap,C=new WeakMap,Q=new WeakMap,z=new WeakMap,B=new WeakMap,L=new WeakMap,q=new WeakMap,G=new WeakMap,O=new WeakMap,v=new WeakMap,w=new WeakMap,S=new WeakMap,b=new WeakSet,we=async function(e){if(e.fs)this.fs=e.fs;else{let{dataDir:s,fsType:c}=te(e.dataDir);this.fs=await ie(s,c)}let i={},l=[],n=[`PGDATA=${$}`,`PREFIX=${V}`,`PGUSER=${e.username??"postgres"}`,`PGDATABASE=${e.database??"template1"}`,"MODE=REACT","REPL=N",...this.debug?["-d",this.debug.toString()]:[]];e.wasmModule||ce();let a=e.fsBundle?e.fsBundle.arrayBuffer():ue(),p;a.then(s=>{p=s});let o={WASM_PREFIX:V,arguments:n,INITIAL_MEMORY:e.initialMemory,noExitRuntime:!0,...this.debug>0?{print:console.info,printErr:console.error}:{print:()=>{},printErr:()=>{}},instantiateWasm:(s,c)=>(de(s,e.wasmModule).then(({instance:m,module:g})=>{c(m,g)}),{}),getPreloadedPackage:(s,c)=>{if(s==="postgres.data"){if(p.byteLength!==c)throw new Error(`Invalid FS bundle size: ${p.byteLength} !== ${c}`);return p}throw new Error(`Unknown package: ${s}`)},preRun:[s=>{let c=s.FS.makedev(64,0),m={open:g=>{},close:g=>{},read:(g,I,E,P,x)=>{let J=r(this,O);if(!J)throw new Error("No /dev/blob File or Blob provided to read from");let j=new Uint8Array(J);if(x>=j.length)return 0;let Z=Math.min(j.length-x,P);for(let W=0;W<Z;W++)I[E+W]=j[x+W];return Z},write:(g,I,E,P,x)=>(r(this,v)??h(this,v,[]),r(this,v).push(I.slice(E,E+P)),P),llseek:(g,I,E)=>{let P=r(this,O);if(!P)throw new Error("No /dev/blob File or Blob provided to llseek");let x=I;if(E===1?x+=g.position:E===2&&(x=new Uint8Array(P).length),x<0)throw new s.FS.ErrnoError(28);return x}};s.FS.registerDevice(c,m),s.FS.mkdev("/dev/blob",c)}]};o=await this.fs.emscriptenOpts(o);for(let[s,c]of Object.entries(r(this,L)))if(c instanceof URL)i[s]=Y(c);else{let m=await c.setup(this,o);if(m.emscriptenOpts&&(o=m.emscriptenOpts),m.namespaceObj){let g=this;g[s]=m.namespaceObj}m.bundlePath&&(i[s]=Y(m.bundlePath)),m.init&&l.push(m.init),m.close&&r(this,q).push(m.close)}if(o.pg_extensions=i,await a,this.mod=await pe(o),await this.fs.initialSyncFs(this.mod.FS),e.loadDataDir){if(this.mod.FS.analyzePath($+"/PG_VERSION").exists)throw new Error("Database already exists, cannot load from tarball");D(this,b,N).call(this,"pglite: loading data from tarball"),await ee(this.mod.FS,e.loadDataDir)}this.mod.FS.analyzePath($+"/PG_VERSION").exists?D(this,b,N).call(this,"pglite: found DB, resuming"):D(this,b,N).call(this,"pglite: no db"),await me(this.mod,(...s)=>D(this,b,N).call(this,...s));let u=this.mod._pg_initdb();if(!u)throw new Error("INITDB failed to return value");if(u&1)throw new Error("INITDB failed");if(u&2){let s=e.username??"postgres",c=e.database??"template1";if(u&4){if(!(u&12))throw new Error("Invalid db/user combination")}else if(c!=="template1"&&s!=="postgres")throw new Error("INITDB created a new datadir, but an alternative db/user was requested")}await this.syncToFs(),h(this,A,!0),await this.exec("SET search_path TO public;"),await this._initArrayTypes();for(let s of l)await s()},N=function(...e){this.debug>0&&console.log(...e)};var ye=H;y();export{be as IdbFs,ve as MemoryFS,_ as Mutex,ye as PGlite,Oe as formatQuery,Ee as messages,Te as parse,Pe as protocol,_e as types,Fe as uuid};
//# sourceMappingURL=index.js.map