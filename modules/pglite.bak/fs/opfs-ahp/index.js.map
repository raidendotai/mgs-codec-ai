{"version":3,"sources":["../../../src/fs/opfs-ahp/index.ts","../../../src/fs/opfs-ahp/emscriptenFs.ts","../../../src/fs/opfs-ahp/types.ts","../../../src/fs/opfs-ahp/opfsAhp.ts"],"sourcesContent":["import { FilesystemBase } from '../types.js'\nimport { PGDATA } from '../index.js'\nimport type { PostgresMod, FS } from '../../postgresMod.js'\nimport { createOPFSAHP } from './emscriptenFs.js'\nimport { OpfsAhp } from './opfsAhp.js'\nimport { dumpTar, type DumpTarCompressionOptions } from '../tarUtils.js'\n\nexport interface OpfsAhpFSOptions {\n  initialPoolSize?: number\n  maintainedPoolSize?: number\n}\n\n/**\n * PGlite OPFS access handle pool filesystem.\n * Opens a pool of sync access handles and then allocates them as needed.\n */\nexport class OpfsAhpFS extends FilesystemBase {\n  #initialPoolSize: number\n  #maintainedPoolSize: number\n  opfsAhp?: OpfsAhp\n\n  constructor(\n    dataDir: string,\n    { initialPoolSize, maintainedPoolSize }: OpfsAhpFSOptions = {},\n  ) {\n    super(dataDir)\n    this.#initialPoolSize = initialPoolSize ?? 1000\n    this.#maintainedPoolSize = maintainedPoolSize ?? 100\n  }\n\n  async emscriptenOpts(opts: Partial<PostgresMod>) {\n    this.opfsAhp = await OpfsAhp.create({\n      root: this.dataDir!,\n      initialPoolSize: this.#initialPoolSize,\n      maintainedPoolSize: this.#maintainedPoolSize,\n    })\n    const options: Partial<PostgresMod> = {\n      ...opts,\n      preRun: [\n        ...(opts.preRun || []),\n        (mod: PostgresMod) => {\n          const OPFS = createOPFSAHP(mod, this.opfsAhp!)\n          mod.FS.mkdir(PGDATA)\n          mod.FS.mount(OPFS, {}, PGDATA)\n        },\n      ],\n    }\n    return options\n  }\n\n  async syncToFs(_fs: FS, relaxedDurability = false) {\n    await this.opfsAhp?.maybeCheckpointState()\n    await this.opfsAhp?.maintainPool()\n    // console.log(\"syncToFs\", relaxedDurability);\n    if (!relaxedDurability) {\n      this.opfsAhp?.flush()\n    }\n  }\n\n  async dumpTar(\n    mod: FS,\n    dbname: string,\n    compression?: DumpTarCompressionOptions,\n  ) {\n    return dumpTar(mod, dbname, compression)\n  }\n\n  async close(FS: FS): Promise<void> {\n    this.opfsAhp?.exit()\n    FS.quit()\n  }\n}\n","import type { PostgresMod } from '../../postgresMod.js'\nimport type { OpfsAhp } from './opfsAhp.js'\nimport { ERRNO_CODES } from './types.js'\n\nexport type FileSystemType = Emscripten.FileSystemType & {\n  createNode: (\n    parent: FSNode | null,\n    name: string,\n    mode: number,\n    dev?: any,\n  ) => FSNode\n  node_ops: FS.NodeOps\n  stream_ops: FS.StreamOps & {\n    dup: (stream: FSStream) => void\n    mmap: (\n      stream: FSStream,\n      length: number,\n      position: number,\n      prot: any,\n      flags: any,\n    ) => { ptr: number; allocated: boolean }\n    msync: (\n      stream: FSStream,\n      buffer: Uint8Array,\n      offset: number,\n      length: number,\n      mmapFlags: any,\n    ) => number\n  }\n} & { [key: string]: any }\n\ntype FSNode = FS.FSNode & {\n  node_ops: FS.NodeOps\n  stream_ops: FS.StreamOps\n}\n\ntype FSStream = FS.FSStream & {\n  node: FSNode\n  shared: {\n    refcount: number\n  }\n}\n\nexport interface OpfsMount extends FS.Mount {\n  opts: {\n    root: string\n  }\n}\n\ntype OpfsNode = FSNode\n\ntype EmscriptenFS = PostgresMod['FS'] & {\n  createNode: (\n    parent: FSNode | null,\n    name: string,\n    mode: number,\n    dev?: any,\n  ) => FSNode\n}\n\n/**\n * Create an emscripten filesystem that uses the AHP filesystem.\n * @param Module The emscripten module\n * @param opfsAhp The AHP filesystem - see `OpfsAhp.ts`\n * @returns The emscripten filesystem\n */\nexport const createOPFSAHP = (Module: PostgresMod, opfsAhp: OpfsAhp) => {\n  const FS = Module.FS as EmscriptenFS\n  const OPFS = {\n    tryFSOperation<T>(f: () => T): T {\n      try {\n        return f()\n      } catch (e: any) {\n        if (!e.code) throw e\n        if (e.code === 'UNKNOWN') throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\n        throw new FS.ErrnoError(e.code)\n      }\n    },\n    mount(_mount: OpfsMount): FSNode {\n      return OPFS.createNode(null, '/', 16384 | 511, 0)\n    },\n    syncfs(\n      _mount: FS.Mount,\n      _populate: any, // This has the wrong type in @types/emscripten\n      _done: (err?: number | null) => unknown,\n    ): void {\n      // noop\n    },\n    createNode(\n      parent: FSNode | null,\n      name: string,\n      mode: number,\n      _dev?: any,\n    ): OpfsNode {\n      if (!FS.isDir(mode) && !FS.isFile(mode)) {\n        throw new FS.ErrnoError(28)\n      }\n      const node = FS.createNode(parent, name, mode)\n      node.node_ops = OPFS.node_ops\n      node.stream_ops = OPFS.stream_ops\n      return node\n    },\n    getMode: function (path: string): number {\n      log('getMode', path)\n      return OPFS.tryFSOperation(() => {\n        const stats = opfsAhp.lstat(path)\n        return stats.mode\n      })\n    },\n    realPath: function (node: FSNode): string {\n      const parts: string[] = []\n      while (node.parent !== node) {\n        parts.push(node.name)\n        node = node.parent as FSNode\n      }\n      parts.push((node.mount as OpfsMount).opts.root)\n      parts.reverse()\n      return parts.join('/')\n    },\n    node_ops: {\n      getattr(node: OpfsNode): FS.Stats {\n        log('getattr', OPFS.realPath(node))\n        const path = OPFS.realPath(node)\n        return OPFS.tryFSOperation(() => {\n          const stats = opfsAhp.lstat(path)\n          return {\n            ...stats,\n            dev: 0,\n            ino: node.id,\n            nlink: 1,\n            rdev: node.rdev,\n            atime: new Date(stats.atime),\n            mtime: new Date(stats.mtime),\n            ctime: new Date(stats.ctime),\n          }\n        })\n      },\n      setattr(node: OpfsNode, attr: FS.Stats): void {\n        log('setattr', OPFS.realPath(node), attr)\n        const path = OPFS.realPath(node)\n        OPFS.tryFSOperation(() => {\n          if (attr.mode !== undefined) {\n            opfsAhp.chmod(path, attr.mode)\n          }\n          if (attr.size !== undefined) {\n            opfsAhp.truncate(path, attr.size)\n          }\n          if (attr.timestamp !== undefined) {\n            opfsAhp.utimes(path, attr.timestamp, attr.timestamp)\n          }\n          if (attr.size !== undefined) {\n            opfsAhp.truncate(path, attr.size)\n          }\n        })\n      },\n      lookup(parent: FSNode, name: string): OpfsNode {\n        log('lookup', OPFS.realPath(parent), name)\n        const path = [OPFS.realPath(parent), name].join('/')\n        const mode = OPFS.getMode(path)\n        return OPFS.createNode(parent, name, mode)\n      },\n      mknod(\n        parent: FSNode,\n        name: string,\n        mode: number,\n        dev: unknown,\n      ): OpfsNode {\n        log('mknod', OPFS.realPath(parent), name, mode, dev)\n        const node = OPFS.createNode(parent, name, mode, dev)\n        // create the backing node for this in the fs root as well\n        const path = OPFS.realPath(node)\n        return OPFS.tryFSOperation(() => {\n          if (FS.isDir(node.mode)) {\n            opfsAhp.mkdir(path, { mode })\n          } else {\n            opfsAhp.writeFile(path, '', { mode })\n          }\n          return node\n        })\n      },\n      rename(oldNode: OpfsNode, newDir: OpfsNode, newName: string): void {\n        log('rename', OPFS.realPath(oldNode), OPFS.realPath(newDir), newName)\n        const oldPath = OPFS.realPath(oldNode)\n        const newPath = [OPFS.realPath(newDir), newName].join('/')\n        OPFS.tryFSOperation(() => {\n          opfsAhp.rename(oldPath, newPath)\n        })\n        oldNode.name = newName\n      },\n      unlink(parent: OpfsNode, name: string): void {\n        log('unlink', OPFS.realPath(parent), name)\n        const path = [OPFS.realPath(parent), name].join('/')\n        try {\n          opfsAhp.unlink(path)\n        } catch (e: any) {\n          // no-op\n        }\n      },\n      rmdir(parent: OpfsNode, name: string): void {\n        log('rmdir', OPFS.realPath(parent), name)\n        const path = [OPFS.realPath(parent), name].join('/')\n        return OPFS.tryFSOperation(() => {\n          opfsAhp.rmdir(path)\n        })\n      },\n      readdir(node: OpfsNode): string[] {\n        log('readdir', OPFS.realPath(node))\n        const path = OPFS.realPath(node)\n        return OPFS.tryFSOperation(() => {\n          return opfsAhp.readdir(path)\n        })\n      },\n      symlink(parent: FSNode, newName: string, oldPath: string): void {\n        log('symlink', OPFS.realPath(parent), newName, oldPath)\n        // This is not supported by OPFS\n        throw new FS.ErrnoError(63)\n      },\n      readlink(node: FSNode): string {\n        log('readlink', OPFS.realPath(node))\n        // This is not supported by OPFS\n        throw new FS.ErrnoError(63)\n      },\n    },\n    stream_ops: {\n      open(stream: FSStream): void {\n        log('open stream', OPFS.realPath(stream.node))\n        const path = OPFS.realPath(stream.node)\n        return OPFS.tryFSOperation(() => {\n          if (FS.isFile(stream.node.mode)) {\n            stream.shared.refcount = 1\n            stream.nfd = opfsAhp.open(path)\n          }\n        })\n      },\n      close(stream: FSStream): void {\n        log('close stream', OPFS.realPath(stream.node))\n        return OPFS.tryFSOperation(() => {\n          if (\n            FS.isFile(stream.node.mode) &&\n            stream.nfd &&\n            --stream.shared.refcount === 0\n          ) {\n            opfsAhp.close(stream.nfd)\n          }\n        })\n      },\n      dup(stream: FSStream) {\n        log('dup stream', OPFS.realPath(stream.node))\n        stream.shared.refcount++\n      },\n      read(\n        stream: FSStream, // Stream to read from\n        buffer: Uint8Array, // Buffer to read into - Wrong type in @types/emscripten\n        offset: number, // Offset in buffer to start writing to\n        length: number, // Number of bytes to read\n        position: number, // Position in file to read from\n      ): number {\n        log('read stream', OPFS.realPath(stream.node), offset, length, position)\n        if (length === 0) return 0\n        const ret = OPFS.tryFSOperation(() =>\n          opfsAhp.read(\n            stream.nfd!,\n            buffer as unknown as Int8Array,\n            offset,\n            length,\n            position,\n          ),\n        )\n        return ret\n      },\n      write(\n        stream: FSStream, // Stream to write to\n        buffer: Uint8Array, // Buffer to read from - Wrong type in @types/emscripten\n        offset: number, // Offset in buffer to start writing from\n        length: number, // Number of bytes to write\n        position: number, // Position in file to write to\n      ): number {\n        log(\n          'write stream',\n          OPFS.realPath(stream.node),\n          offset,\n          length,\n          position,\n        )\n        return OPFS.tryFSOperation(() =>\n          opfsAhp.write(\n            stream.nfd!,\n            buffer.buffer as unknown as Int8Array,\n            offset,\n            length,\n            position,\n          ),\n        )\n      },\n      llseek(stream: FSStream, offset: number, whence: number): number {\n        log('llseek stream', OPFS.realPath(stream.node), offset, whence)\n        let position = offset\n        if (whence === 1) {\n          position += stream.position\n        } else if (whence === 2) {\n          if (FS.isFile(stream.node.mode)) {\n            OPFS.tryFSOperation(() => {\n              const stat = opfsAhp.fstat(stream.nfd!)\n              position += stat.size\n            })\n          }\n        }\n        if (position < 0) {\n          throw new FS.ErrnoError(28)\n        }\n        return position\n      },\n      mmap(\n        stream: FSStream,\n        length: number,\n        position: number,\n        prot: any,\n        flags: any,\n      ) {\n        log(\n          'mmap stream',\n          OPFS.realPath(stream.node),\n          length,\n          position,\n          prot,\n          flags,\n        )\n        if (!FS.isFile(stream.node.mode)) {\n          throw new FS.ErrnoError(ERRNO_CODES.ENODEV)\n        }\n\n        const ptr = (Module as any).mmapAlloc(length) // TODO: Fix type and check this is exported\n\n        OPFS.stream_ops.read(\n          stream,\n          Module.HEAP8 as unknown as Uint8Array,\n          ptr,\n          length,\n          position,\n        )\n        return { ptr, allocated: true }\n      },\n      msync(\n        stream: FSStream,\n        buffer: Uint8Array,\n        offset: number,\n        length: number,\n        mmapFlags: any,\n      ) {\n        log(\n          'msync stream',\n          OPFS.realPath(stream.node),\n          offset,\n          length,\n          mmapFlags,\n        )\n        OPFS.stream_ops.write(stream, buffer, 0, length, offset)\n        return 0\n      },\n    },\n  } satisfies FileSystemType\n  return OPFS\n}\n\nfunction log(..._args: any[]) {\n  // console.log(...args);\n}\n","export type FsStats = {\n  dev: number\n  ino: number\n  mode: number\n  nlink: number\n  uid: number\n  gid: number\n  rdev: number\n  size: number\n  blksize: number\n  blocks: number\n  atime: number\n  mtime: number\n  ctime: number\n}\n\n// TypeScript doesn't have a built-in type for FileSystemSyncAccessHandle\nexport interface FileSystemSyncAccessHandle {\n  close(): void\n  flush(): void\n  getSize(): number\n  read(buffer: ArrayBuffer, options: { at: number }): number\n  truncate(newSize: number): void\n  write(buffer: ArrayBuffer, options: { at: number }): number\n}\n\nexport const ERRNO_CODES = {\n  EBADF: 8,\n  EBADFD: 127,\n  EEXIST: 20,\n  EINVAL: 28,\n  EISDIR: 31,\n  ENODEV: 43,\n  ENOENT: 44,\n  ENOTDIR: 54,\n  ENOTEMPTY: 55,\n} as const\n\nexport class FsError extends Error {\n  code?: number\n  constructor(code: number | keyof typeof ERRNO_CODES | null, message: string) {\n    super(message)\n    if (typeof code === 'number') {\n      this.code = code\n    } else if (typeof code === 'string') {\n      this.code = ERRNO_CODES[code]\n    }\n  }\n}\n\n// State\n\nexport interface State {\n  root: DirectoryNode\n  pool: PoolFilenames\n}\n\nexport type PoolFilenames = Array<string>\n\n// WAL\n\nexport interface WALEntry {\n  opp: string\n  args: any[]\n}\n\n// Node tree\n\nexport type NodeType = 'file' | 'directory'\n\ninterface BaseNode {\n  type: NodeType\n  lastModified: number\n  mode: number\n}\n\nexport interface FileNode extends BaseNode {\n  type: 'file'\n  backingFilename: string\n}\n\nexport interface DirectoryNode extends BaseNode {\n  type: 'directory'\n  children: { [filename: string]: Node }\n}\n\nexport type Node = FileNode | DirectoryNode\n","import { FsError } from './types.js'\nimport type {\n  FsStats,\n  State,\n  FileSystemSyncAccessHandle,\n  Node,\n  FileNode,\n  DirectoryNode,\n  WALEntry,\n} from './types.js'\n\nconst STATE_FILE = 'state.txt'\nconst DATA_DIR = 'data'\nconst INITIAL_MODE = {\n  DIR: 16384,\n  FILE: 32768,\n}\n\nexport interface OpfsAhpOptions {\n  root: string\n  initialPoolSize?: number\n  maintainedPoolSize?: number\n}\n\n/**\n * An OPFS Access Handle Pool VFS that exports a Node.js-like FS interface.\n * This FS is then wrapped by an Emscripten FS interface in emscriptenFs.ts.\n */\nexport class OpfsAhp {\n  readyPromise: Promise<void>\n  #ready = false\n\n  readonly root: string\n  readonly initialPoolSize: number\n  readonly maintainedPoolSize: number\n\n  #opfsRootAh!: FileSystemDirectoryHandle\n  #rootAh!: FileSystemDirectoryHandle\n  #dataDirAh!: FileSystemDirectoryHandle\n\n  #stateFH!: FileSystemFileHandle\n  #stateSH!: FileSystemSyncAccessHandle\n\n  #fh: Map<string, FileSystemFileHandle> = new Map()\n  #sh: Map<string, FileSystemSyncAccessHandle> = new Map()\n\n  #handleIdCounter = 0\n  #openHandlePaths: Map<number, string> = new Map()\n  #openHandleIds: Map<string, number> = new Map()\n\n  state!: State\n  lastCheckpoint = 0\n  checkpointInterval = 1000 * 60 // 1 minute\n  poolCounter = 0\n\n  #unsyncedSH = new Set<FileSystemSyncAccessHandle>()\n\n  constructor({ root, initialPoolSize, maintainedPoolSize }: OpfsAhpOptions) {\n    this.root = root\n    this.initialPoolSize = initialPoolSize || 1000\n    this.maintainedPoolSize = maintainedPoolSize || 100\n    this.readyPromise = this.#init()\n  }\n\n  static async create(options: OpfsAhpOptions) {\n    const instance = new OpfsAhp(options)\n    await instance.readyPromise\n    return instance\n  }\n\n  async #init() {\n    this.#opfsRootAh = await navigator.storage.getDirectory()\n    this.#rootAh = await this.#resolveOpfsDirectory(this.root, {\n      create: true,\n    })\n    this.#dataDirAh = await this.#resolveOpfsDirectory(DATA_DIR, {\n      from: this.#rootAh,\n      create: true,\n    })\n\n    this.#stateFH = await this.#rootAh.getFileHandle(STATE_FILE, {\n      create: true,\n    })\n    this.#stateSH = await (this.#stateFH as any).createSyncAccessHandle()\n\n    const stateAB = new ArrayBuffer(this.#stateSH.getSize())\n    this.#stateSH.read(stateAB, { at: 0 })\n    let state: State\n    const stateLines = new TextDecoder().decode(stateAB).split('\\n')\n    // Line 1 is a base state object.\n    // Lines 1+n are WAL entries.\n\n    let isNewState = false\n    try {\n      state = JSON.parse(stateLines[0])\n    } catch (e) {\n      state = {\n        root: {\n          type: 'directory',\n          lastModified: Date.now(),\n          mode: INITIAL_MODE.DIR,\n          children: {},\n        },\n        pool: [],\n      }\n      // write new state to file\n      this.#stateSH.truncate(0)\n      this.#stateSH.write(new TextEncoder().encode(JSON.stringify(state)), {\n        at: 0,\n      })\n      isNewState = true\n    }\n    this.state = state\n\n    // Apply WAL entries\n    const wal = stateLines\n      .slice(1)\n      .filter(Boolean)\n      .map((line) => JSON.parse(line))\n    for (const entry of wal) {\n      const methodName = `_${entry.opp}State`\n      if (typeof this[methodName as keyof this] === 'function') {\n        try {\n          const method = this[methodName as keyof this] as any\n          method.bind(this)(...entry.args)\n        } catch (e) {\n          console.warn('Error applying OPFS AHP WAL entry', entry, e)\n        }\n      }\n    }\n\n    // Open all file handles for dir tree\n    const walkPromises: Promise<void>[] = []\n    const walk = async (node: Node) => {\n      if (node.type === 'file') {\n        try {\n          const fh = await this.#dataDirAh.getFileHandle(node.backingFilename)\n          const sh: FileSystemSyncAccessHandle = await (\n            fh as any\n          ).createSyncAccessHandle()\n          this.#fh.set(node.backingFilename, fh)\n\n          this.#sh.set(node.backingFilename, sh)\n        } catch (e) {\n          console.error('Error opening file handle for node', node, e)\n        }\n      } else {\n        for (const child of Object.values(node.children)) {\n          walkPromises.push(walk(child))\n        }\n      }\n    }\n    await walk(this.state.root)\n\n    // Open all pool file handles\n    const poolPromises: Promise<void>[] = []\n    for (const filename of this.state.pool) {\n      poolPromises.push(\n        // eslint-disable-next-line no-async-promise-executor\n        new Promise<void>(async (resolve) => {\n          if (this.#fh.has(filename)) {\n            console.warn('File handle already exists for pool file', filename)\n          }\n          const fh = await this.#dataDirAh.getFileHandle(filename)\n          const sh: FileSystemSyncAccessHandle = await (\n            fh as any\n          ).createSyncAccessHandle()\n          this.#fh.set(filename, fh)\n          this.#sh.set(filename, sh)\n          resolve()\n        }),\n      )\n    }\n\n    await Promise.all([...walkPromises, ...poolPromises])\n\n    await this.maintainPool(\n      isNewState ? this.initialPoolSize : this.maintainedPoolSize,\n    )\n\n    this.#ready = true\n  }\n\n  get ready() {\n    return this.#ready\n  }\n\n  async maintainPool(size?: number) {\n    size = size || this.maintainedPoolSize\n    const change = size - this.state.pool.length\n    const promises: Promise<void>[] = []\n    for (let i = 0; i < change; i++) {\n      promises.push(\n        // eslint-disable-next-line no-async-promise-executor\n        new Promise<void>(async (resolve) => {\n          ++this.poolCounter\n          const filename = `${(Date.now() - 1704063600).toString(16).padStart(8, '0')}-${this.poolCounter.toString(16).padStart(8, '0')}`\n          const fh = await this.#dataDirAh.getFileHandle(filename, {\n            create: true,\n          })\n          const sh: FileSystemSyncAccessHandle = await (\n            fh as any\n          ).createSyncAccessHandle()\n          this.#fh.set(filename, fh)\n          this.#sh.set(filename, sh)\n          this.#logWAL({\n            opp: 'createPoolFile',\n            args: [filename],\n          })\n          this.state.pool.push(filename)\n          resolve()\n        }),\n      )\n    }\n    for (let i = 0; i > change; i--) {\n      promises.push(\n        // eslint-disable-next-line no-async-promise-executor\n        new Promise<void>(async (resolve) => {\n          const filename = this.state.pool.pop()!\n          this.#logWAL({\n            opp: 'deletePoolFile',\n            args: [filename],\n          })\n          const fh = this.#fh.get(filename)!\n          const sh = this.#sh.get(filename)\n          sh?.close()\n          // @ts-ignore outdated type? need to check\n          await fh.remove().then(() => {\n            this.#fh.delete(filename)\n            this.#sh.delete(filename)\n            resolve()\n          })\n        }),\n      )\n    }\n    await Promise.all(promises)\n  }\n\n  _createPoolFileState(filename: string) {\n    this.state.pool.push(filename)\n  }\n\n  _deletePoolFileState(filename: string) {\n    const index = this.state.pool.indexOf(filename)\n    if (index > -1) {\n      this.state.pool.splice(index, 1)\n    }\n  }\n\n  async maybeCheckpointState() {\n    if (Date.now() - this.lastCheckpoint > this.checkpointInterval) {\n      await this.checkpointState()\n    }\n  }\n\n  async checkpointState() {\n    const stateAB = new TextEncoder().encode(JSON.stringify(this.state))\n    this.#stateSH.truncate(0)\n    this.#stateSH.write(stateAB, { at: 0 })\n    this.#stateSH.flush()\n    this.lastCheckpoint = Date.now()\n  }\n\n  flush() {\n    for (const sh of this.#unsyncedSH) {\n      try {\n        sh.flush()\n      } catch (e) {\n        // The file may have been closed if it was deleted\n      }\n    }\n    this.#unsyncedSH.clear()\n  }\n\n  exit(): void {\n    for (const sh of this.#sh.values()) {\n      sh.close()\n    }\n    this.#stateSH.flush()\n    this.#stateSH.close()\n  }\n\n  // Filesystem API:\n\n  chmod(path: string, mode: number): void {\n    this.#tryWithWAL({ opp: 'chmod', args: [path, mode] }, () => {\n      this._chmodState(path, mode)\n    })\n  }\n\n  _chmodState(path: string, mode: number): void {\n    const node = this.#resolvePath(path)\n    node.mode = mode\n  }\n\n  close(fd: number): void {\n    const path = this.#getPathFromFd(fd)\n    this.#openHandlePaths.delete(fd)\n    this.#openHandleIds.delete(path)\n  }\n\n  fstat(fd: number): FsStats {\n    const path = this.#getPathFromFd(fd)\n    return this.lstat(path)\n  }\n\n  lstat(path: string): FsStats {\n    const node = this.#resolvePath(path)\n    const size =\n      node.type === 'file' ? this.#sh.get(node.backingFilename)!.getSize() : 0\n    const blksize = 4096\n    return {\n      dev: 0,\n      ino: 0,\n      mode: node.mode,\n      nlink: 1,\n      uid: 0,\n      gid: 0,\n      rdev: 0,\n      size,\n      blksize,\n      blocks: Math.ceil(size / blksize),\n      atime: node.lastModified,\n      mtime: node.lastModified,\n      ctime: node.lastModified,\n    }\n  }\n\n  mkdir(path: string, options?: { recursive?: boolean; mode?: number }): void {\n    this.#tryWithWAL({ opp: 'mkdir', args: [path, options] }, () => {\n      this._mkdirState(path, options)\n    })\n  }\n\n  _mkdirState(\n    path: string,\n    options?: { recursive?: boolean; mode?: number },\n  ): void {\n    const parts = this.#pathParts(path)\n    const newDirName = parts.pop()!\n    const currentPath: string[] = []\n    let node = this.state.root\n    for (const part of parts) {\n      currentPath.push(path)\n      if (!Object.prototype.hasOwnProperty.call(node.children, part)) {\n        if (options?.recursive) {\n          this.mkdir(currentPath.join('/'))\n        } else {\n          throw new FsError('ENOENT', 'No such file or directory')\n        }\n      }\n      if (node.children[part].type !== 'directory') {\n        throw new FsError('ENOTDIR', 'Not a directory')\n      }\n      node = node.children[part] as DirectoryNode\n    }\n    if (Object.prototype.hasOwnProperty.call(node.children, newDirName)) {\n      throw new FsError('EEXIST', 'File exists')\n    }\n    const newDir: DirectoryNode = {\n      type: 'directory',\n      lastModified: Date.now(),\n      mode: options?.mode || INITIAL_MODE.DIR,\n      children: {},\n    }\n    node.children[newDirName] = newDir\n  }\n\n  open(path: string, _flags?: string, _mode?: number): number {\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const handleId = this.#nextHandleId()\n    this.#openHandlePaths.set(handleId, path)\n    this.#openHandleIds.set(path, handleId)\n    return handleId\n  }\n\n  readdir(path: string): string[] {\n    const node = this.#resolvePath(path)\n    if (node.type !== 'directory') {\n      throw new FsError('ENOTDIR', 'Not a directory')\n    }\n    return Object.keys(node.children)\n  }\n\n  read(\n    fd: number,\n    buffer: Int8Array, // Buffer to read into\n    offset: number, // Offset in buffer to start writing to\n    length: number, // Number of bytes to read\n    position: number, // Position in file to read from\n  ): number {\n    const path = this.#getPathFromFd(fd)\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const sh = this.#sh.get(node.backingFilename)!\n    return sh.read(new Int8Array(buffer.buffer, offset, length), {\n      at: position,\n    })\n  }\n\n  rename(oldPath: string, newPath: string): void {\n    this.#tryWithWAL({ opp: 'rename', args: [oldPath, newPath] }, () => {\n      this._renameState(oldPath, newPath, true)\n    })\n  }\n\n  _renameState(oldPath: string, newPath: string, doFileOps = false): void {\n    const oldPathParts = this.#pathParts(oldPath)\n    const oldFilename = oldPathParts.pop()!\n    const oldParent = this.#resolvePath(oldPathParts.join('/')) as DirectoryNode\n    if (\n      !Object.prototype.hasOwnProperty.call(oldParent.children, oldFilename)\n    ) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    const newPathParts = this.#pathParts(newPath)\n    const newFilename = newPathParts.pop()!\n    const newParent = this.#resolvePath(newPathParts.join('/')) as DirectoryNode\n    if (\n      doFileOps &&\n      Object.prototype.hasOwnProperty.call(newParent.children, newFilename)\n    ) {\n      // Overwrite, so return the underlying file to the pool\n      const node = newParent.children[newFilename]! as FileNode\n      const sh = this.#sh.get(node.backingFilename)!\n      sh.truncate(0)\n      this.state.pool.push(node.backingFilename)\n    }\n    newParent.children[newFilename] = oldParent.children[oldFilename]!\n    delete oldParent.children[oldFilename]\n  }\n\n  rmdir(path: string): void {\n    this.#tryWithWAL({ opp: 'rmdir', args: [path] }, () => {\n      this._rmdirState(path)\n    })\n  }\n\n  _rmdirState(path: string): void {\n    const pathParts = this.#pathParts(path)\n    const dirName = pathParts.pop()!\n    const parent = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n    if (!Object.prototype.hasOwnProperty.call(parent.children, dirName)) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    const node = parent.children[dirName]!\n    if (node.type !== 'directory') {\n      throw new FsError('ENOTDIR', 'Not a directory')\n    }\n    if (Object.keys(node.children).length > 0) {\n      throw new FsError('ENOTEMPTY', 'Directory not empty')\n    }\n    delete parent.children[dirName]\n  }\n\n  truncate(path: string, len = 0): void {\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const sh = this.#sh.get(node.backingFilename)\n    if (!sh) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    sh.truncate(len)\n    this.#unsyncedSH.add(sh)\n  }\n\n  unlink(path: string): void {\n    this.#tryWithWAL({ opp: 'unlink', args: [path] }, () => {\n      this._unlinkState(path, true)\n    })\n  }\n\n  _unlinkState(path: string, doFileOps = false): void {\n    const pathParts = this.#pathParts(path)\n    const filename = pathParts.pop()!\n    const dir = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n    if (!Object.prototype.hasOwnProperty.call(dir.children, filename)) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    const node = dir.children[filename]!\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    delete dir.children[filename]\n    if (doFileOps) {\n      const sh = this.#sh.get(node.backingFilename)!\n      // We don't delete the file, it's truncated and returned to the pool\n      sh?.truncate(0)\n      this.#unsyncedSH.add(sh)\n      if (this.#openHandleIds.has(path)) {\n        this.#openHandlePaths.delete(this.#openHandleIds.get(path)!)\n        this.#openHandleIds.delete(path)\n      }\n    }\n    this.state.pool.push(node.backingFilename)\n  }\n\n  utimes(path: string, atime: number, mtime: number): void {\n    this.#tryWithWAL({ opp: 'utimes', args: [path, atime, mtime] }, () => {\n      this._utimesState(path, atime, mtime)\n    })\n  }\n\n  _utimesState(path: string, _atime: number, mtime: number): void {\n    const node = this.#resolvePath(path)\n    node.lastModified = mtime\n  }\n\n  writeFile(\n    path: string,\n    data: string | Int8Array,\n    options?: { encoding?: string; mode?: number; flag?: string },\n  ): void {\n    const pathParts = this.#pathParts(path)\n    const filename = pathParts.pop()!\n    const parent = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n\n    if (!Object.prototype.hasOwnProperty.call(parent.children, filename)) {\n      if (this.state.pool.length === 0) {\n        throw new Error('No more file handles available in the pool')\n      }\n      const node: Node = {\n        type: 'file',\n        lastModified: Date.now(),\n        mode: options?.mode || INITIAL_MODE.FILE,\n        backingFilename: this.state.pool.pop()!,\n      }\n      parent.children[filename] = node\n      this.#logWAL({\n        opp: 'createFileNode',\n        args: [path, node],\n      })\n    } else {\n      const node = parent.children[filename] as FileNode\n      node.lastModified = Date.now()\n      this.#logWAL({\n        opp: 'setLastModified',\n        args: [path, node.lastModified],\n      })\n    }\n    const node = parent.children[filename] as FileNode\n    const sh = this.#sh.get(node.backingFilename)!\n    // Files in pool are empty, only write if data is provided\n    if (data.length > 0) {\n      sh.write(\n        typeof data === 'string'\n          ? new TextEncoder().encode(data)\n          : new Int8Array(data),\n        { at: 0 },\n      )\n      if (path.startsWith('/pg_wal')) {\n        this.#unsyncedSH.add(sh)\n      }\n    }\n  }\n\n  _createFileNodeState(path: string, node: FileNode): FileNode {\n    const pathParts = this.#pathParts(path)\n    const filename = pathParts.pop()!\n    const parent = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n    parent.children[filename] = node\n    // remove backingFilename from pool\n    const index = this.state.pool.indexOf(node.backingFilename)\n    if (index > -1) {\n      this.state.pool.splice(index, 1)\n    }\n    return node\n  }\n\n  _setLastModifiedState(path: string, lastModified: number): void {\n    const node = this.#resolvePath(path)\n    node.lastModified = lastModified\n  }\n\n  write(\n    fd: number,\n    buffer: Int8Array, // Buffer to read from\n    offset: number, // Offset in buffer to start reading from\n    length: number, // Number of bytes to write\n    position: number, // Position in file to write to\n  ): number {\n    const path = this.#getPathFromFd(fd)\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const sh = this.#sh.get(node.backingFilename)\n    if (!sh) {\n      throw new FsError('EBADF', 'Bad file descriptor')\n    }\n    const ret = sh.write(new Int8Array(buffer, offset, length), {\n      at: position,\n    })\n    if (path.startsWith('/pg_wal')) {\n      this.#unsyncedSH.add(sh)\n    }\n    return ret\n  }\n\n  // Internal methods:\n\n  #tryWithWAL(entry: WALEntry, fn: () => void) {\n    const offset = this.#logWAL(entry)\n    try {\n      fn()\n    } catch (e) {\n      // Rollback WAL entry\n      this.#stateSH.truncate(offset)\n      throw e\n    }\n  }\n\n  #logWAL(entry: WALEntry) {\n    const entryJSON = JSON.stringify(entry)\n    const stateAB = new TextEncoder().encode(`\\n${entryJSON}`)\n    const offset = this.#stateSH.getSize()\n    this.#stateSH.write(stateAB, { at: offset })\n    this.#unsyncedSH.add(this.#stateSH)\n    return offset\n  }\n\n  #pathParts(path: string): string[] {\n    return path.split('/').filter(Boolean)\n  }\n\n  #resolvePath(path: string, from?: DirectoryNode): Node {\n    const parts = this.#pathParts(path)\n    let node: Node = from || this.state.root\n    for (const part of parts) {\n      if (node.type !== 'directory') {\n        throw new FsError('ENOTDIR', 'Not a directory')\n      }\n      if (!Object.prototype.hasOwnProperty.call(node.children, part)) {\n        throw new FsError('ENOENT', 'No such file or directory')\n      }\n      node = node.children[part]!\n    }\n    return node\n  }\n\n  #getPathFromFd(fd: number): string {\n    const path = this.#openHandlePaths.get(fd)\n    if (!path) {\n      throw new FsError('EBADF', 'Bad file descriptor')\n    }\n    return path\n  }\n\n  #nextHandleId(): number {\n    const id = ++this.#handleIdCounter\n    while (this.#openHandlePaths.has(id)) {\n      this.#handleIdCounter++\n    }\n    return id\n  }\n\n  async #resolveOpfsDirectory(\n    path: string,\n    options?: {\n      from?: FileSystemDirectoryHandle\n      create?: boolean\n    },\n  ): Promise<FileSystemDirectoryHandle> {\n    const parts = this.#pathParts(path)\n    let ah = options?.from || this.#opfsRootAh\n    for (const part of parts) {\n      ah = await ah.getDirectoryHandle(part, { create: options?.create })\n    }\n    return ah\n  }\n}\n"],"mappings":"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","names":["init_esm_shims","init_esm_shims","init_esm_shims","ERRNO_CODES","FsError","code","message","createOPFSAHP","Module","opfsAhp","FS","OPFS","f","e","ERRNO_CODES","_mount","_populate","_done","parent","name","mode","_dev","node","path","log","parts","stats","attr","dev","oldNode","newDir","newName","oldPath","newPath","stream","buffer","offset","length","position","whence","stat","prot","flags","ptr","mmapFlags","_args","init_esm_shims","STATE_FILE","DATA_DIR","INITIAL_MODE","_ready","_opfsRootAh","_rootAh","_dataDirAh","_stateFH","_stateSH","_fh","_sh","_handleIdCounter","_openHandlePaths","_openHandleIds","_unsyncedSH","_OpfsAhp_instances","init_fn","tryWithWAL_fn","logWAL_fn","pathParts_fn","resolvePath_fn","getPathFromFd_fn","nextHandleId_fn","resolveOpfsDirectory_fn","_OpfsAhp","root","initialPoolSize","maintainedPoolSize","__privateAdd","__privateMethod","options","instance","__privateGet","size","change","promises","i","resolve","filename","fh","sh","index","stateAB","path","mode","node","fd","blksize","parts","newDirName","currentPath","part","FsError","newDir","_flags","_mode","handleId","buffer","offset","length","position","oldPath","newPath","doFileOps","oldPathParts","oldFilename","oldParent","newPathParts","newFilename","newParent","pathParts","dirName","parent","len","dir","atime","mtime","_atime","data","lastModified","ret","__privateSet","state","stateLines","isNewState","wal","line","entry","methodName","e","walkPromises","walk","child","poolPromises","fn","entryJSON","from","id","__privateWrapper","ah","OpfsAhp","_initialPoolSize","_maintainedPoolSize","OpfsAhpFS","FilesystemBase","dataDir","initialPoolSize","maintainedPoolSize","__privateAdd","__privateSet","opts","OpfsAhp","__privateGet","mod","OPFS","createOPFSAHP","PGDATA","_fs","relaxedDurability","dbname","compression","dumpTar","FS"]}