{"version":3,"sources":["../src/base.ts"],"sourcesContent":["import { query as queryTemplate } from './templating.js'\nimport { parseDescribeStatementResults, parseResults } from './parse.js'\nimport {\n  type Serializer,\n  type Parser,\n  serializers,\n  parsers,\n  arraySerializer,\n  arrayParser,\n} from './types.js'\nimport type {\n  DebugLevel,\n  PGliteInterface,\n  Results,\n  Transaction,\n  QueryOptions,\n  ExecProtocolOptions,\n} from './interface.js'\n\nimport { serialize as serializeProtocol } from '@electric-sql/pg-protocol'\nimport { BackendMessage } from '@electric-sql/pg-protocol/messages'\n\nexport abstract class BasePGlite\n  implements Pick<PGliteInterface, 'query' | 'sql' | 'exec' | 'transaction'>\n{\n  serializers: Record<number | string, Serializer> = { ...serializers }\n  parsers: Record<number | string, Parser> = { ...parsers }\n  #arrayTypesInitialized = false\n\n  // # Abstract properties:\n  abstract debug: DebugLevel\n\n  // # Private properties:\n  #inTransaction = false\n\n  // # Abstract methods:\n\n  /**\n   * Execute a postgres wire protocol message\n   * @param message The postgres wire protocol message to execute\n   * @returns The result of the query\n   */\n  abstract execProtocol(\n    message: Uint8Array,\n    { syncToFs, onNotice }: ExecProtocolOptions,\n  ): Promise<Array<[BackendMessage, Uint8Array]>>\n\n  /**\n   * Execute a postgres wire protocol message directly without wrapping the response.\n   * Only use if `execProtocol()` doesn't suite your needs.\n   *\n   * **Warning:** This bypasses PGlite's protocol wrappers that manage error/notice messages,\n   * transactions, and notification listeners. Only use if you need to bypass these wrappers and\n   * don't intend to use the above features.\n   *\n   * @param message The postgres wire protocol message to execute\n   * @returns The direct message data response produced by Postgres\n   */\n  abstract execProtocolRaw(\n    message: Uint8Array,\n    { syncToFs }: ExecProtocolOptions,\n  ): Promise<Uint8Array>\n\n  /**\n   * Sync the database to the filesystem\n   * @returns Promise that resolves when the database is synced to the filesystem\n   */\n  abstract syncToFs(): Promise<void>\n\n  /**\n   * Handle a file attached to the current query\n   * @param file The file to handle\n   */\n  abstract _handleBlob(blob?: File | Blob): Promise<void>\n\n  /**\n   * Get the written file\n   */\n  abstract _getWrittenBlob(): Promise<File | Blob | undefined>\n\n  /**\n   * Cleanup the current file\n   */\n  abstract _cleanupBlob(): Promise<void>\n\n  abstract _checkReady(): Promise<void>\n  abstract _runExclusiveQuery<T>(fn: () => Promise<T>): Promise<T>\n  abstract _runExclusiveTransaction<T>(fn: () => Promise<T>): Promise<T>\n\n  // # Concrete implementations:\n\n  /**\n   * Initialize the array types\n   * The oid if the type of an element and the typarray is the oid of the type of the\n   * array.\n   * We extract these from the databaes then create the serializers/parsers for\n   * each type.\n   * This should be called at the end of #init() in the implementing class.\n   */\n  async _initArrayTypes() {\n    if (this.#arrayTypesInitialized) return\n    this.#arrayTypesInitialized = true\n\n    const types = await this.query<{ oid: number; typarray: number }>(`\n      SELECT b.oid, b.typarray\n      FROM pg_catalog.pg_type a\n      LEFT JOIN pg_catalog.pg_type b ON b.oid = a.typelem\n      WHERE a.typcategory = 'A'\n      GROUP BY b.oid, b.typarray\n      ORDER BY b.oid\n    `)\n\n    for (const type of types.rows) {\n      this.serializers[type.typarray] = (x) =>\n        arraySerializer(x, this.serializers[type.oid], type.typarray)\n      this.parsers[type.typarray] = (x) =>\n        arrayParser(x, this.parsers[type.oid], type.typarray)\n    }\n  }\n\n  async #execProtocolNoSync(\n    message: Uint8Array,\n    options: ExecProtocolOptions = {},\n  ): Promise<Array<[BackendMessage, Uint8Array]>> {\n    return await this.execProtocol(message, { ...options, syncToFs: false })\n  }\n\n  /**\n   * Execute a single SQL statement\n   * This uses the \"Extended Query\" postgres wire protocol message.\n   * @param query The query to execute\n   * @param params Optional parameters for the query\n   * @returns The result of the query\n   */\n  async query<T>(\n    query: string,\n    params?: any[],\n    options?: QueryOptions,\n  ): Promise<Results<T>> {\n    await this._checkReady()\n    // We wrap the public query method in the transaction mutex to ensure that\n    // only one query can be executed at a time and not concurrently with a\n    // transaction.\n    return await this._runExclusiveTransaction(async () => {\n      return await this.#runQuery<T>(query, params, options)\n    })\n  }\n\n  /**\n   * Execute a single SQL statement like with {@link PGlite.query}, but with a\n   * templated statement where template values will be treated as parameters.\n   *\n   * You can use helpers from `/template` to further format the query with\n   * identifiers, raw SQL, and nested statements.\n   *\n   * This uses the \"Extended Query\" postgres wire protocol message.\n   *\n   * @param query The query to execute with parameters as template values\n   * @returns The result of the query\n   *\n   * @example\n   * ```ts\n   * const results = await db.sql`SELECT * FROM ${identifier`foo`} WHERE id = ${id}`\n   * ```\n   */\n  async sql<T>(\n    sqlStrings: TemplateStringsArray,\n    ...params: any[]\n  ): Promise<Results<T>> {\n    const { query, params: actualParams } = queryTemplate(sqlStrings, ...params)\n    return await this.query(query, actualParams)\n  }\n\n  /**\n   * Execute a SQL query, this can have multiple statements.\n   * This uses the \"Simple Query\" postgres wire protocol message.\n   * @param query The query to execute\n   * @returns The result of the query\n   */\n  async exec(query: string, options?: QueryOptions): Promise<Array<Results>> {\n    await this._checkReady()\n    // We wrap the public exec method in the transaction mutex to ensure that\n    // only one query can be executed at a time and not concurrently with a\n    // transaction.\n    return await this._runExclusiveTransaction(async () => {\n      return await this.#runExec(query, options)\n    })\n  }\n\n  /**\n   * Internal method to execute a query\n   * Not protected by the transaction mutex, so it can be used inside a transaction\n   * @param query The query to execute\n   * @param params Optional parameters for the query\n   * @returns The result of the query\n   */\n  async #runQuery<T>(\n    query: string,\n    params: any[] = [],\n    options?: QueryOptions,\n  ): Promise<Results<T>> {\n    return await this._runExclusiveQuery(async () => {\n      // We need to parse, bind and execute a query with parameters\n      this.#log('runQuery', query, params, options)\n      await this._handleBlob(options?.blob)\n\n      let results\n\n      try {\n        const parseResults = await this.#execProtocolNoSync(\n          serializeProtocol.parse({ text: query, types: options?.paramTypes }),\n          options,\n        )\n\n        const dataTypeIDs = parseDescribeStatementResults(\n          (\n            await this.#execProtocolNoSync(\n              serializeProtocol.describe({ type: 'S' }),\n              options,\n            )\n          ).map(([msg]) => msg),\n        )\n\n        const values = params.map((param, i) => {\n          const oid = dataTypeIDs[i]\n          if (param === null || param === undefined) {\n            return null\n          }\n          const serialize = this.serializers[oid]\n          if (serialize) {\n            return serialize(param)\n          } else {\n            return param.toString()\n          }\n        })\n\n        results = [\n          ...parseResults,\n          ...(await this.#execProtocolNoSync(\n            serializeProtocol.bind({\n              values,\n            }),\n            options,\n          )),\n          ...(await this.#execProtocolNoSync(\n            serializeProtocol.describe({ type: 'P' }),\n            options,\n          )),\n          ...(await this.#execProtocolNoSync(\n            serializeProtocol.execute({}),\n            options,\n          )),\n        ]\n      } finally {\n        await this.#execProtocolNoSync(serializeProtocol.sync(), options)\n      }\n\n      await this._cleanupBlob()\n      if (!this.#inTransaction) {\n        await this.syncToFs()\n      }\n      const blob = await this._getWrittenBlob()\n      return parseResults(\n        results.map(([msg]) => msg),\n        this.parsers,\n        options,\n        blob,\n      )[0] as Results<T>\n    })\n  }\n\n  /**\n   * Internal method to execute a query\n   * Not protected by the transaction mutex, so it can be used inside a transaction\n   * @param query The query to execute\n   * @param params Optional parameters for the query\n   * @returns The result of the query\n   */\n  async #runExec(\n    query: string,\n    options?: QueryOptions,\n  ): Promise<Array<Results>> {\n    return await this._runExclusiveQuery(async () => {\n      // No params so we can just send the query\n      this.#log('runExec', query, options)\n      await this._handleBlob(options?.blob)\n      let results\n      try {\n        results = await this.#execProtocolNoSync(\n          serializeProtocol.query(query),\n          options,\n        )\n      } finally {\n        await this.#execProtocolNoSync(serializeProtocol.sync(), options)\n      }\n      this._cleanupBlob()\n      if (!this.#inTransaction) {\n        await this.syncToFs()\n      }\n      const blob = await this._getWrittenBlob()\n      return parseResults(\n        results.map(([msg]) => msg),\n        this.parsers,\n        options,\n        blob,\n      ) as Array<Results>\n    })\n  }\n\n  /**\n   * Execute a transaction\n   * @param callback A callback function that takes a transaction object\n   * @returns The result of the transaction\n   */\n  async transaction<T>(\n    callback: (tx: Transaction) => Promise<T>,\n  ): Promise<T | undefined> {\n    await this._checkReady()\n    return await this._runExclusiveTransaction(async () => {\n      await this.#runExec('BEGIN')\n      this.#inTransaction = true\n\n      // Once a transaction is closed, we throw an error if it's used again\n      let closed = false\n      const checkClosed = () => {\n        if (closed) {\n          throw new Error('Transaction is closed')\n        }\n      }\n\n      const tx: Transaction = {\n        query: async <T>(\n          query: string,\n          params?: any[],\n          options?: QueryOptions,\n        ): Promise<Results<T>> => {\n          checkClosed()\n          return await this.#runQuery(query, params, options)\n        },\n        sql: async <T>(\n          sqlStrings: TemplateStringsArray,\n          ...params: any[]\n        ): Promise<Results<T>> => {\n          const { query, params: actualParams } = queryTemplate(\n            sqlStrings,\n            ...params,\n          )\n          return await this.#runQuery(query, actualParams)\n        },\n        exec: async (\n          query: string,\n          options?: QueryOptions,\n        ): Promise<Array<Results>> => {\n          checkClosed()\n          return await this.#runExec(query, options)\n        },\n        rollback: async () => {\n          checkClosed()\n          // Rollback and set the closed flag to prevent further use of this\n          // transaction\n          await this.#runExec('ROLLBACK')\n          closed = true\n        },\n        get closed() {\n          return closed\n        },\n      }\n\n      try {\n        const result = await callback(tx)\n        if (!closed) {\n          closed = true\n          await this.#runExec('COMMIT')\n        }\n        this.#inTransaction = false\n        return result\n      } catch (e) {\n        if (!closed) {\n          await this.#runExec('ROLLBACK')\n        }\n        this.#inTransaction = false\n        throw e\n      }\n    })\n  }\n\n  /**\n   * Internal log function\n   */\n  #log(...args: any[]) {\n    if (this.debug > 0) {\n      console.log(...args)\n    }\n  }\n}\n"],"mappings":"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","names":["init_esm_shims","_arrayTypesInitialized","_inTransaction","_BasePGlite_instances","execProtocolNoSync_fn","runQuery_fn","runExec_fn","log_fn","BasePGlite","__privateAdd","serializers","parsers","__privateGet","__privateSet","types","type","x","arraySerializer","arrayParser","query","params","options","__privateMethod","sqlStrings","actualParams","callback","closed","checkClosed","tx","result","e","message","results","parseResults","serialize","dataTypeIDs","parseDescribeStatementResults","msg","values","param","i","oid","blob","args"]}