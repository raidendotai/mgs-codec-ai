{"version":3,"sources":["../src/index.ts","../src/pglite.ts","../../../node_modules/.pnpm/async-mutex@0.4.1/node_modules/async-mutex/index.mjs","../src/postgresMod.ts","../src/extensionUtils.ts","../src/interface.ts"],"sourcesContent":["export * from './pglite.js'\nexport * from './interface.js'\nexport * as types from './types.js'\nexport * as parse from './parse.js'\nexport * as messages from '@electric-sql/pg-protocol/messages'\nexport * as protocol from '@electric-sql/pg-protocol'\nexport { MemoryFS } from './fs/memoryfs.js'\nexport { IdbFs } from './fs/idbfs.js'\nexport { Mutex } from 'async-mutex'\nexport { uuid, formatQuery } from './utils.js'\n","import { Mutex } from 'async-mutex'\nimport PostgresModFactory, { type PostgresMod } from './postgresMod.js'\nimport { type Filesystem, parseDataDir, loadFs } from './fs/index.js'\nimport { instantiateWasm, getFsBundle, startWasmDownload } from './utils.js'\nimport type {\n  DebugLevel,\n  PGliteOptions,\n  PGliteInterface,\n  ExecProtocolOptions,\n  PGliteInterfaceExtensions,\n  Extensions,\n} from './interface.js'\nimport { BasePGlite } from './base.js'\nimport { loadExtensionBundle, loadExtensions } from './extensionUtils.js'\nimport { loadTar, DumpTarCompressionOptions } from './fs/tarUtils.js'\nimport { PGDATA, WASM_PREFIX } from './fs/index.js'\n\n// Importing the source as the built version is not ESM compatible\nimport { serialize, Parser as ProtocolParser } from '@electric-sql/pg-protocol'\nimport {\n  BackendMessage,\n  DatabaseError,\n  NoticeMessage,\n  CommandCompleteMessage,\n  NotificationResponseMessage,\n} from '@electric-sql/pg-protocol/messages'\n\nexport class PGlite\n  extends BasePGlite\n  implements PGliteInterface, AsyncDisposable\n{\n  fs?: Filesystem\n  protected mod?: PostgresMod\n\n  readonly dataDir?: string\n\n  #ready = false\n  #closing = false\n  #closed = false\n  #inTransaction = false\n  #relaxedDurability = false\n\n  readonly waitReady: Promise<void>\n\n  #queryMutex = new Mutex()\n  #transactionMutex = new Mutex()\n  #fsSyncMutex = new Mutex()\n  #fsSyncScheduled = false\n\n  readonly debug: DebugLevel = 0\n\n  #extensions: Extensions\n  #extensionsClose: Array<() => Promise<void>> = []\n\n  #protocolParser = new ProtocolParser()\n\n  // These are the current ArrayBuffer that is being read or written to\n  // during a query, such as COPY FROM or COPY TO.\n  #queryReadBuffer?: ArrayBuffer\n  #queryWriteChunks?: Uint8Array[]\n\n  #notifyListeners = new Map<string, Set<(payload: string) => void>>()\n  #globalNotifyListeners = new Set<(channel: string, payload: string) => void>()\n\n  /**\n   * Create a new PGlite instance\n   * @param dataDir The directory to store the database files\n   *                Prefix with idb:// to use indexeddb filesystem in the browser\n   *                Use memory:// to use in-memory filesystem\n   * @param options PGlite options\n   */\n  constructor(dataDir?: string, options?: PGliteOptions)\n\n  /**\n   * Create a new PGlite instance\n   * @param options PGlite options including the data directory\n   */\n  constructor(options?: PGliteOptions)\n\n  constructor(\n    dataDirOrPGliteOptions: string | PGliteOptions = {},\n    options: PGliteOptions = {},\n  ) {\n    super()\n    if (typeof dataDirOrPGliteOptions === 'string') {\n      options = {\n        dataDir: dataDirOrPGliteOptions,\n        ...options,\n      }\n    } else {\n      options = dataDirOrPGliteOptions\n    }\n    this.dataDir = options.dataDir\n\n    // Enable debug logging if requested\n    if (options?.debug !== undefined) {\n      this.debug = options.debug\n    }\n\n    // Enable relaxed durability if requested\n    if (options?.relaxedDurability !== undefined) {\n      this.#relaxedDurability = options.relaxedDurability\n    }\n\n    // Save the extensions for later use\n    this.#extensions = options.extensions ?? {}\n\n    // Initialize the database, and store the promise so we can wait for it to be ready\n    this.waitReady = this.#init(options ?? {})\n  }\n\n  /**\n   * Create a new PGlite instance with extensions on the Typescript interface\n   * (The main constructor does enable extensions, however due to the limitations\n   * of Typescript, the extensions are not available on the instance interface)\n   * @param options PGlite options including the data directory\n   * @returns A promise that resolves to the PGlite instance when it's ready.\n   */\n\n  static async create<O extends PGliteOptions>(\n    options?: O,\n  ): Promise<PGlite & PGliteInterfaceExtensions<O['extensions']>>\n\n  /**\n   * Create a new PGlite instance with extensions on the Typescript interface\n   * (The main constructor does enable extensions, however due to the limitations\n   * of Typescript, the extensions are not available on the instance interface)\n   * @param dataDir The directory to store the database files\n   *                Prefix with idb:// to use indexeddb filesystem in the browser\n   *                Use memory:// to use in-memory filesystem\n   * @param options PGlite options\n   * @returns A promise that resolves to the PGlite instance when it's ready.\n   */\n  static async create<O extends PGliteOptions>(\n    dataDir?: string,\n    options?: O,\n  ): Promise<PGlite & PGliteInterfaceExtensions<O['extensions']>>\n\n  static async create<O extends PGliteOptions>(\n    dataDirOrPGliteOptions?: string | O,\n    options?: O,\n  ): Promise<PGlite & PGliteInterfaceExtensions<O['extensions']>> {\n    const resolvedOpts: PGliteOptions =\n      typeof dataDirOrPGliteOptions === 'string'\n        ? {\n            dataDir: dataDirOrPGliteOptions,\n            ...(options ?? {}),\n          }\n        : dataDirOrPGliteOptions ?? {}\n\n    const pg = new PGlite(resolvedOpts)\n    await pg.waitReady\n    return pg as any\n  }\n\n  /**\n   * Initialize the database\n   * @returns A promise that resolves when the database is ready\n   */\n  async #init(options: PGliteOptions) {\n    if (options.fs) {\n      this.fs = options.fs\n    } else {\n      const { dataDir, fsType } = parseDataDir(options.dataDir)\n      this.fs = await loadFs(dataDir, fsType)\n    }\n\n    const extensionBundlePromises: Record<string, Promise<Blob | null>> = {}\n    const extensionInitFns: Array<() => Promise<void>> = []\n\n    const args = [\n      `PGDATA=${PGDATA}`,\n      `PREFIX=${WASM_PREFIX}`,\n      `PGUSER=${options.username ?? 'postgres'}`,\n      `PGDATABASE=${options.database ?? 'template1'}`,\n      'MODE=REACT',\n      'REPL=N',\n      // \"-F\", // Disable fsync (TODO: Only for in-memory mode?)\n      ...(this.debug ? ['-d', this.debug.toString()] : []),\n    ]\n\n    if (!options.wasmModule) {\n      // Start the wasm download in the background so it's ready when we need it\n      startWasmDownload()\n    }\n\n    // Get the fs bundle\n    // We don't await the loading of the fs bundle at this point as we can continue\n    // with other work.\n    // It's resolved value `fsBundleBuffer` is set and used in `getPreloadedPackage`\n    // which is called via `PostgresModFactory` after we have awaited\n    // `fsBundleBufferPromise` below.\n    const fsBundleBufferPromise = options.fsBundle\n      ? options.fsBundle.arrayBuffer()\n      : getFsBundle()\n    let fsBundleBuffer: ArrayBuffer\n    fsBundleBufferPromise.then((buffer) => {\n      fsBundleBuffer = buffer\n    })\n\n    let emscriptenOpts: Partial<PostgresMod> = {\n      WASM_PREFIX,\n      arguments: args,\n      INITIAL_MEMORY: options.initialMemory,\n      noExitRuntime: true,\n      ...(this.debug > 0\n        ? { print: console.info, printErr: console.error }\n        : { print: () => {}, printErr: () => {} }),\n      instantiateWasm: (imports, successCallback) => {\n        instantiateWasm(imports, options.wasmModule).then(\n          ({ instance, module }) => {\n            // @ts-ignore wrong type in Emscripten typings\n            successCallback(instance, module)\n          },\n        )\n        return {}\n      },\n      getPreloadedPackage: (remotePackageName, remotePackageSize) => {\n        if (remotePackageName === 'postgres.data') {\n          if (fsBundleBuffer.byteLength !== remotePackageSize) {\n            throw new Error(\n              `Invalid FS bundle size: ${fsBundleBuffer.byteLength} !== ${remotePackageSize}`,\n            )\n          }\n          return fsBundleBuffer\n        }\n        throw new Error(`Unknown package: ${remotePackageName}`)\n      },\n      preRun: [\n        (mod: any) => {\n          // Register /dev/blob device\n          // This is used to read and write blobs when used in COPY TO/FROM\n          // e.g. COPY mytable TO '/dev/blob' WITH (FORMAT binary)\n          // The data is returned by the query as a `blob` property in the results\n          const devId = mod.FS.makedev(64, 0)\n          const devOpt = {\n            open: (_stream: any) => {},\n            close: (_stream: any) => {},\n            read: (\n              _stream: any,\n              buffer: Uint8Array,\n              offset: number,\n              length: number,\n              position: number,\n            ) => {\n              const buf = this.#queryReadBuffer\n              if (!buf) {\n                throw new Error(\n                  'No /dev/blob File or Blob provided to read from',\n                )\n              }\n              const contents = new Uint8Array(buf)\n              if (position >= contents.length) return 0\n              const size = Math.min(contents.length - position, length)\n              for (let i = 0; i < size; i++) {\n                buffer[offset + i] = contents[position + i]\n              }\n              return size\n            },\n            write: (\n              _stream: any,\n              buffer: Uint8Array,\n              offset: number,\n              length: number,\n              _position: number,\n            ) => {\n              this.#queryWriteChunks ??= []\n              this.#queryWriteChunks.push(buffer.slice(offset, offset + length))\n              return length\n            },\n            llseek: (stream: any, offset: number, whence: number) => {\n              const buf = this.#queryReadBuffer\n              if (!buf) {\n                throw new Error('No /dev/blob File or Blob provided to llseek')\n              }\n              let position = offset\n              if (whence === 1) {\n                position += stream.position\n              } else if (whence === 2) {\n                position = new Uint8Array(buf).length\n              }\n              if (position < 0) {\n                throw new mod.FS.ErrnoError(28)\n              }\n              return position\n            },\n          }\n          mod.FS.registerDevice(devId, devOpt)\n          mod.FS.mkdev('/dev/blob', devId)\n        },\n      ],\n    }\n\n    emscriptenOpts = await this.fs!.emscriptenOpts(emscriptenOpts)\n\n    // # Setup extensions\n    // This is the first step of loading PGlite extensions\n    // We loop through each extension and call the setup function\n    // This amends the emscriptenOpts and can return:\n    // - emscriptenOpts: The updated emscripten options\n    // - namespaceObj: The namespace object to attach to the PGlite instance\n    // - init: A function to initialize the extension/plugin after the database is ready\n    // - close: A function to close/tidy-up the extension/plugin when the database is closed\n    for (const [extName, ext] of Object.entries(this.#extensions)) {\n      if (ext instanceof URL) {\n        // Extension with only a URL to a bundle\n        extensionBundlePromises[extName] = loadExtensionBundle(ext)\n      } else {\n        // Extension with JS setup function\n        const extRet = await ext.setup(this, emscriptenOpts)\n        if (extRet.emscriptenOpts) {\n          emscriptenOpts = extRet.emscriptenOpts\n        }\n        if (extRet.namespaceObj) {\n          const instance = this as any\n          instance[extName] = extRet.namespaceObj\n        }\n        if (extRet.bundlePath) {\n          extensionBundlePromises[extName] = loadExtensionBundle(\n            extRet.bundlePath,\n          ) // Don't await here, this is parallel\n        }\n        if (extRet.init) {\n          extensionInitFns.push(extRet.init)\n        }\n        if (extRet.close) {\n          this.#extensionsClose.push(extRet.close)\n        }\n      }\n    }\n    emscriptenOpts['pg_extensions'] = extensionBundlePromises\n\n    // Await the fs bundle - we do this just before calling PostgresModFactory\n    // as it needs the fs bundle to be ready.\n    await fsBundleBufferPromise\n\n    // Load the database engine\n    this.mod = await PostgresModFactory(emscriptenOpts)\n\n    // Sync the filesystem from any previous store\n    await this.fs!.initialSyncFs(this.mod.FS)\n\n    // If the user has provided a tarball to load the database from, do that now.\n    // We do this after the initial sync so that we can throw if the database\n    // already exists.\n    if (options.loadDataDir) {\n      if (this.mod.FS.analyzePath(PGDATA + '/PG_VERSION').exists) {\n        throw new Error('Database already exists, cannot load from tarball')\n      }\n      this.#log('pglite: loading data from tarball')\n      await loadTar(this.mod.FS, options.loadDataDir)\n    }\n\n    // Check and log if the database exists\n    if (this.mod.FS.analyzePath(PGDATA + '/PG_VERSION').exists) {\n      this.#log('pglite: found DB, resuming')\n    } else {\n      this.#log('pglite: no db')\n    }\n\n    // Start compiling dynamic extensions present in FS.\n    await loadExtensions(this.mod, (...args) => this.#log(...args))\n\n    // Initialize the database\n    const idb = this.mod._pg_initdb()\n\n    if (!idb) {\n      // This would be a sab worker crash before pg_initdb can be called\n      throw new Error('INITDB failed to return value')\n    }\n\n    // initdb states:\n    // - populating pgdata\n    // - reconnect a previous db\n    // - found valid db+user\n    // currently unhandled:\n    // - db does not exist\n    // - user is invalid for db\n\n    if (idb & 0b0001) {\n      // this would be a wasm crash inside pg_initdb from a sab worker.\n      throw new Error('INITDB failed')\n    } else if (idb & 0b0010) {\n      // initdb was called to init PGDATA if required\n      const pguser = options.username ?? 'postgres'\n      const pgdatabase = options.database ?? 'template1'\n      if (idb & 0b0100) {\n        // initdb has found a previous database\n        if (idb & (0b0100 | 0b1000)) {\n          // initdb found db+user, and we switched to that user\n        } else {\n          // TODO: invalid user for db?\n          throw new Error('Invalid db/user combination')\n        }\n      } else {\n        // initdb has created a new database for us, we can only continue if we are\n        // in template1 and the user is postgres\n        if (pgdatabase !== 'template1' && pguser !== 'postgres') {\n          // throw new Error(`Invalid database ${pgdatabase} requested`);\n          throw new Error(\n            'INITDB created a new datadir, but an alternative db/user was requested',\n          )\n        }\n      }\n    }\n\n    // Sync any changes back to the persisted store (if there is one)\n    // TODO: only sync here if initdb did init db.\n    await this.syncToFs()\n\n    this.#ready = true\n\n    // Set the search path to public for this connection\n    await this.exec('SET search_path TO public;')\n\n    // Init array types\n    await this._initArrayTypes()\n\n    // Init extensions\n    for (const initFn of extensionInitFns) {\n      await initFn()\n    }\n  }\n\n  /**\n   * The Postgres Emscripten Module\n   */\n  get Module() {\n    return this.mod!\n  }\n\n  /**\n   * The ready state of the database\n   */\n  get ready() {\n    return this.#ready && !this.#closing && !this.#closed\n  }\n\n  /**\n   * The closed state of the database\n   */\n  get closed() {\n    return this.#closed\n  }\n\n  /**\n   * Close the database\n   * @returns A promise that resolves when the database is closed\n   */\n  async close() {\n    await this._checkReady()\n    this.#closing = true\n\n    // Close all extensions\n    for (const closeFn of this.#extensionsClose) {\n      await closeFn()\n    }\n\n    // Close the database\n    try {\n      await this.execProtocol(serialize.end())\n      this.mod!._pg_shutdown()\n    } catch (e) {\n      const err = e as { name: string; status: number }\n      if (err.name === 'ExitStatus' && err.status === 0) {\n        // Database closed successfully\n        // An earlier build of PGlite would throw an error here when closing\n        // leaving this here for now. I believe it was a bug in Emscripten.\n      } else {\n        throw e\n      }\n    }\n\n    // Close the filesystem\n    await this.fs!.close(this.mod!.FS)\n\n    this.#closed = true\n    this.#closing = false\n  }\n\n  /**\n   * Close the database when the object exits scope\n   * Stage 3 ECMAScript Explicit Resource Management\n   * https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-2.html#using-declarations-and-explicit-resource-management\n   */\n  async [Symbol.asyncDispose]() {\n    await this.close()\n  }\n\n  /**\n   * Handle a file attached to the current query\n   * @param file The file to handle\n   */\n  async _handleBlob(blob?: File | Blob) {\n    this.#queryReadBuffer = blob ? await blob.arrayBuffer() : undefined\n  }\n\n  /**\n   * Cleanup the current file\n   */\n  async _cleanupBlob() {\n    this.#queryReadBuffer = undefined\n  }\n\n  /**\n   * Get the written blob from the current query\n   * @returns The written blob\n   */\n  async _getWrittenBlob(): Promise<Blob | undefined> {\n    if (!this.#queryWriteChunks) {\n      return undefined\n    }\n    const blob = new Blob(this.#queryWriteChunks)\n    this.#queryWriteChunks = undefined\n    return blob\n  }\n\n  /**\n   * Wait for the database to be ready\n   */\n  async _checkReady() {\n    if (this.#closing) {\n      throw new Error('PGlite is closing')\n    }\n    if (this.#closed) {\n      throw new Error('PGlite is closed')\n    }\n    if (!this.#ready) {\n      // Starting the database can take a while and it might not be ready yet\n      // We'll wait for it to be ready before continuing\n      await this.waitReady\n    }\n  }\n\n  /**\n   * Execute a postgres wire protocol message directly without wrapping the response.\n   * Only use if `execProtocol()` doesn't suite your needs.\n   *\n   * **Warning:** This bypasses PGlite's protocol wrappers that manage error/notice messages,\n   * transactions, and notification listeners. Only use if you need to bypass these wrappers and\n   * don't intend to use the above features.\n   *\n   * @param message The postgres wire protocol message to execute\n   * @returns The direct message data response produced by Postgres\n   */\n  async execProtocolRaw(\n    message: Uint8Array,\n    { syncToFs = true }: ExecProtocolOptions = {},\n  ) {\n    const msg_len = message.length\n    const mod = this.mod!\n\n    // >0 set buffer content type to wire protocol\n    // set buffer size so answer will be at size+0x2 pointer addr\n    mod._interactive_write(msg_len)\n\n    // copy whole buffer at addr 0x1\n    mod.HEAPU8.set(message, 1)\n\n    // execute the message\n    mod._interactive_one()\n\n    // Read responses from the buffer\n    const msg_start = msg_len + 2\n    const msg_end = msg_start + mod._interactive_read()\n    const data = mod.HEAPU8.subarray(msg_start, msg_end)\n\n    if (syncToFs) {\n      await this.syncToFs()\n    }\n\n    return data\n  }\n\n  /**\n   * Execute a postgres wire protocol message\n   * @param message The postgres wire protocol message to execute\n   * @returns The result of the query\n   */\n  async execProtocol(\n    message: Uint8Array,\n    {\n      syncToFs = true,\n      throwOnError = true,\n      onNotice,\n    }: ExecProtocolOptions = {},\n  ): Promise<Array<[BackendMessage, Uint8Array]>> {\n    const data = await this.execProtocolRaw(message, { syncToFs })\n    const results: Array<[BackendMessage, Uint8Array]> = []\n\n    this.#protocolParser.parse(data, (msg) => {\n      if (msg instanceof DatabaseError) {\n        this.#protocolParser = new ProtocolParser() // Reset the parser\n        if (throwOnError) {\n          throw msg\n        }\n        // TODO: Do we want to wrap the error in a custom error?\n      } else if (msg instanceof NoticeMessage) {\n        if (this.debug > 0) {\n          // Notice messages are warnings, we should log them\n          console.warn(msg)\n        }\n        if (onNotice) {\n          onNotice(msg)\n        }\n      } else if (msg instanceof CommandCompleteMessage) {\n        // Keep track of the transaction state\n        switch (msg.text) {\n          case 'BEGIN':\n            this.#inTransaction = true\n            break\n          case 'COMMIT':\n          case 'ROLLBACK':\n            this.#inTransaction = false\n            break\n        }\n      } else if (msg instanceof NotificationResponseMessage) {\n        // We've received a notification, call the listeners\n        const listeners = this.#notifyListeners.get(msg.channel)\n        if (listeners) {\n          listeners.forEach((cb) => {\n            // We use queueMicrotask so that the callback is called after any\n            // synchronous code has finished running.\n            queueMicrotask(() => cb(msg.payload))\n          })\n        }\n        this.#globalNotifyListeners.forEach((cb) => {\n          queueMicrotask(() => cb(msg.channel, msg.payload))\n        })\n      }\n      results.push([msg, data])\n    })\n\n    return results\n  }\n\n  /**\n   * Check if the database is in a transaction\n   * @returns True if the database is in a transaction, false otherwise\n   */\n  isInTransaction() {\n    return this.#inTransaction\n  }\n\n  /**\n   * Perform any sync operations implemented by the filesystem, this is\n   * run after every query to ensure that the filesystem is synced.\n   */\n  async syncToFs() {\n    if (this.#fsSyncScheduled) {\n      return\n    }\n    this.#fsSyncScheduled = true\n\n    const doSync = async () => {\n      await this.#fsSyncMutex.runExclusive(async () => {\n        this.#fsSyncScheduled = false\n        await this.fs!.syncToFs(this.mod!.FS, this.#relaxedDurability)\n      })\n    }\n\n    if (this.#relaxedDurability) {\n      doSync()\n    } else {\n      await doSync()\n    }\n  }\n\n  /**\n   * Internal log function\n   */\n  #log(...args: any[]) {\n    if (this.debug > 0) {\n      console.log(...args)\n    }\n  }\n\n  /**\n   * Listen for a notification\n   * @param channel The channel to listen on\n   * @param callback The callback to call when a notification is received\n   */\n  async listen(channel: string, callback: (payload: string) => void) {\n    if (!this.#notifyListeners.has(channel)) {\n      this.#notifyListeners.set(channel, new Set())\n    }\n    this.#notifyListeners.get(channel)!.add(callback)\n    await this.exec(`LISTEN \"${channel}\"`)\n    return async () => {\n      await this.unlisten(channel, callback)\n    }\n  }\n\n  /**\n   * Stop listening for a notification\n   * @param channel The channel to stop listening on\n   * @param callback The callback to remove\n   */\n  async unlisten(channel: string, callback?: (payload: string) => void) {\n    if (callback) {\n      this.#notifyListeners.get(channel)?.delete(callback)\n      if (this.#notifyListeners.get(channel)?.size === 0) {\n        await this.exec(`UNLISTEN \"${channel}\"`)\n        this.#notifyListeners.delete(channel)\n      }\n    } else {\n      await this.exec(`UNLISTEN \"${channel}\"`)\n      this.#notifyListeners.delete(channel)\n    }\n  }\n\n  /**\n   * Listen to notifications\n   * @param callback The callback to call when a notification is received\n   */\n  onNotification(\n    callback: (channel: string, payload: string) => void,\n  ): () => void {\n    this.#globalNotifyListeners.add(callback)\n    return () => {\n      this.#globalNotifyListeners.delete(callback)\n    }\n  }\n\n  /**\n   * Stop listening to notifications\n   * @param callback The callback to remove\n   */\n  offNotification(callback: (channel: string, payload: string) => void) {\n    this.#globalNotifyListeners.delete(callback)\n  }\n\n  /**\n   * Dump the PGDATA dir from the filesystem to a gziped tarball.\n   * @param compression The compression options to use - 'gzip', 'auto', 'none'\n   * @returns The tarball as a File object where available, and fallback to a Blob\n   */\n  async dumpDataDir(\n    compression?: DumpTarCompressionOptions,\n  ): Promise<File | Blob> {\n    const dbname = this.dataDir?.split('/').pop() ?? 'pgdata'\n    return this.fs!.dumpTar(this.mod!.FS, dbname, compression)\n  }\n\n  /**\n   * Run a function in a mutex that's exclusive to queries\n   * @param fn The query to run\n   * @returns The result of the query\n   */\n  _runExclusiveQuery<T>(fn: () => Promise<T>): Promise<T> {\n    return this.#queryMutex.runExclusive(fn)\n  }\n\n  /**\n   * Run a function in a mutex that's exclusive to transactions\n   * @param fn The function to run\n   * @returns The result of the function\n   */\n  _runExclusiveTransaction<T>(fn: () => Promise<T>): Promise<T> {\n    return this.#transactionMutex.runExclusive(fn)\n  }\n}\n","const E_TIMEOUT = new Error('timeout while waiting for mutex to become available');\nconst E_ALREADY_LOCKED = new Error('mutex already locked');\nconst E_CANCELED = new Error('request for lock canceled');\n\nvar __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Semaphore {\n    constructor(_value, _cancelError = E_CANCELED) {\n        this._value = _value;\n        this._cancelError = _cancelError;\n        this._weightedQueues = [];\n        this._weightedWaiters = [];\n    }\n    acquire(weight = 1) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        return new Promise((resolve, reject) => {\n            if (!this._weightedQueues[weight - 1])\n                this._weightedQueues[weight - 1] = [];\n            this._weightedQueues[weight - 1].push({ resolve, reject });\n            this._dispatch();\n        });\n    }\n    runExclusive(callback, weight = 1) {\n        return __awaiter$2(this, void 0, void 0, function* () {\n            const [value, release] = yield this.acquire(weight);\n            try {\n                return yield callback(value);\n            }\n            finally {\n                release();\n            }\n        });\n    }\n    waitForUnlock(weight = 1) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        return new Promise((resolve) => {\n            if (!this._weightedWaiters[weight - 1])\n                this._weightedWaiters[weight - 1] = [];\n            this._weightedWaiters[weight - 1].push(resolve);\n            this._dispatch();\n        });\n    }\n    isLocked() {\n        return this._value <= 0;\n    }\n    getValue() {\n        return this._value;\n    }\n    setValue(value) {\n        this._value = value;\n        this._dispatch();\n    }\n    release(weight = 1) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        this._value += weight;\n        this._dispatch();\n    }\n    cancel() {\n        this._weightedQueues.forEach((queue) => queue.forEach((entry) => entry.reject(this._cancelError)));\n        this._weightedQueues = [];\n    }\n    _dispatch() {\n        var _a;\n        for (let weight = this._value; weight > 0; weight--) {\n            const queueEntry = (_a = this._weightedQueues[weight - 1]) === null || _a === void 0 ? void 0 : _a.shift();\n            if (!queueEntry)\n                continue;\n            const previousValue = this._value;\n            const previousWeight = weight;\n            this._value -= weight;\n            weight = this._value + 1;\n            queueEntry.resolve([previousValue, this._newReleaser(previousWeight)]);\n        }\n        this._drainUnlockWaiters();\n    }\n    _newReleaser(weight) {\n        let called = false;\n        return () => {\n            if (called)\n                return;\n            called = true;\n            this.release(weight);\n        };\n    }\n    _drainUnlockWaiters() {\n        for (let weight = this._value; weight > 0; weight--) {\n            if (!this._weightedWaiters[weight - 1])\n                continue;\n            this._weightedWaiters[weight - 1].forEach((waiter) => waiter());\n            this._weightedWaiters[weight - 1] = [];\n        }\n    }\n}\n\nvar __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Mutex {\n    constructor(cancelError) {\n        this._semaphore = new Semaphore(1, cancelError);\n    }\n    acquire() {\n        return __awaiter$1(this, void 0, void 0, function* () {\n            const [, releaser] = yield this._semaphore.acquire();\n            return releaser;\n        });\n    }\n    runExclusive(callback) {\n        return this._semaphore.runExclusive(() => callback());\n    }\n    isLocked() {\n        return this._semaphore.isLocked();\n    }\n    waitForUnlock() {\n        return this._semaphore.waitForUnlock();\n    }\n    release() {\n        if (this._semaphore.isLocked())\n            this._semaphore.release();\n    }\n    cancel() {\n        return this._semaphore.cancel();\n    }\n}\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nfunction withTimeout(sync, timeout, timeoutError = E_TIMEOUT) {\n    return {\n        acquire: (weight) => {\n            if (weight !== undefined && weight <= 0) {\n                throw new Error(`invalid weight ${weight}: must be positive`);\n            }\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                let isTimeout = false;\n                const handle = setTimeout(() => {\n                    isTimeout = true;\n                    reject(timeoutError);\n                }, timeout);\n                try {\n                    const ticket = yield sync.acquire(weight);\n                    if (isTimeout) {\n                        const release = Array.isArray(ticket) ? ticket[1] : ticket;\n                        release();\n                    }\n                    else {\n                        clearTimeout(handle);\n                        resolve(ticket);\n                    }\n                }\n                catch (e) {\n                    if (!isTimeout) {\n                        clearTimeout(handle);\n                        reject(e);\n                    }\n                }\n            }));\n        },\n        runExclusive(callback, weight) {\n            return __awaiter(this, void 0, void 0, function* () {\n                let release = () => undefined;\n                try {\n                    const ticket = yield this.acquire(weight);\n                    if (Array.isArray(ticket)) {\n                        release = ticket[1];\n                        return yield callback(ticket[0]);\n                    }\n                    else {\n                        release = ticket;\n                        return yield callback();\n                    }\n                }\n                finally {\n                    release();\n                }\n            });\n        },\n        release(weight) {\n            sync.release(weight);\n        },\n        cancel() {\n            return sync.cancel();\n        },\n        waitForUnlock: (weight) => {\n            if (weight !== undefined && weight <= 0) {\n                throw new Error(`invalid weight ${weight}: must be positive`);\n            }\n            return new Promise((resolve, reject) => {\n                const handle = setTimeout(() => reject(timeoutError), timeout);\n                sync.waitForUnlock(weight).then(() => {\n                    clearTimeout(handle);\n                    resolve();\n                });\n            });\n        },\n        isLocked: () => sync.isLocked(),\n        getValue: () => sync.getValue(),\n        setValue: (value) => sync.setValue(value),\n    };\n}\n\n// eslint-disable-next-lisne @typescript-eslint/explicit-module-boundary-types\nfunction tryAcquire(sync, alreadyAcquiredError = E_ALREADY_LOCKED) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return withTimeout(sync, 0, alreadyAcquiredError);\n}\n\nexport { E_ALREADY_LOCKED, E_CANCELED, E_TIMEOUT, Mutex, Semaphore, tryAcquire, withTimeout };\n","import PostgresModFactory from '../release/postgres.js'\n\ntype IDBFS = Emscripten.FileSystemType & {\n  quit: () => void\n  dbs: Record<string, IDBDatabase>\n}\n\nexport type FS = typeof FS & {\n  filesystems: {\n    MEMFS: Emscripten.FileSystemType\n    NODEFS: Emscripten.FileSystemType\n    IDBFS: IDBFS\n  }\n  quit: () => void\n}\n\nexport interface PostgresMod\n  extends Omit<EmscriptenModule, 'preInit' | 'preRun' | 'postRun'> {\n  preInit: Array<{ (mod: PostgresMod): void }>\n  preRun: Array<{ (mod: PostgresMod): void }>\n  postRun: Array<{ (mod: PostgresMod): void }>\n  FS: FS\n  WASM_PREFIX: string\n  INITIAL_MEMORY: number\n  pg_extensions: Record<string, Promise<Blob | null>>\n  _pg_initdb: () => number\n  _pg_shutdown: () => void\n  _interactive_write: (msgLength: number) => void\n  _interactive_one: () => void\n  _interactive_read: () => number\n}\n\ntype PostgresFactory<T extends PostgresMod = PostgresMod> = (\n  moduleOverrides?: Partial<T>,\n) => Promise<T>\n\nexport default PostgresModFactory as PostgresFactory<PostgresMod>\n","import tinyTar from 'tinytar'\nimport { IN_NODE } from './utils.js'\nimport type { PostgresMod } from './postgresMod.js'\n\nexport async function loadExtensionBundle(\n  bundlePath: URL,\n): Promise<Blob | null> {\n  // Async load the extension bundle tar file\n  // could be from a URL or a file\n  if (IN_NODE) {\n    const fs = await import('fs')\n    const zlib = await import('zlib')\n    const { Writable } = await import('stream')\n    const { pipeline } = await import('stream/promises')\n\n    if (!fs.existsSync(bundlePath)) {\n      throw new Error(`Extension bundle not found: ${bundlePath}`)\n    }\n\n    const gunzip = zlib.createGunzip()\n    const chunks: Uint8Array[] = []\n\n    await pipeline(\n      fs.createReadStream(bundlePath),\n      gunzip,\n      new Writable({\n        write(chunk, _encoding, callback) {\n          chunks.push(chunk)\n          callback()\n        },\n      }),\n    )\n    return new Blob(chunks)\n  } else {\n    const response = await fetch(bundlePath.toString())\n    if (!response.ok || !response.body) {\n      return null\n    } else if (response.headers.get('Content-Encoding') === 'gzip') {\n      // Although the bundle is manually compressed, some servers will recognize\n      // that and add a content-encoding header. Fetch will then automatically\n      // decompress the response.\n      return response.blob()\n    } else {\n      const decompressionStream = new DecompressionStream('gzip')\n      const decompressedStream = new Response(\n        response.body.pipeThrough(decompressionStream),\n      )\n      return decompressedStream.blob()\n    }\n  }\n}\n\nexport async function loadExtensions(\n  mod: PostgresMod,\n  log: (...args: any[]) => void,\n) {\n  for (const ext in mod.pg_extensions) {\n    let blob\n    try {\n      blob = await mod.pg_extensions[ext]\n    } catch (err) {\n      console.error('Failed to fetch extension:', ext, err)\n      continue\n    }\n    if (blob) {\n      const bytes = new Uint8Array(await blob.arrayBuffer())\n      loadExtension(mod, ext, bytes, log)\n    } else {\n      console.error('Could not get binary data for extension:', ext)\n    }\n  }\n}\n\nfunction loadExtension(\n  mod: PostgresMod,\n  _ext: string,\n  bytes: Uint8Array,\n  log: (...args: any[]) => void,\n) {\n  const data = tinyTar.untar(bytes)\n  data.forEach((file: any) => {\n    if (!file.name.startsWith('.')) {\n      const filePath = mod.WASM_PREFIX + '/' + file.name\n      if (file.name.endsWith('.so')) {\n        const extOk = (...args: any[]) => {\n          log('pgfs:ext OK', filePath, args)\n        }\n        const extFail = (...args: any[]) => {\n          log('pgfs:ext FAIL', filePath, args)\n        }\n        mod.FS.createPreloadedFile(\n          dirname(filePath),\n          file.name.split('/').pop()!.slice(0, -3),\n          file.data as any, // There is a type error in Emscripten's FS.createPreloadedFile, this excepts a Uint8Array, but the type is defined as any\n          true,\n          true,\n          extOk,\n          extFail,\n          false,\n        )\n      } else {\n        mod.FS.writeFile(filePath, file.data)\n      }\n    }\n  })\n}\n\nfunction dirname(path: string) {\n  const last = path.lastIndexOf('/')\n  if (last > 0) {\n    return path.slice(0, last)\n  } else {\n    return path\n  }\n}\n","import type {\n  BackendMessage,\n  NoticeMessage,\n} from '@electric-sql/pg-protocol/messages'\nimport type { Filesystem } from './fs/types.js'\nimport type { DumpTarCompressionOptions } from './fs/tarUtils.js'\n\nexport type FilesystemType = 'nodefs' | 'idbfs' | 'memoryfs'\n\nexport type DebugLevel = 0 | 1 | 2 | 3 | 4 | 5\n\nexport type RowMode = 'array' | 'object'\n\nexport interface ParserOptions {\n  [pgType: number]: (value: string) => any\n}\n\nexport interface QueryOptions {\n  rowMode?: RowMode\n  parsers?: ParserOptions\n  blob?: Blob | File\n  onNotice?: (notice: NoticeMessage) => void\n  paramTypes?: number[]\n}\n\nexport interface ExecProtocolOptions {\n  syncToFs?: boolean\n  throwOnError?: boolean\n  onNotice?: (notice: NoticeMessage) => void\n}\n\nexport interface ExtensionSetupResult {\n  emscriptenOpts?: any\n  namespaceObj?: any\n  bundlePath?: URL\n  init?: () => Promise<void>\n  close?: () => Promise<void>\n}\n\nexport type ExtensionSetup = (\n  pg: PGliteInterface,\n  emscriptenOpts: any,\n  clientOnly?: boolean,\n) => Promise<ExtensionSetupResult>\n\nexport interface Extension {\n  name: string\n  setup: ExtensionSetup\n}\n\nexport type Extensions = {\n  [namespace: string]: Extension | URL\n}\n\nexport interface DumpDataDirResult {\n  tarball: Uint8Array\n  extension: '.tar' | '.tgz'\n  filename: string\n}\n\nexport interface PGliteOptions {\n  dataDir?: string\n  username?: string\n  database?: string\n  fs?: Filesystem\n  debug?: DebugLevel\n  relaxedDurability?: boolean\n  extensions?: Extensions\n  loadDataDir?: Blob | File\n  initialMemory?: number\n  wasmModule?: WebAssembly.Module\n  fsBundle?: Blob | File\n}\n\nexport type PGliteInterface = {\n  readonly waitReady: Promise<void>\n  readonly debug: DebugLevel\n  readonly ready: boolean\n  readonly closed: boolean\n\n  close(): Promise<void>\n  query<T>(\n    query: string,\n    params?: any[],\n    options?: QueryOptions,\n  ): Promise<Results<T>>\n  sql<T>(\n    sqlStrings: TemplateStringsArray,\n    ...params: any[]\n  ): Promise<Results<T>>\n  exec(query: string, options?: QueryOptions): Promise<Array<Results>>\n  transaction<T>(\n    callback: (tx: Transaction) => Promise<T>,\n  ): Promise<T | undefined>\n  execProtocolRaw(\n    message: Uint8Array,\n    options?: ExecProtocolOptions,\n  ): Promise<Uint8Array>\n  execProtocol(\n    message: Uint8Array,\n    options?: ExecProtocolOptions,\n  ): Promise<Array<[BackendMessage, Uint8Array]>>\n  listen(\n    channel: string,\n    callback: (payload: string) => void,\n  ): Promise<() => Promise<void>>\n  unlisten(channel: string, callback?: (payload: string) => void): Promise<void>\n  onNotification(\n    callback: (channel: string, payload: string) => void,\n  ): () => void\n  offNotification(callback: (channel: string, payload: string) => void): void\n  dumpDataDir(compression?: DumpTarCompressionOptions): Promise<File | Blob>\n}\n\nexport type PGliteInterfaceExtensions<E> = E extends Extensions\n  ? {\n      [K in keyof E]: E[K] extends Extension\n        ? Awaited<ReturnType<E[K]['setup']>>['namespaceObj'] extends infer N\n          ? N extends undefined | null | void\n            ? never\n            : N\n          : never\n        : never\n    }\n  : Record<string, never>\n\nexport type Row<T = { [key: string]: any }> = T\n\nexport type Results<T = { [key: string]: any }> = {\n  rows: Row<T>[]\n  affectedRows?: number\n  fields: { name: string; dataTypeID: number }[]\n  blob?: Blob // Only set when a file is returned, such as from a COPY command\n}\n\nexport interface Transaction {\n  query<T>(\n    query: string,\n    params?: any[],\n    options?: QueryOptions,\n  ): Promise<Results<T>>\n  sql<T>(\n    sqlStrings: TemplateStringsArray,\n    ...params: any[]\n  ): Promise<Results<T>>\n  exec(query: string, options?: QueryOptions): Promise<Array<Results>>\n  rollback(): Promise<void>\n  get closed(): boolean\n}\n"],"mappings":"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","names":["init_esm_shims","init_esm_shims","init_esm_shims","E_TIMEOUT","E_ALREADY_LOCKED","E_CANCELED","__awaiter$2","thisArg","_arguments","P","generator","adopt","value","resolve","reject","fulfilled","step","e","rejected","result","Semaphore","_value","_cancelError","weight","callback","release","queue","entry","_a","queueEntry","previousValue","previousWeight","called","waiter","__awaiter$1","Mutex","cancelError","releaser","init_esm_shims","PostgresModFactory","postgresMod_default","init_esm_shims","import_tinytar","loadExtensionBundle","bundlePath","IN_NODE","fs","zlib","Writable","pipeline","gunzip","chunks","chunk","_encoding","callback","response","decompressionStream","loadExtensions","mod","log","ext","blob","err","bytes","loadExtension","_ext","tinyTar","file","filePath","extOk","args","extFail","dirname","path","last","_ready","_closing","_closed","_inTransaction","_relaxedDurability","_queryMutex","_transactionMutex","_fsSyncMutex","_fsSyncScheduled","_extensions","_extensionsClose","_protocolParser","_queryReadBuffer","_queryWriteChunks","_notifyListeners","_globalNotifyListeners","_PGlite_instances","init_fn","log_fn","_PGlite","BasePGlite","dataDirOrPGliteOptions","options","__privateAdd","Mutex","Parser","__privateSet","__privateMethod","resolvedOpts","pg","__privateGet","closeFn","serialize","err","blob","message","syncToFs","msg_len","mod","msg_start","msg_end","data","throwOnError","onNotice","results","msg","DatabaseError","NoticeMessage","CommandCompleteMessage","NotificationResponseMessage","listeners","cb","doSync","channel","callback","compression","dbname","fn","dataDir","fsType","parseDataDir","loadFs","extensionBundlePromises","extensionInitFns","args","PGDATA","WASM_PREFIX","startWasmDownload","fsBundleBufferPromise","getFsBundle","fsBundleBuffer","buffer","emscriptenOpts","imports","successCallback","instantiateWasm","instance","module","remotePackageName","remotePackageSize","devId","devOpt","_stream","offset","length","position","buf","contents","size","i","_position","stream","whence","extName","ext","loadExtensionBundle","extRet","postgresMod_default","loadTar","loadExtensions","idb","pguser","pgdatabase","initFn","PGlite","init_esm_shims"]}